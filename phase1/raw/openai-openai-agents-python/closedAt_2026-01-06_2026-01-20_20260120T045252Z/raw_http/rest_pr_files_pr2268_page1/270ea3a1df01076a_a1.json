{
  "finished_at": "2026-01-20T04:54:54.191940Z",
  "meta": {
    "attempt": 1,
    "request_fingerprint": "270ea3a1df01076a",
    "tag": "rest_pr_files_pr2268_page1"
  },
  "request": {
    "body": null,
    "headers": {
      "Accept": "application/vnd.github+json",
      "X-GitHub-Api-Version": "2022-11-28"
    },
    "method": "GET",
    "url": "https://api.github.com/repos/openai/openai-agents-python/pulls/2268/files?per_page=100&page=1"
  },
  "response": {
    "headers": {
      "access-control-allow-origin": "*",
      "access-control-expose-headers": "ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Resource, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, X-GitHub-SSO, X-GitHub-Request-Id, Deprecation, Sunset",
      "cache-control": "private, max-age=60, s-maxage=60",
      "content-length": "14927",
      "content-security-policy": "default-src 'none'",
      "content-type": "application/json; charset=utf-8",
      "date": "Tue, 20 Jan 2026 04:54:54 GMT",
      "etag": "\"78ff93603d69be5b5ba8540609a29a1524b3e71b901262b5d19c2de37dec184f\"",
      "github-authentication-token-expiration": "2026-02-19 04:41:20 UTC",
      "last-modified": "Mon, 19 Jan 2026 11:04:38 GMT",
      "referrer-policy": "origin-when-cross-origin, strict-origin-when-cross-origin",
      "server": "github.com",
      "strict-transport-security": "max-age=31536000; includeSubdomains; preload",
      "vary": "Accept, Authorization, Cookie, X-GitHub-OTP,Accept-Encoding, Accept, X-Requested-With",
      "x-accepted-oauth-scopes": "",
      "x-content-type-options": "nosniff",
      "x-frame-options": "deny",
      "x-github-api-version-selected": "2022-11-28",
      "x-github-media-type": "github.v3; format=json",
      "x-github-request-id": "DB4D:2B2B06:166ACF5:1F75720:696F0A9D",
      "x-oauth-scopes": "repo",
      "x-ratelimit-limit": "5000",
      "x-ratelimit-remaining": "4978",
      "x-ratelimit-reset": "1768885989",
      "x-ratelimit-resource": "core",
      "x-ratelimit-used": "22",
      "x-xss-protection": "0"
    },
    "json": [
      {
        "additions": 179,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/dc428fad5fdb8956000733dd3f95d2d05297741a/src%2Fagents%2Fmcp%2Fserver.py",
        "changes": 198,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/src%2Fagents%2Fmcp%2Fserver.py?ref=dc428fad5fdb8956000733dd3f95d2d05297741a",
        "deletions": 19,
        "filename": "src/agents/mcp/server.py",
        "patch": "@@ -3,12 +3,17 @@\n import abc\n import asyncio\n import inspect\n+import sys\n from collections.abc import Awaitable\n from contextlib import AbstractAsyncContextManager, AsyncExitStack\n from datetime import timedelta\n from pathlib import Path\n from typing import TYPE_CHECKING, Any, Callable, Literal, TypeVar\n \n+import httpx\n+\n+if sys.version_info < (3, 11):\n+    from exceptiongroup import BaseExceptionGroup  # pyright: ignore[reportMissingImports]\n from anyio.streams.memory import MemoryObjectReceiveStream, MemoryObjectSendStream\n from mcp import ClientSession, StdioServerParameters, Tool as MCPTool, stdio_client\n from mcp.client.session import MessageHandlerFnT\n@@ -251,6 +256,35 @@ def invalidate_tools_cache(self):\n         \"\"\"Invalidate the tools cache.\"\"\"\n         self._cache_dirty = True\n \n+    def _extract_http_error_from_exception(self, e: Exception) -> Exception | None:\n+        \"\"\"Extract HTTP error from exception or ExceptionGroup.\"\"\"\n+        if isinstance(e, (httpx.HTTPStatusError, httpx.ConnectError, httpx.TimeoutException)):\n+            return e\n+\n+        # Check if it's an ExceptionGroup containing HTTP errors\n+        if isinstance(e, BaseExceptionGroup):\n+            for exc in e.exceptions:\n+                if isinstance(\n+                    exc, (httpx.HTTPStatusError, httpx.ConnectError, httpx.TimeoutException)\n+                ):\n+                    return exc\n+\n+        return None\n+\n+    def _raise_user_error_for_http_error(self, http_error: Exception) -> None:\n+        \"\"\"Raise appropriate UserError for HTTP error.\"\"\"\n+        error_message = f\"Failed to connect to MCP server '{self.name}': \"\n+        if isinstance(http_error, httpx.HTTPStatusError):\n+            error_message += f\"HTTP error {http_error.response.status_code} ({http_error.response.reason_phrase})\"  # noqa: E501\n+\n+        elif isinstance(http_error, httpx.ConnectError):\n+            error_message += \"Could not reach the server.\"\n+\n+        elif isinstance(http_error, httpx.TimeoutException):\n+            error_message += \"Connection timeout.\"\n+\n+        raise UserError(error_message) from http_error\n+\n     async def _run_with_retries(self, func: Callable[[], Awaitable[T]]) -> T:\n         attempts = 0\n         while True:\n@@ -265,6 +299,7 @@ async def _run_with_retries(self, func: Callable[[], Awaitable[T]]) -> T:\n \n     async def connect(self):\n         \"\"\"Connect to the server.\"\"\"\n+        connection_succeeded = False\n         try:\n             transport = await self.exit_stack.enter_async_context(self.create_streams())\n             # streamablehttp_client returns (read, write, get_session_id)\n@@ -285,10 +320,49 @@ async def connect(self):\n             server_result = await session.initialize()\n             self.server_initialize_result = server_result\n             self.session = session\n+            connection_succeeded = True\n         except Exception as e:\n-            logger.error(f\"Error initializing MCP server: {e}\")\n-            await self.cleanup()\n+            # Try to extract HTTP error from exception or ExceptionGroup\n+            http_error = self._extract_http_error_from_exception(e)\n+            if http_error:\n+                self._raise_user_error_for_http_error(http_error)\n+\n+            # For CancelledError, preserve cancellation semantics - don't wrap it.\n+            # If it's masking an HTTP error, cleanup() will extract and raise UserError.\n+            if isinstance(e, asyncio.CancelledError):\n+                raise\n+\n+            # For HTTP-related errors, wrap them\n+            if isinstance(e, (httpx.HTTPStatusError, httpx.ConnectError, httpx.TimeoutException)):\n+                self._raise_user_error_for_http_error(e)\n+\n+            # For other errors, re-raise as-is (don't wrap non-HTTP errors)\n             raise\n+        finally:\n+            # Always attempt cleanup on error, but suppress cleanup errors that mask the original\n+            if not connection_succeeded:\n+                try:\n+                    await self.cleanup()\n+                except UserError:\n+                    # Re-raise UserError from cleanup (contains the real HTTP error)\n+                    raise\n+                except Exception as cleanup_error:\n+                    # Suppress RuntimeError about cancel scopes during cleanup - this is a known\n+                    # issue with the MCP library's async generator cleanup and shouldn't mask the\n+                    # original error\n+                    if isinstance(cleanup_error, RuntimeError) and \"cancel scope\" in str(\n+                        cleanup_error\n+                    ):\n+                        logger.debug(\n+                            f\"Ignoring cancel scope error during cleanup of MCP server \"\n+                            f\"'{self.name}': {cleanup_error}\"\n+                        )\n+                    else:\n+                        # Log other cleanup errors but don't raise - original error is more\n+                        # important\n+                        logger.warning(\n+                            f\"Error during cleanup of MCP server '{self.name}': {cleanup_error}\"\n+                        )\n \n     async def list_tools(\n         self,\n@@ -301,21 +375,32 @@ async def list_tools(\n         session = self.session\n         assert session is not None\n \n-        # Return from cache if caching is enabled, we have tools, and the cache is not dirty\n-        if self.cache_tools_list and not self._cache_dirty and self._tools_list:\n-            tools = self._tools_list\n-        else:\n-            # Fetch the tools from the server\n-            result = await self._run_with_retries(lambda: session.list_tools())\n-            self._tools_list = result.tools\n-            self._cache_dirty = False\n-            tools = self._tools_list\n-\n-        # Filter tools based on tool_filter\n-        filtered_tools = tools\n-        if self.tool_filter is not None:\n-            filtered_tools = await self._apply_tool_filter(filtered_tools, run_context, agent)\n-        return filtered_tools\n+        try:\n+            # Return from cache if caching is enabled, we have tools, and the cache is not dirty\n+            if self.cache_tools_list and not self._cache_dirty and self._tools_list:\n+                tools = self._tools_list\n+            else:\n+                # Fetch the tools from the server\n+                result = await self._run_with_retries(lambda: session.list_tools())\n+                self._tools_list = result.tools\n+                self._cache_dirty = False\n+                tools = self._tools_list\n+\n+            # Filter tools based on tool_filter\n+            filtered_tools = tools\n+            if self.tool_filter is not None:\n+                filtered_tools = await self._apply_tool_filter(filtered_tools, run_context, agent)\n+            return filtered_tools\n+        except httpx.HTTPStatusError as e:\n+            status_code = e.response.status_code\n+            raise UserError(\n+                f\"Failed to list tools from MCP server '{self.name}': HTTP error {status_code}\"\n+            ) from e\n+        except httpx.ConnectError as e:\n+            raise UserError(\n+                f\"Failed to list tools from MCP server '{self.name}': Connection lost. \"\n+                f\"The server may have disconnected.\"\n+            ) from e\n \n     async def call_tool(self, tool_name: str, arguments: dict[str, Any] | None) -> CallToolResult:\n         \"\"\"Invoke a tool on the server.\"\"\"\n@@ -324,7 +409,19 @@ async def call_tool(self, tool_name: str, arguments: dict[str, Any] | None) -> C\n         session = self.session\n         assert session is not None\n \n-        return await self._run_with_retries(lambda: session.call_tool(tool_name, arguments))\n+        try:\n+            return await self._run_with_retries(lambda: session.call_tool(tool_name, arguments))\n+        except httpx.HTTPStatusError as e:\n+            status_code = e.response.status_code\n+            raise UserError(\n+                f\"Failed to call tool '{tool_name}' on MCP server '{self.name}': \"\n+                f\"HTTP error {status_code}\"\n+            ) from e\n+        except httpx.ConnectError as e:\n+            raise UserError(\n+                f\"Failed to call tool '{tool_name}' on MCP server '{self.name}': Connection lost. \"\n+                f\"The server may have disconnected.\"\n+            ) from e\n \n     async def list_prompts(\n         self,\n@@ -347,10 +444,73 @@ async def get_prompt(\n     async def cleanup(self):\n         \"\"\"Cleanup the server.\"\"\"\n         async with self._cleanup_lock:\n+            # Only raise HTTP errors if we're cleaning up after a failed connection.\n+            # During normal teardown (via __aexit__), log but don't raise to avoid\n+            # masking the original exception.\n+            is_failed_connection_cleanup = self.session is None\n+\n             try:\n                 await self.exit_stack.aclose()\n+            except BaseExceptionGroup as eg:\n+                # Extract HTTP errors from ExceptionGroup raised during cleanup\n+                # This happens when background tasks fail (e.g., HTTP errors)\n+                http_error = None\n+                connect_error = None\n+                timeout_error = None\n+                error_message = f\"Failed to connect to MCP server '{self.name}': \"\n+\n+                for exc in eg.exceptions:\n+                    if isinstance(exc, httpx.HTTPStatusError):\n+                        http_error = exc\n+                    elif isinstance(exc, httpx.ConnectError):\n+                        connect_error = exc\n+                    elif isinstance(exc, httpx.TimeoutException):\n+                        timeout_error = exc\n+\n+                # Only raise HTTP errors if we're cleaning up after a failed connection.\n+                # During normal teardown, log them instead.\n+                if http_error:\n+                    if is_failed_connection_cleanup:\n+                        error_message += f\"HTTP error {http_error.response.status_code} ({http_error.response.reason_phrase})\"  # noqa: E501\n+                        raise UserError(error_message) from http_error\n+                    else:\n+                        # Normal teardown - log but don't raise\n+                        logger.warning(\n+                            f\"HTTP error during cleanup of MCP server '{self.name}': {http_error}\"\n+                        )\n+                elif connect_error:\n+                    if is_failed_connection_cleanup:\n+                        error_message += \"Could not reach the server.\"\n+                        raise UserError(error_message) from connect_error\n+                    else:\n+                        logger.warning(\n+                            f\"Connection error during cleanup of MCP server '{self.name}': {connect_error}\"  # noqa: E501\n+                        )\n+                elif timeout_error:\n+                    if is_failed_connection_cleanup:\n+                        error_message += \"Connection timeout.\"\n+                        raise UserError(error_message) from timeout_error\n+                    else:\n+                        logger.warning(\n+                            f\"Timeout error during cleanup of MCP server '{self.name}': {timeout_error}\"  # noqa: E501\n+                        )\n+                else:\n+                    # No HTTP error found, suppress RuntimeError about cancel scopes\n+                    has_cancel_scope_error = any(\n+                        isinstance(exc, RuntimeError) and \"cancel scope\" in str(exc)\n+                        for exc in eg.exceptions\n+                    )\n+                    if has_cancel_scope_error:\n+                        logger.debug(f\"Ignoring cancel scope error during cleanup: {eg}\")\n+                    else:\n+                        logger.error(f\"Error cleaning up server: {eg}\")\n             except Exception as e:\n-                logger.error(f\"Error cleaning up server: {e}\")\n+                # Suppress RuntimeError about cancel scopes - this is a known issue with the MCP\n+                # library when background tasks fail during async generator cleanup\n+                if isinstance(e, RuntimeError) and \"cancel scope\" in str(e):\n+                    logger.debug(f\"Ignoring cancel scope error during cleanup: {e}\")\n+                else:\n+                    logger.error(f\"Error cleaning up server: {e}\")\n             finally:\n                 self.session = None\n ",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/dc428fad5fdb8956000733dd3f95d2d05297741a/src%2Fagents%2Fmcp%2Fserver.py",
        "sha": "015b5b6f76d0cf9ef843b5a623ae4b8df95c2858",
        "status": "modified"
      },
      {
        "additions": 7,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/dc428fad5fdb8956000733dd3f95d2d05297741a/src%2Fagents%2Fmcp%2Futil.py",
        "changes": 9,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/src%2Fagents%2Fmcp%2Futil.py?ref=dc428fad5fdb8956000733dd3f95d2d05297741a",
        "deletions": 2,
        "filename": "src/agents/mcp/util.py",
        "patch": "@@ -201,9 +201,14 @@ async def invoke_mcp_tool(\n \n         try:\n             result = await server.call_tool(tool.name, json_data)\n+        except UserError:\n+            # Re-raise UserError as-is (it already has a good message)\n+            raise\n         except Exception as e:\n-            logger.error(f\"Error invoking MCP tool {tool.name}: {e}\")\n-            raise AgentsException(f\"Error invoking MCP tool {tool.name}: {e}\") from e\n+            logger.error(f\"Error invoking MCP tool {tool.name} on server '{server.name}': {e}\")\n+            raise AgentsException(\n+                f\"Error invoking MCP tool {tool.name} on server '{server.name}': {e}\"\n+            ) from e\n \n         if _debug.DONT_LOG_TOOL_DATA:\n             logger.debug(f\"MCP tool {tool.name} completed.\")",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/dc428fad5fdb8956000733dd3f95d2d05297741a/src%2Fagents%2Fmcp%2Futil.py",
        "sha": "832728986fed9ee74642791d56ea6f64a4465509",
        "status": "modified"
      }
    ],
    "status": 200
  },
  "started_at": "2026-01-20T04:54:53.665532Z"
}
