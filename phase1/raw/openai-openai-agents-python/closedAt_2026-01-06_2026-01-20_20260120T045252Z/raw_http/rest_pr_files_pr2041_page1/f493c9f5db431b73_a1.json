{
  "finished_at": "2026-01-20T04:53:08.214098Z",
  "meta": {
    "attempt": 1,
    "request_fingerprint": "f493c9f5db431b73",
    "tag": "rest_pr_files_pr2041_page1"
  },
  "request": {
    "body": null,
    "headers": {
      "Accept": "application/vnd.github+json",
      "X-GitHub-Api-Version": "2022-11-28"
    },
    "method": "GET",
    "url": "https://api.github.com/repos/openai/openai-agents-python/pulls/2041/files?per_page=100&page=1"
  },
  "response": {
    "headers": {
      "access-control-allow-origin": "*",
      "access-control-expose-headers": "ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Resource, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, X-GitHub-SSO, X-GitHub-Request-Id, Deprecation, Sunset",
      "cache-control": "private, max-age=60, s-maxage=60",
      "content-length": "88194",
      "content-security-policy": "default-src 'none'",
      "content-type": "application/json; charset=utf-8",
      "date": "Tue, 20 Jan 2026 04:53:07 GMT",
      "etag": "\"4ebeb72c022f716f09d3f4a9df7021dec245e13825f161f972d8667189c6e354\"",
      "github-authentication-token-expiration": "2026-02-19 04:41:20 UTC",
      "last-modified": "Sat, 10 Jan 2026 02:12:27 GMT",
      "referrer-policy": "origin-when-cross-origin, strict-origin-when-cross-origin",
      "server": "github.com",
      "strict-transport-security": "max-age=31536000; includeSubdomains; preload",
      "vary": "Accept, Authorization, Cookie, X-GitHub-OTP,Accept-Encoding, Accept, X-Requested-With",
      "x-accepted-oauth-scopes": "",
      "x-content-type-options": "nosniff",
      "x-frame-options": "deny",
      "x-github-api-version-selected": "2022-11-28",
      "x-github-media-type": "github.v3; format=json",
      "x-github-request-id": "DA77:29AB24:15F3593:1EFD2AD:696F0A33",
      "x-oauth-scopes": "repo",
      "x-ratelimit-limit": "5000",
      "x-ratelimit-remaining": "4998",
      "x-ratelimit-reset": "1768885989",
      "x-ratelimit-resource": "core",
      "x-ratelimit-used": "2",
      "x-xss-protection": "0"
    },
    "json": [
      {
        "additions": 12,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/f8608f767ff995b0e9fd824e6ef7d565a7e1a70b/src%2Fagents%2Fextensions%2Fmemory%2F__init__.py",
        "changes": 12,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/src%2Fagents%2Fextensions%2Fmemory%2F__init__.py?ref=f8608f767ff995b0e9fd824e6ef7d565a7e1a70b",
        "deletions": 0,
        "filename": "src/agents/extensions/memory/__init__.py",
        "patch": "@@ -15,6 +15,7 @@\n     \"RedisSession\",\r\n     \"SQLAlchemySession\",\r\n     \"AdvancedSQLiteSession\",\r\n+    \"AdvancedSQLAlchemySession\",\r\n ]\r\n \r\n \r\n@@ -60,4 +61,15 @@ def __getattr__(name: str) -> Any:\n         except ModuleNotFoundError as e:\r\n             raise ImportError(f\"Failed to import AdvancedSQLiteSession: {e}\") from e\r\n \r\n+    if name == \"AdvancedSQLAlchemySession\":\r\n+        try:\r\n+            from .advanced_sqlalchemy_session import AdvancedSQLAlchemySession  # noqa: F401\r\n+\r\n+            return AdvancedSQLAlchemySession\r\n+        except ModuleNotFoundError as e:\r\n+            raise ImportError(\r\n+                \"AdvancedSQLAlchemySession requires the 'sqlalchemy' extra. \"\r\n+                \"Install it with: pip install openai-agents[sqlalchemy]\"\r\n+            ) from e\r\n+\r\n     raise AttributeError(f\"module {__name__} has no attribute {name}\")\r",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/f8608f767ff995b0e9fd824e6ef7d565a7e1a70b/src%2Fagents%2Fextensions%2Fmemory%2F__init__.py",
        "sha": "3964bb7aea8838a1814d19c83d5adc9b670b5bf5",
        "status": "modified"
      },
      {
        "additions": 1239,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/f8608f767ff995b0e9fd824e6ef7d565a7e1a70b/src%2Fagents%2Fextensions%2Fmemory%2Fadvanced_sqlalchemy_session.py",
        "changes": 1239,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/src%2Fagents%2Fextensions%2Fmemory%2Fadvanced_sqlalchemy_session.py?ref=f8608f767ff995b0e9fd824e6ef7d565a7e1a70b",
        "deletions": 0,
        "filename": "src/agents/extensions/memory/advanced_sqlalchemy_session.py",
        "patch": "@@ -0,0 +1,1239 @@\n+from __future__ import annotations\n+\n+import json\n+import logging\n+import time\n+from typing import Any\n+\n+from sqlalchemy import (\n+    TIMESTAMP,\n+    Column,\n+    ForeignKey,\n+    Index,\n+    Integer,\n+    String,\n+    Table,\n+    Text,\n+    UniqueConstraint,\n+    and_,\n+    case,\n+    delete,\n+    func,\n+    insert,\n+    select,\n+    text as sql_text,\n+    update,\n+)\n+from sqlalchemy.ext.asyncio import AsyncEngine\n+\n+from agents.result import RunResult\n+from agents.usage import Usage\n+\n+from ...items import TResponseInputItem\n+from .sqlalchemy_session import SQLAlchemySession\n+\n+\n+class AdvancedSQLAlchemySession(SQLAlchemySession):\n+    \"\"\"SQLAlchemy implementation of the advanced session with branching and usage tracking.\"\"\"\n+\n+    _message_structure: Table\n+    _turn_usage: Table\n+\n+    def __init__(\n+        self,\n+        session_id: str,\n+        *,\n+        engine: AsyncEngine,\n+        create_tables: bool = False,\n+        sessions_table: str = \"agent_sessions\",\n+        messages_table: str = \"agent_messages\",\n+        structure_table: str = \"message_structure\",\n+        turn_usage_table: str = \"turn_usage\",\n+        logger: logging.Logger | None = None,\n+    ):\n+        \"\"\"Initialize the AdvancedSQLAlchemySession.\"\"\"\n+        super().__init__(\n+            session_id,\n+            engine=engine,\n+            create_tables=create_tables,\n+            sessions_table=sessions_table,\n+            messages_table=messages_table,\n+        )\n+\n+        self._message_structure = Table(\n+            structure_table,\n+            self._metadata,\n+            Column(\"id\", Integer, primary_key=True, autoincrement=True),\n+            Column(\n+                \"session_id\",\n+                String,\n+                ForeignKey(f\"{self._sessions.name}.session_id\", ondelete=\"CASCADE\"),\n+                nullable=False,\n+            ),\n+            Column(\n+                \"message_id\",\n+                Integer,\n+                ForeignKey(f\"{self._messages.name}.id\", ondelete=\"CASCADE\"),\n+                nullable=False,\n+            ),\n+            Column(\"branch_id\", String, nullable=False, server_default=\"main\"),\n+            Column(\"message_type\", String, nullable=False),\n+            Column(\"sequence_number\", Integer, nullable=False),\n+            Column(\"user_turn_number\", Integer),\n+            Column(\"branch_turn_number\", Integer),\n+            Column(\"tool_name\", String),\n+            Column(\n+                \"created_at\",\n+                TIMESTAMP(timezone=False),\n+                server_default=sql_text(\"CURRENT_TIMESTAMP\"),\n+            ),\n+            sqlite_autoincrement=True,\n+        )\n+\n+        Index(\n+            f\"idx_{structure_table}_session_seq\",\n+            self._message_structure.c.session_id,\n+            self._message_structure.c.sequence_number,\n+        )\n+        Index(\n+            f\"idx_{structure_table}_branch\",\n+            self._message_structure.c.session_id,\n+            self._message_structure.c.branch_id,\n+        )\n+        Index(\n+            f\"idx_{structure_table}_branch_turn\",\n+            self._message_structure.c.session_id,\n+            self._message_structure.c.branch_id,\n+            self._message_structure.c.user_turn_number,\n+        )\n+        Index(\n+            f\"idx_{structure_table}_branch_seq\",\n+            self._message_structure.c.session_id,\n+            self._message_structure.c.branch_id,\n+            self._message_structure.c.sequence_number,\n+        )\n+\n+        self._turn_usage = Table(\n+            turn_usage_table,\n+            self._metadata,\n+            Column(\"id\", Integer, primary_key=True, autoincrement=True),\n+            Column(\n+                \"session_id\",\n+                String,\n+                ForeignKey(f\"{self._sessions.name}.session_id\", ondelete=\"CASCADE\"),\n+                nullable=False,\n+            ),\n+            Column(\"branch_id\", String, nullable=False, server_default=\"main\"),\n+            Column(\"user_turn_number\", Integer, nullable=False),\n+            Column(\"requests\", Integer, nullable=False, server_default=\"0\"),\n+            Column(\"input_tokens\", Integer, nullable=False, server_default=\"0\"),\n+            Column(\"output_tokens\", Integer, nullable=False, server_default=\"0\"),\n+            Column(\"total_tokens\", Integer, nullable=False, server_default=\"0\"),\n+            Column(\"input_tokens_details\", Text),\n+            Column(\"output_tokens_details\", Text),\n+            Column(\n+                \"created_at\",\n+                TIMESTAMP(timezone=False),\n+                server_default=sql_text(\"CURRENT_TIMESTAMP\"),\n+            ),\n+            UniqueConstraint(\n+                \"session_id\",\n+                \"branch_id\",\n+                \"user_turn_number\",\n+                name=f\"uq_{turn_usage_table}_turn\",\n+            ),\n+            sqlite_autoincrement=True,\n+        )\n+\n+        Index(\n+            f\"idx_{turn_usage_table}_session_turn\",\n+            self._turn_usage.c.session_id,\n+            self._turn_usage.c.branch_id,\n+            self._turn_usage.c.user_turn_number,\n+        )\n+\n+        self._current_branch_id = \"main\"\n+        self._logger = logger or logging.getLogger(__name__)\n+\n+    async def add_items(self, items: list[TResponseInputItem]) -> None:\n+        \"\"\"Add items to the session.\n+\n+        Args:\n+            items: The items to add to the session\n+        \"\"\"\n+        if not items:\n+            return\n+\n+        await self._ensure_tables()\n+        async with self._lock:\n+            await super().add_items(items)\n+            try:\n+                await self._add_structure_metadata(items)\n+            except Exception as exc:  # pragma: no cover - defensive\n+                self._logger.error(\n+                    \"Failed to add structure metadata for session %s: %s\",\n+                    self.session_id,\n+                    exc,\n+                )\n+                try:\n+                    await self._cleanup_orphaned_messages()\n+                except Exception as cleanup_error:  # pragma: no cover - defensive\n+                    self._logger.error(\n+                        \"Failed to cleanup orphaned messages for session %s: %s\",\n+                        self.session_id,\n+                        cleanup_error,\n+                    )\n+\n+    async def get_items(\n+        self,\n+        limit: int | None = None,\n+        branch_id: str | None = None,\n+    ) -> list[TResponseInputItem]:\n+        \"\"\"Get items from current or specified branch.\n+\n+        Args:\n+            limit: Maximum number of items to return. If None, returns all items.\n+            branch_id: Branch to get items from. If None, uses current branch.\n+\n+        Returns:\n+            List of conversation items from the specified branch.\n+        \"\"\"\n+        branch = branch_id or self._current_branch_id\n+        await self._ensure_tables()\n+\n+        async with self._session_factory() as sess:\n+            if limit is None:\n+                stmt = (\n+                    select(self._messages.c.message_data)\n+                    .join(\n+                        self._message_structure,\n+                        and_(\n+                            self._messages.c.id == self._message_structure.c.message_id,\n+                            self._message_structure.c.branch_id == branch,\n+                        ),\n+                    )\n+                    .where(self._messages.c.session_id == self.session_id)\n+                    .order_by(self._message_structure.c.sequence_number.asc())\n+                )\n+            else:\n+                stmt = (\n+                    select(self._messages.c.message_data)\n+                    .join(\n+                        self._message_structure,\n+                        and_(\n+                            self._messages.c.id == self._message_structure.c.message_id,\n+                            self._message_structure.c.branch_id == branch,\n+                        ),\n+                    )\n+                    .where(self._messages.c.session_id == self.session_id)\n+                    .order_by(self._message_structure.c.sequence_number.desc())\n+                    .limit(limit)\n+                )\n+\n+            result = await sess.execute(stmt)\n+            rows: list[str] = [row[0] for row in result.all()]\n+\n+        if limit is not None:\n+            rows.reverse()\n+\n+        items: list[TResponseInputItem] = []\n+        for raw in rows:\n+            try:\n+                items.append(await self._deserialize_item(raw))\n+            except json.JSONDecodeError:\n+                # Skip corrupted rows\n+                continue\n+        return items\n+\n+    async def store_run_usage(self, result: RunResult) -> None:\n+        \"\"\"Store usage data for the current conversation turn.\n+\n+        This is designed to be called after `Runner.run()` completes.\n+        Session-level usage can be aggregated from turn data when needed.\n+\n+        Args:\n+            result: The result from the run\n+        \"\"\"\n+        usage = result.context_wrapper.usage\n+        if usage is None:\n+            return\n+\n+        try:\n+            current_turn = await self._get_current_turn_number()\n+            if current_turn > 0:\n+                await self._update_turn_usage_internal(current_turn, usage)\n+        except Exception as exc:  # pragma: no cover - defensive logging\n+            self._logger.error(\"Failed to store usage for session %s: %s\", self.session_id, exc)\n+\n+    async def _get_next_turn_number(self, branch_id: str) -> int:\n+        \"\"\"Get the next turn number for a specific branch.\n+\n+        Args:\n+            branch_id: The branch ID to get the next turn number for.\n+\n+        Returns:\n+            The next available turn number for the specified branch.\n+        \"\"\"\n+        max_turn = await self._get_current_turn_number(branch_id)\n+        return max_turn + 1\n+\n+    async def _get_next_branch_turn_number(self, branch_id: str) -> int:\n+        \"\"\"Get the next branch turn number for a specific branch.\n+\n+        Args:\n+            branch_id: The branch ID to get the next branch turn number for.\n+\n+        Returns:\n+            The next available branch turn number for the specified branch.\n+        \"\"\"\n+        await self._ensure_tables()\n+        async with self._session_factory() as sess:\n+            stmt = select(\n+                func.coalesce(func.max(self._message_structure.c.branch_turn_number), 0)\n+            ).where(\n+                and_(\n+                    self._message_structure.c.session_id == self.session_id,\n+                    self._message_structure.c.branch_id == branch_id,\n+                )\n+            )\n+            value = await sess.scalar(stmt)\n+        return int(value or 0) + 1\n+\n+    async def _get_current_turn_number(self, branch_id: str | None = None) -> int:\n+        \"\"\"Get the current turn number for the current branch.\n+\n+        Returns:\n+            The current turn number for the active branch.\n+        \"\"\"\n+        branch = branch_id or self._current_branch_id\n+        await self._ensure_tables()\n+        async with self._session_factory() as sess:\n+            stmt = select(\n+                func.coalesce(func.max(self._message_structure.c.user_turn_number), 0)\n+            ).where(\n+                and_(\n+                    self._message_structure.c.session_id == self.session_id,\n+                    self._message_structure.c.branch_id == branch,\n+                )\n+            )\n+            value = await sess.scalar(stmt)\n+        return int(value or 0)\n+\n+    async def _add_structure_metadata(self, items: list[TResponseInputItem]) -> None:\n+        \"\"\"Extract structure metadata with branch-aware turn tracking.\n+\n+        This method:\n+        - Assigns turn numbers per branch (not globally)\n+        - Assigns explicit sequence numbers for precise ordering\n+        - Links messages to their database IDs for structure tracking\n+        - Handles multiple user messages in a single batch correctly\n+\n+        Args:\n+            items: The items to add to the session\n+        \"\"\"\n+        if not items:\n+            return\n+\n+        await self._ensure_tables()\n+\n+        async with self._session_factory() as sess:\n+            async with sess.begin():\n+                ids_stmt = (\n+                    select(self._messages.c.id)\n+                    .where(self._messages.c.session_id == self.session_id)\n+                    .order_by(self._messages.c.id.desc())\n+                    .limit(len(items))\n+                )\n+                id_rows = await sess.execute(ids_stmt)\n+                message_ids = [row[0] for row in id_rows.all()]\n+                message_ids.reverse()\n+\n+                if len(message_ids) != len(items):\n+                    self._logger.warning(\n+                        \"Mismatch retrieving message IDs for session %s. Expected %s got %s\",\n+                        self.session_id,\n+                        len(items),\n+                        len(message_ids),\n+                    )\n+                    return\n+\n+                seq_stmt = select(\n+                    func.coalesce(func.max(self._message_structure.c.sequence_number), 0)\n+                ).where(self._message_structure.c.session_id == self.session_id)\n+                seq_start = await sess.scalar(seq_stmt)\n+                seq_start = int(seq_start or 0)\n+\n+                turn_stmt = select(\n+                    func.coalesce(func.max(self._message_structure.c.user_turn_number), 0),\n+                    func.coalesce(func.max(self._message_structure.c.branch_turn_number), 0),\n+                ).where(\n+                    and_(\n+                        self._message_structure.c.session_id == self.session_id,\n+                        self._message_structure.c.branch_id == self._current_branch_id,\n+                    )\n+                )\n+                turn_row = await sess.execute(turn_stmt)\n+                turn_values = turn_row.one_or_none()\n+                current_turn = int(turn_values[0]) if turn_values and turn_values[0] else 0\n+                current_branch_turn = int(turn_values[1]) if turn_values and turn_values[1] else 0\n+\n+                structure_payload: list[dict[str, Any]] = []\n+                user_message_count = 0\n+\n+                for offset, (item, message_id) in enumerate(zip(items, message_ids)):\n+                    msg_type = self._classify_message_type(item)\n+                    tool_name = self._extract_tool_name(item)\n+\n+                    if self._is_user_message(item):\n+                        user_message_count += 1\n+\n+                    turn_value = current_turn + user_message_count\n+                    branch_turn_value = current_branch_turn + user_message_count\n+\n+                    structure_payload.append(\n+                        {\n+                            \"session_id\": self.session_id,\n+                            \"message_id\": message_id,\n+                            \"branch_id\": self._current_branch_id,\n+                            \"message_type\": msg_type,\n+                            \"sequence_number\": seq_start + offset + 1,\n+                            \"user_turn_number\": turn_value,\n+                            \"branch_turn_number\": branch_turn_value,\n+                            \"tool_name\": tool_name,\n+                        }\n+                    )\n+\n+                if structure_payload:\n+                    await sess.execute(insert(self._message_structure), structure_payload)\n+\n+    async def _cleanup_orphaned_messages(self) -> None:\n+        \"\"\"Remove messages that exist in agent_messages but not in message_structure.\n+\n+        This can happen if _add_structure_metadata fails after super().add_items() succeeds.\n+        Used for maintaining data consistency.\n+        \"\"\"\n+        await self._ensure_tables()\n+        async with self._session_factory() as sess:\n+            async with sess.begin():\n+                join_stmt = (\n+                    select(self._messages.c.id)\n+                    .select_from(\n+                        self._messages.outerjoin(\n+                            self._message_structure,\n+                            self._messages.c.id == self._message_structure.c.message_id,\n+                        )\n+                    )\n+                    .where(\n+                        and_(\n+                            self._messages.c.session_id == self.session_id,\n+                            self._message_structure.c.message_id.is_(None),\n+                        )\n+                    )\n+                )\n+                result = await sess.execute(join_stmt)\n+                orphan_ids = [row[0] for row in result.all()]\n+\n+                if orphan_ids:\n+                    await sess.execute(\n+                        delete(self._messages).where(self._messages.c.id.in_(orphan_ids))\n+                    )\n+                    self._logger.info(\n+                        \"Cleaned up %s orphaned messages for session %s\",\n+                        len(orphan_ids),\n+                        self.session_id,\n+                    )\n+\n+    def _classify_message_type(self, item: TResponseInputItem) -> str:\n+        \"\"\"Classify the type of a message item.\n+\n+        Args:\n+            item: The message item to classify.\n+\n+        Returns:\n+            String representing the message type (user, assistant, etc.).\n+        \"\"\"\n+        if isinstance(item, dict):\n+            if item.get(\"role\") == \"user\":\n+                return \"user\"\n+            elif item.get(\"role\") == \"assistant\":\n+                return \"assistant\"\n+            elif item.get(\"type\"):\n+                return str(item.get(\"type\"))\n+        return \"other\"\n+\n+    def _extract_tool_name(self, item: TResponseInputItem) -> str | None:\n+        \"\"\"Extract tool name if this is a tool call/output.\n+\n+        Args:\n+            item: The message item to extract tool name from.\n+\n+        Returns:\n+            Tool name if item is a tool call, None otherwise.\n+        \"\"\"\n+        if isinstance(item, dict):\n+            item_type = item.get(\"type\")\n+\n+            if item_type in {\"mcp_call\", \"mcp_approval_request\"} and \"server_label\" in item:\n+                server_label = item.get(\"server_label\")\n+                tool_name = item.get(\"name\")\n+                if tool_name and server_label:\n+                    return f\"{server_label}.{tool_name}\"\n+                if server_label:\n+                    return str(server_label)\n+                if tool_name:\n+                    return str(tool_name)\n+\n+            if item_type in {\n+                \"computer_call\",\n+                \"file_search_call\",\n+                \"web_search_call\",\n+                \"code_interpreter_call\",\n+            }:\n+                return item_type\n+\n+            if \"name\" in item and item.get(\"name\") is not None:\n+                return str(item.get(\"name\"))\n+\n+        return None\n+\n+    def _is_user_message(self, item: TResponseInputItem) -> bool:\n+        \"\"\"Check if this is a user message.\n+\n+        Args:\n+            item: The message item to check.\n+\n+        Returns:\n+            True if the item is a user message, False otherwise.\n+        \"\"\"\n+        return isinstance(item, dict) and item.get(\"role\") == \"user\"\n+\n+    async def create_branch_from_turn(\n+        self,\n+        turn_number: int,\n+        branch_name: str | None = None,\n+    ) -> str:\n+        \"\"\"Create a new branch starting from a specific user message turn.\n+\n+        Args:\n+            turn_number: The branch turn number of the user message to branch from\n+            branch_name: Optional name for the branch (auto-generated if None)\n+\n+        Returns:\n+            The branch_id of the newly created branch\n+\n+        Raises:\n+            ValueError: If turn doesn't exist or doesn't contain a user message\n+        \"\"\"\n+        await self._ensure_tables()\n+        async with self._session_factory() as sess:\n+            stmt = (\n+                select(self._messages.c.message_data)\n+                .join(\n+                    self._message_structure,\n+                    self._messages.c.id == self._message_structure.c.message_id,\n+                )\n+                .where(\n+                    and_(\n+                        self._message_structure.c.session_id == self.session_id,\n+                        self._message_structure.c.branch_id == self._current_branch_id,\n+                        self._message_structure.c.branch_turn_number == turn_number,\n+                        self._message_structure.c.message_type == \"user\",\n+                    )\n+                )\n+            )\n+            row = await sess.execute(stmt)\n+            message_row = row.first()\n+\n+        if not message_row:\n+            raise ValueError(\n+                f\"Turn {turn_number} does not contain a user message \"\n+                f\"in branch '{self._current_branch_id}'\"\n+            )\n+\n+        try:\n+            message_content = json.loads(message_row[0]).get(\"content\", \"\")\n+        except Exception:  # pragma: no cover - defensive\n+            message_content = \"Unable to parse content\"\n+\n+        if branch_name is None:\n+            branch_name = f\"branch_from_turn_{turn_number}_{int(time.time())}\"\n+\n+        await self._copy_messages_to_new_branch(branch_name, turn_number)\n+\n+        old_branch = self._current_branch_id\n+        self._current_branch_id = branch_name\n+        self._logger.debug(\n+            \"Created branch '%s' from turn %s ('%s') in '%s'\",\n+            branch_name,\n+            turn_number,\n+            message_content[:50] + (\"...\" if len(message_content) > 50 else \"\"),\n+            old_branch,\n+        )\n+        return branch_name\n+\n+    async def create_branch_from_content(\n+        self,\n+        search_term: str,\n+        branch_name: str | None = None,\n+    ) -> str:\n+        \"\"\"Create branch from the first user turn matching the search term.\n+\n+        Args:\n+            search_term: Text to search for in user messages.\n+            branch_name: Optional name for the branch (auto-generated if None).\n+\n+        Returns:\n+            The branch_id of the newly created branch.\n+\n+        Raises:\n+            ValueError: If no matching turns are found.\n+        \"\"\"\n+        matches = await self.find_turns_by_content(search_term)\n+        if not matches:\n+            raise ValueError(f\"No user turns found containing '{search_term}'\")\n+\n+        return await self.create_branch_from_turn(matches[0][\"turn\"], branch_name)\n+\n+    async def switch_to_branch(self, branch_id: str) -> None:\n+        \"\"\"Switch to a different branch.\n+\n+        Args:\n+            branch_id: The branch to switch to.\n+\n+        Raises:\n+            ValueError: If the branch doesn't exist.\n+        \"\"\"\n+        await self._ensure_tables()\n+        async with self._session_factory() as sess:\n+            stmt = (\n+                select(func.count())\n+                .select_from(self._message_structure)\n+                .where(\n+                    and_(\n+                        self._message_structure.c.session_id == self.session_id,\n+                        self._message_structure.c.branch_id == branch_id,\n+                    )\n+                )\n+            )\n+            exists = await sess.scalar(stmt)\n+\n+        if not exists:\n+            raise ValueError(f\"Branch '{branch_id}' does not exist\")\n+\n+        old_branch = self._current_branch_id\n+        self._current_branch_id = branch_id\n+        self._logger.info(\"Switched from branch '%s' to '%s'\", old_branch, branch_id)\n+\n+    async def delete_branch(self, branch_id: str, *, force: bool = False) -> None:\n+        \"\"\"Delete a branch and all its associated data.\n+\n+        Args:\n+            branch_id: The branch to delete.\n+            force: If True, allows deleting the current branch (will switch to 'main').\n+\n+        Raises:\n+            ValueError: If branch doesn't exist, is 'main', or is current branch without force.\n+        \"\"\"\n+        if not branch_id or not branch_id.strip():\n+            raise ValueError(\"Branch ID cannot be empty\")\n+\n+        branch_id = branch_id.strip()\n+\n+        if branch_id == \"main\":\n+            raise ValueError(\"Cannot delete the 'main' branch\")\n+\n+        if branch_id == self._current_branch_id:\n+            if not force:\n+                raise ValueError(\n+                    f\"Cannot delete current branch '{branch_id}'. \"\n+                    \"Use force=True or switch branches first\"\n+                )\n+            await self.switch_to_branch(\"main\")\n+\n+        await self._ensure_tables()\n+        async with self._lock:\n+            async with self._session_factory() as sess:\n+                async with sess.begin():\n+                    exists_stmt = (\n+                        select(func.count())\n+                        .select_from(self._message_structure)\n+                        .where(\n+                            and_(\n+                                self._message_structure.c.session_id == self.session_id,\n+                                self._message_structure.c.branch_id == branch_id,\n+                            )\n+                        )\n+                    )\n+                    exists = await sess.scalar(exists_stmt)\n+                    if not exists:\n+                        raise ValueError(f\"Branch '{branch_id}' does not exist\")\n+\n+                    usage_result = await sess.execute(\n+                        delete(self._turn_usage).where(\n+                            and_(\n+                                self._turn_usage.c.session_id == self.session_id,\n+                                self._turn_usage.c.branch_id == branch_id,\n+                            )\n+                        )\n+                    )\n+\n+                    structure_result = await sess.execute(\n+                        delete(self._message_structure).where(\n+                            and_(\n+                                self._message_structure.c.session_id == self.session_id,\n+                                self._message_structure.c.branch_id == branch_id,\n+                            )\n+                        )\n+                    )\n+\n+        self._logger.info(\n+            \"Deleted branch '%s': %s message entries, %s usage entries\",\n+            branch_id,\n+            structure_result.rowcount if \"structure_result\" in locals() else 0,\n+            usage_result.rowcount if \"usage_result\" in locals() else 0,\n+        )\n+\n+    async def list_branches(self) -> list[dict[str, Any]]:\n+        \"\"\"List all branches in this session.\n+\n+        Returns:\n+            List of dicts with branch info containing:\n+                - 'branch_id': Branch identifier\n+                - 'message_count': Number of messages in branch\n+                - 'user_turns': Number of user turns in branch\n+                - 'is_current': Whether this is the current branch\n+                - 'created_at': When the branch was first created\n+        \"\"\"\n+        await self._ensure_tables()\n+        async with self._session_factory() as sess:\n+            stmt = (\n+                select(\n+                    self._message_structure.c.branch_id,\n+                    func.count().label(\"message_count\"),\n+                    func.sum(\n+                        case(\n+                            (self._message_structure.c.message_type == \"user\", 1),\n+                            else_=0,\n+                        )\n+                    ).label(\"user_turns\"),\n+                    func.min(self._message_structure.c.created_at).label(\"created_at\"),\n+                )\n+                .where(self._message_structure.c.session_id == self.session_id)\n+                .group_by(self._message_structure.c.branch_id)\n+                .order_by(func.min(self._message_structure.c.created_at))\n+            )\n+            result = await sess.execute(stmt)\n+            rows = result.all()\n+\n+        branches: list[dict[str, Any]] = []\n+        for branch_id, message_count, user_turns, created_at in rows:\n+            branches.append(\n+                {\n+                    \"branch_id\": branch_id,\n+                    \"message_count\": int(message_count or 0),\n+                    \"user_turns\": int(user_turns or 0),\n+                    \"is_current\": branch_id == self._current_branch_id,\n+                    \"created_at\": created_at,\n+                }\n+            )\n+        return branches\n+\n+    async def _copy_messages_to_new_branch(\n+        self,\n+        new_branch_id: str,\n+        from_turn_number: int,\n+    ) -> None:\n+        \"\"\"Copy messages before the branch point to the new branch.\n+\n+        Args:\n+            new_branch_id: The ID of the new branch to copy messages to.\n+            from_turn_number: The turn number to copy messages up to (exclusive).\n+        \"\"\"\n+        await self._ensure_tables()\n+        async with self._lock:\n+            async with self._session_factory() as sess:\n+                async with sess.begin():\n+                    select_stmt = (\n+                        select(\n+                            self._message_structure.c.message_id,\n+                            self._message_structure.c.message_type,\n+                            self._message_structure.c.sequence_number,\n+                            self._message_structure.c.user_turn_number,\n+                            self._message_structure.c.branch_turn_number,\n+                            self._message_structure.c.tool_name,\n+                        )\n+                        .where(\n+                            and_(\n+                                self._message_structure.c.session_id == self.session_id,\n+                                self._message_structure.c.branch_id == self._current_branch_id,\n+                                self._message_structure.c.branch_turn_number < from_turn_number,\n+                            )\n+                        )\n+                        .order_by(self._message_structure.c.sequence_number)\n+                    )\n+                    rows = await sess.execute(select_stmt)\n+                    messages_to_copy = rows.all()\n+\n+                    if not messages_to_copy:\n+                        return\n+\n+                    seq_stmt = select(\n+                        func.coalesce(func.max(self._message_structure.c.sequence_number), 0)\n+                    ).where(self._message_structure.c.session_id == self.session_id)\n+                    seq_start = await sess.scalar(seq_stmt)\n+                    seq_start = int(seq_start or 0)\n+\n+                    payload: list[dict[str, Any]] = []\n+                    for idx, (\n+                        message_id,\n+                        message_type,\n+                        _,\n+                        user_turn_number,\n+                        branch_turn_number,\n+                        tool_name,\n+                    ) in enumerate(messages_to_copy):\n+                        payload.append(\n+                            {\n+                                \"session_id\": self.session_id,\n+                                \"message_id\": message_id,\n+                                \"branch_id\": new_branch_id,\n+                                \"message_type\": message_type,\n+                                \"sequence_number\": seq_start + idx + 1,\n+                                \"user_turn_number\": user_turn_number,\n+                                \"branch_turn_number\": branch_turn_number,\n+                                \"tool_name\": tool_name,\n+                            }\n+                        )\n+\n+                    await sess.execute(insert(self._message_structure), payload)\n+\n+    async def get_conversation_turns(\n+        self,\n+        branch_id: str | None = None,\n+    ) -> list[dict[str, Any]]:\n+        \"\"\"Get user turns with content for easy browsing and branching decisions.\n+\n+        Args:\n+            branch_id: Branch to get turns from (current branch if None).\n+\n+        Returns:\n+            List of dicts with turn info containing:\n+                - 'turn': Branch turn number\n+                - 'content': User message content (truncated)\n+                - 'full_content': Full user message content\n+                - 'timestamp': When the turn was created\n+                - 'can_branch': Always True (all user messages can branch)\n+        \"\"\"\n+        branch = branch_id or self._current_branch_id\n+        await self._ensure_tables()\n+        async with self._session_factory() as sess:\n+            stmt = (\n+                select(\n+                    self._message_structure.c.branch_turn_number,\n+                    self._messages.c.message_data,\n+                    self._message_structure.c.created_at,\n+                )\n+                .join(\n+                    self._messages,\n+                    self._messages.c.id == self._message_structure.c.message_id,\n+                )\n+                .where(\n+                    and_(\n+                        self._message_structure.c.session_id == self.session_id,\n+                        self._message_structure.c.branch_id == branch,\n+                        self._message_structure.c.message_type == \"user\",\n+                    )\n+                )\n+                .order_by(self._message_structure.c.branch_turn_number)\n+            )\n+            result = await sess.execute(stmt)\n+            rows = result.all()\n+\n+        turns: list[dict[str, Any]] = []\n+        for turn_number, message_data, created_at in rows:\n+            try:\n+                content = json.loads(message_data).get(\"content\", \"\")\n+            except (json.JSONDecodeError, AttributeError):\n+                continue\n+            turns.append(\n+                {\n+                    \"turn\": int(turn_number),\n+                    \"content\": content[:100] + (\"...\" if len(content) > 100 else \"\"),\n+                    \"full_content\": content,\n+                    \"timestamp\": created_at,\n+                    \"can_branch\": True,\n+                }\n+            )\n+        return turns\n+\n+    async def find_turns_by_content(\n+        self,\n+        search_term: str,\n+        branch_id: str | None = None,\n+    ) -> list[dict[str, Any]]:\n+        \"\"\"Find user turns containing specific content.\n+\n+        Args:\n+            search_term: Text to search for in user messages.\n+            branch_id: Branch to search in (current branch if None).\n+\n+        Returns:\n+            List of matching turns with same format as get_conversation_turns().\n+        \"\"\"\n+        branch = branch_id or self._current_branch_id\n+        pattern = f\"%{search_term}%\"\n+        await self._ensure_tables()\n+\n+        async with self._session_factory() as sess:\n+            stmt = (\n+                select(\n+                    self._message_structure.c.branch_turn_number,\n+                    self._messages.c.message_data,\n+                    self._message_structure.c.created_at,\n+                )\n+                .join(\n+                    self._messages,\n+                    self._messages.c.id == self._message_structure.c.message_id,\n+                )\n+                .where(\n+                    and_(\n+                        self._message_structure.c.session_id == self.session_id,\n+                        self._message_structure.c.branch_id == branch,\n+                        self._message_structure.c.message_type == \"user\",\n+                        self._messages.c.message_data.like(pattern),\n+                    )\n+                )\n+                .order_by(self._message_structure.c.branch_turn_number)\n+            )\n+            result = await sess.execute(stmt)\n+            rows = result.all()\n+\n+        matches: list[dict[str, Any]] = []\n+        for turn_number, message_data, created_at in rows:\n+            try:\n+                content = json.loads(message_data).get(\"content\", \"\")\n+            except (json.JSONDecodeError, AttributeError):\n+                continue\n+            matches.append(\n+                {\n+                    \"turn\": int(turn_number),\n+                    \"content\": content,\n+                    \"full_content\": content,\n+                    \"timestamp\": created_at,\n+                    \"can_branch\": True,\n+                }\n+            )\n+        return matches\n+\n+    async def get_conversation_by_turns(\n+        self,\n+        branch_id: str | None = None,\n+    ) -> dict[int, list[dict[str, str | None]]]:\n+        \"\"\"Get conversation grouped by user turns for specified branch.\n+\n+        Args:\n+            branch_id: Branch to get conversation from (current branch if None).\n+\n+        Returns:\n+            Dictionary mapping turn numbers to lists of message metadata.\n+        \"\"\"\n+        branch = branch_id or self._current_branch_id\n+        await self._ensure_tables()\n+        async with self._session_factory() as sess:\n+            stmt = (\n+                select(\n+                    self._message_structure.c.user_turn_number,\n+                    self._message_structure.c.message_type,\n+                    self._message_structure.c.tool_name,\n+                )\n+                .where(\n+                    and_(\n+                        self._message_structure.c.session_id == self.session_id,\n+                        self._message_structure.c.branch_id == branch,\n+                    )\n+                )\n+                .order_by(self._message_structure.c.sequence_number)\n+            )\n+            result = await sess.execute(stmt)\n+            rows = result.all()\n+\n+        turns: dict[int, list[dict[str, str | None]]] = {}\n+        for turn_number, message_type, tool_name in rows:\n+            key = int(turn_number or 0)\n+            turns.setdefault(key, []).append({\"type\": message_type, \"tool_name\": tool_name})\n+        return turns\n+\n+    async def get_tool_usage(\n+        self,\n+        branch_id: str | None = None,\n+    ) -> list[tuple[str | None, int, int]]:\n+        \"\"\"Get all tool usage by turn for specified branch.\n+\n+        Args:\n+            branch_id: Branch to get tool usage from (current branch if None).\n+\n+        Returns:\n+            List of tuples containing (tool_name, usage_count, turn_number).\n+        \"\"\"\n+        branch = branch_id or self._current_branch_id\n+        tool_types = {\n+            \"tool_call\",\n+            \"function_call\",\n+            \"computer_call\",\n+            \"file_search_call\",\n+            \"web_search_call\",\n+            \"code_interpreter_call\",\n+            \"custom_tool_call\",\n+            \"mcp_call\",\n+            \"mcp_approval_request\",\n+        }\n+\n+        await self._ensure_tables()\n+        async with self._session_factory() as sess:\n+            stmt = (\n+                select(\n+                    self._message_structure.c.tool_name,\n+                    func.count(),\n+                    self._message_structure.c.user_turn_number,\n+                )\n+                .where(\n+                    and_(\n+                        self._message_structure.c.session_id == self.session_id,\n+                        self._message_structure.c.branch_id == branch,\n+                        self._message_structure.c.message_type.in_(tool_types),\n+                    )\n+                )\n+                .group_by(\n+                    self._message_structure.c.tool_name,\n+                    self._message_structure.c.user_turn_number,\n+                )\n+                .order_by(self._message_structure.c.user_turn_number)\n+            )\n+            result = await sess.execute(stmt)\n+            rows = result.all()\n+\n+        return [\n+            (\n+                tool_name,\n+                int(count or 0),\n+                int(user_turn_number or 0),\n+            )\n+            for tool_name, count, user_turn_number in rows\n+        ]\n+\n+    async def get_session_usage(\n+        self,\n+        branch_id: str | None = None,\n+    ) -> dict[str, int] | None:\n+        \"\"\"Get cumulative usage for session or specific branch.\n+\n+        Args:\n+            branch_id: If provided, only get usage for that branch. If None, get all branches.\n+\n+        Returns:\n+            Dictionary with usage statistics or None if no usage data found.\n+        \"\"\"\n+        await self._ensure_tables()\n+        async with self._session_factory() as sess:\n+            if branch_id:\n+                stmt = select(\n+                    func.sum(self._turn_usage.c.requests),\n+                    func.sum(self._turn_usage.c.input_tokens),\n+                    func.sum(self._turn_usage.c.output_tokens),\n+                    func.sum(self._turn_usage.c.total_tokens),\n+                    func.count(),\n+                ).where(\n+                    and_(\n+                        self._turn_usage.c.session_id == self.session_id,\n+                        self._turn_usage.c.branch_id == branch_id,\n+                    )\n+                )\n+            else:\n+                stmt = select(\n+                    func.sum(self._turn_usage.c.requests),\n+                    func.sum(self._turn_usage.c.input_tokens),\n+                    func.sum(self._turn_usage.c.output_tokens),\n+                    func.sum(self._turn_usage.c.total_tokens),\n+                    func.count(),\n+                ).where(self._turn_usage.c.session_id == self.session_id)\n+\n+            result = await sess.execute(stmt)\n+            row = result.first()\n+\n+        if not row or row[0] is None:\n+            return None\n+\n+        requests, input_tokens, output_tokens, total_tokens, turns = row\n+        return {\n+            \"requests\": int(requests or 0),\n+            \"input_tokens\": int(input_tokens or 0),\n+            \"output_tokens\": int(output_tokens or 0),\n+            \"total_tokens\": int(total_tokens or 0),\n+            \"total_turns\": int(turns or 0),\n+        }\n+\n+    async def get_turn_usage(\n+        self,\n+        user_turn_number: int | None = None,\n+        branch_id: str | None = None,\n+    ) -> list[dict[str, Any]] | dict[str, Any]:\n+        \"\"\"Get usage statistics by turn with full JSON token details.\n+\n+        Args:\n+            user_turn_number: Specific turn to get usage for. If None, returns all turns.\n+            branch_id: Branch to get usage from (current branch if None).\n+\n+        Returns:\n+            Dictionary with usage data for specific turn, or list of dictionaries for all turns.\n+        \"\"\"\n+        branch = branch_id or self._current_branch_id\n+        await self._ensure_tables()\n+        async with self._session_factory() as sess:\n+            if user_turn_number is not None:\n+                stmt = select(\n+                    self._turn_usage.c.requests,\n+                    self._turn_usage.c.input_tokens,\n+                    self._turn_usage.c.output_tokens,\n+                    self._turn_usage.c.total_tokens,\n+                    self._turn_usage.c.input_tokens_details,\n+                    self._turn_usage.c.output_tokens_details,\n+                ).where(\n+                    and_(\n+                        self._turn_usage.c.session_id == self.session_id,\n+                        self._turn_usage.c.branch_id == branch,\n+                        self._turn_usage.c.user_turn_number == user_turn_number,\n+                    )\n+                )\n+                result = await sess.execute(stmt)\n+                row = result.first()\n+                if not row:\n+                    return {}\n+                return {\n+                    \"requests\": int(row[0] or 0),\n+                    \"input_tokens\": int(row[1] or 0),\n+                    \"output_tokens\": int(row[2] or 0),\n+                    \"total_tokens\": int(row[3] or 0),\n+                    \"input_tokens_details\": self._loads_optional(row[4]),\n+                    \"output_tokens_details\": self._loads_optional(row[5]),\n+                }\n+\n+            stmt = (\n+                select(\n+                    self._turn_usage.c.user_turn_number,\n+                    self._turn_usage.c.requests,\n+                    self._turn_usage.c.input_tokens,\n+                    self._turn_usage.c.output_tokens,\n+                    self._turn_usage.c.total_tokens,\n+                    self._turn_usage.c.input_tokens_details,\n+                    self._turn_usage.c.output_tokens_details,\n+                )\n+                .where(\n+                    and_(\n+                        self._turn_usage.c.session_id == self.session_id,\n+                        self._turn_usage.c.branch_id == branch,\n+                    )\n+                )\n+                .order_by(self._turn_usage.c.user_turn_number)\n+            )\n+            result = await sess.execute(stmt)\n+            rows = result.all()\n+\n+        usage_rows: list[dict[str, Any]] = []\n+        for (\n+            turn_number,\n+            requests,\n+            input_tokens,\n+            output_tokens,\n+            total_tokens,\n+            input_details,\n+            output_details,\n+        ) in rows:\n+            usage_rows.append(\n+                {\n+                    \"user_turn_number\": int(turn_number or 0),\n+                    \"requests\": int(requests or 0),\n+                    \"input_tokens\": int(input_tokens or 0),\n+                    \"output_tokens\": int(output_tokens or 0),\n+                    \"total_tokens\": int(total_tokens or 0),\n+                    \"input_tokens_details\": self._loads_optional(input_details),\n+                    \"output_tokens_details\": self._loads_optional(output_details),\n+                }\n+            )\n+        return usage_rows\n+\n+    async def _update_turn_usage_internal(\n+        self,\n+        user_turn_number: int,\n+        usage_data: Usage,\n+    ) -> None:\n+        \"\"\"Internal method to update usage for a specific turn with full JSON details.\n+\n+        Args:\n+            user_turn_number: The turn number to update usage for.\n+            usage_data: The usage data to store.\n+        \"\"\"\n+        await self._ensure_tables()\n+        input_details = self._dumps_token_details(getattr(usage_data, \"input_tokens_details\", None))\n+        output_details = self._dumps_token_details(\n+            getattr(usage_data, \"output_tokens_details\", None)\n+        )\n+\n+        payload = {\n+            \"requests\": usage_data.requests or 0,\n+            \"input_tokens\": usage_data.input_tokens or 0,\n+            \"output_tokens\": usage_data.output_tokens or 0,\n+            \"total_tokens\": usage_data.total_tokens or 0,\n+            \"input_tokens_details\": input_details,\n+            \"output_tokens_details\": output_details,\n+        }\n+\n+        async with self._session_factory() as sess:\n+            async with sess.begin():\n+                update_stmt = (\n+                    update(self._turn_usage)\n+                    .where(\n+                        and_(\n+                            self._turn_usage.c.session_id == self.session_id,\n+                            self._turn_usage.c.branch_id == self._current_branch_id,\n+                            self._turn_usage.c.user_turn_number == user_turn_number,\n+                        )\n+                    )\n+                    .values(**payload)\n+                )\n+                result = await sess.execute(update_stmt)\n+\n+                if result.rowcount == 0:\n+                    insert_stmt = insert(self._turn_usage).values(\n+                        session_id=self.session_id,\n+                        branch_id=self._current_branch_id,\n+                        user_turn_number=user_turn_number,\n+                        **payload,\n+                    )\n+                    await sess.execute(insert_stmt)\n+\n+    def _dumps_token_details(self, details: Any) -> str | None:\n+        \"\"\"Serialize token detail objects to JSON.\"\"\"\n+        if not details:\n+            return None\n+\n+        for attr in (\"model_dump\", \"dict\"):\n+            if hasattr(details, attr):\n+                try:\n+                    return json.dumps(getattr(details, attr)())\n+                except (TypeError, ValueError):\n+                    continue\n+\n+        try:\n+            return json.dumps(details.__dict__)\n+        except (TypeError, ValueError) as exc:  # pragma: no cover - defensive\n+            self._logger.warning(\"Failed to serialize token details: %s\", exc)\n+            return None\n+\n+    def _loads_optional(self, payload: str | None) -> Any:\n+        \"\"\"Deserialize optional JSON payloads.\"\"\"\n+        if not payload:\n+            return None\n+        try:\n+            return json.loads(payload)\n+        except json.JSONDecodeError:\n+            return None",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/f8608f767ff995b0e9fd824e6ef7d565a7e1a70b/src%2Fagents%2Fextensions%2Fmemory%2Fadvanced_sqlalchemy_session.py",
        "sha": "ac225579fa49ba1818f2de245920ddf64277087d",
        "status": "added"
      },
      {
        "additions": 812,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/f8608f767ff995b0e9fd824e6ef7d565a7e1a70b/tests%2Fextensions%2Fmemory%2Ftest_advanced_sqlalchemy_session.py",
        "changes": 812,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/tests%2Fextensions%2Fmemory%2Ftest_advanced_sqlalchemy_session.py?ref=f8608f767ff995b0e9fd824e6ef7d565a7e1a70b",
        "deletions": 0,
        "filename": "tests/extensions/memory/test_advanced_sqlalchemy_session.py",
        "patch": "@@ -0,0 +1,812 @@\n+from __future__ import annotations\n+\n+from collections.abc import AsyncIterator\n+from contextlib import asynccontextmanager\n+from typing import Any, cast\n+\n+import pytest\n+from openai.types.responses.response_usage import InputTokensDetails, OutputTokensDetails\n+\n+pytest.importorskip(\"sqlalchemy\")  # Skip tests if SQLAlchemy is not installed\n+from agents import Agent, Runner, TResponseInputItem, function_tool\n+from agents.extensions.memory import AdvancedSQLAlchemySession\n+from agents.result import RunResult\n+from agents.run_context import RunContextWrapper\n+from agents.usage import Usage\n+from tests.fake_model import FakeModel\n+from tests.test_responses import get_text_message\n+\n+pytestmark = pytest.mark.asyncio\n+\n+DB_URL = \"sqlite+aiosqlite:///:memory:\"\n+\n+\n+@asynccontextmanager\n+async def managed_session(session_id: str) -> AsyncIterator[AdvancedSQLAlchemySession]:\n+    \"\"\"Create an AdvancedSQLAlchemySession and ensure the engine is disposed afterwards.\"\"\"\n+    session = AdvancedSQLAlchemySession.from_url(\n+        session_id,\n+        url=DB_URL,\n+        create_tables=True,\n+    )\n+    try:\n+        yield session\n+    finally:\n+        await session._engine.dispose()\n+\n+\n+@function_tool\n+async def test_tool(query: str) -> str:\n+    \"\"\"A test tool for verifying tool tracking.\"\"\"\n+    return f\"Tool result for: {query}\"\n+\n+\n+@pytest.fixture\n+def agent() -> Agent:\n+    \"\"\"Fixture for a basic agent with a fake model and tooling.\"\"\"\n+    return Agent(name=\"advanced-sqlalchemy\", model=FakeModel(), tools=[test_tool])\n+\n+\n+@pytest.fixture\n+def usage_data() -> Usage:\n+    \"\"\"Fixture providing sample usage data.\"\"\"\n+    return Usage(\n+        requests=1,\n+        input_tokens=50,\n+        output_tokens=30,\n+        total_tokens=80,\n+        input_tokens_details=InputTokensDetails(cached_tokens=10),\n+        output_tokens_details=OutputTokensDetails(reasoning_tokens=5),\n+    )\n+\n+\n+def create_mock_run_result(\n+    usage: Usage | None = None,\n+    agent: Agent | None = None,\n+) -> RunResult:\n+    \"\"\"Helper function to create a RunResult carrying usage information.\"\"\"\n+    if agent is None:\n+        agent = Agent(name=\"test\", model=FakeModel())\n+\n+    if usage is None:\n+        usage = Usage(\n+            requests=1,\n+            input_tokens=50,\n+            output_tokens=30,\n+            total_tokens=80,\n+            input_tokens_details=InputTokensDetails(cached_tokens=10),\n+            output_tokens_details=OutputTokensDetails(reasoning_tokens=5),\n+        )\n+\n+    context_wrapper = RunContextWrapper(context=None, usage=usage)\n+\n+    return RunResult(\n+        input=\"test input\",\n+        new_items=[],\n+        raw_responses=[],\n+        final_output=\"test output\",\n+        input_guardrail_results=[],\n+        output_guardrail_results=[],\n+        tool_input_guardrail_results=[],\n+        tool_output_guardrail_results=[],\n+        context_wrapper=context_wrapper,\n+        _last_agent=agent,\n+    )\n+\n+\n+async def test_advanced_session_basic_functionality():\n+    async with managed_session(\"advanced_test\") as session:\n+        items: list[TResponseInputItem] = [\n+            {\"role\": \"user\", \"content\": \"Hello\"},\n+            {\"role\": \"assistant\", \"content\": \"Hi there!\"},\n+        ]\n+        await session.add_items(items)\n+\n+        retrieved = await session.get_items()\n+        assert len(retrieved) == 2\n+        assert retrieved[0].get(\"content\") == \"Hello\"\n+        assert retrieved[1].get(\"content\") == \"Hi there!\"\n+\n+\n+async def test_message_structure_tracking():\n+    async with managed_session(\"structure_test\") as session:\n+        items: list[TResponseInputItem] = [\n+            {\"role\": \"user\", \"content\": \"What's 2+2?\"},\n+            {\"type\": \"function_call\", \"name\": \"calculator\", \"arguments\": '{\"expression\": \"2+2\"}'},  # type: ignore\n+            {\"type\": \"function_call_output\", \"output\": \"4\"},  # type: ignore\n+            {\"role\": \"assistant\", \"content\": \"The answer is 4\"},\n+            {\"type\": \"reasoning\", \"summary\": [{\"text\": \"Simple math\", \"type\": \"summary_text\"}]},  # type: ignore\n+        ]\n+        await session.add_items(items)\n+\n+        conversation_turns = await session.get_conversation_by_turns()\n+        assert len(conversation_turns) == 1\n+\n+        turn_1_items = conversation_turns[1]\n+        assert len(turn_1_items) == 5\n+\n+        item_types = [item[\"type\"] for item in turn_1_items]\n+        assert \"user\" in item_types\n+        assert \"function_call\" in item_types\n+        assert \"function_call_output\" in item_types\n+        assert \"assistant\" in item_types\n+        assert \"reasoning\" in item_types\n+\n+\n+async def test_tool_usage_tracking():\n+    async with managed_session(\"tools_test\") as session:\n+        items: list[TResponseInputItem] = [\n+            {\"role\": \"user\", \"content\": \"Search for cats\"},\n+            {\"type\": \"function_call\", \"name\": \"web_search\", \"arguments\": '{\"query\": \"cats\"}'},  # type: ignore\n+            {\"type\": \"function_call_output\", \"output\": \"Found cat information\"},  # type: ignore\n+            {\"type\": \"function_call\", \"name\": \"calculator\", \"arguments\": '{\"expression\": \"1+1\"}'},  # type: ignore\n+            {\"type\": \"function_call_output\", \"output\": \"2\"},  # type: ignore\n+            {\"role\": \"assistant\", \"content\": \"I found information and calculated 1+1=2\"},\n+        ]\n+        await session.add_items(items)\n+\n+        tool_usage = await session.get_tool_usage()\n+        assert len(tool_usage) == 2\n+\n+        tool_names = {usage[0] for usage in tool_usage}\n+        assert \"web_search\" in tool_names\n+        assert \"calculator\" in tool_names\n+\n+\n+async def test_branch_listing_and_search():\n+    async with managed_session(\"advanced_listing\") as session:\n+        await session.add_items(\n+            [\n+                {\"role\": \"user\", \"content\": \"Initial turn\"},\n+                {\"role\": \"assistant\", \"content\": \"Reply\"},\n+            ]\n+        )\n+\n+        await session.add_items(\n+            [\n+                {\"role\": \"user\", \"content\": \"Second turn with tool\"},\n+                {\n+                    \"type\": \"mcp_call\",\n+                    \"server_label\": \"search\",\n+                    \"name\": \"lookup\",\n+                    \"role\": \"tool\",\n+                    \"content\": [],\n+                },\n+            ]\n+        )\n+\n+        branches = await session.list_branches()\n+        assert len(branches) == 1\n+        assert branches[0][\"branch_id\"] == \"main\"\n+        assert branches[0][\"user_turns\"] == 2\n+\n+        turns = await session.get_conversation_turns()\n+        assert [turn[\"content\"] for turn in turns] == [\"Initial turn\", \"Second turn with tool\"]\n+\n+        matches = await session.find_turns_by_content(\"Second\")\n+        assert len(matches) == 1\n+        assert matches[0][\"turn\"] == 2\n+\n+        tool_usage = await session.get_tool_usage()\n+        assert tool_usage == [(\"search.lookup\", 1, 2)]\n+\n+\n+async def test_branching_functionality():\n+    async with managed_session(\"branching_test\") as session:\n+        turn_1_items: list[TResponseInputItem] = [\n+            {\"role\": \"user\", \"content\": \"First question\"},\n+            {\"role\": \"assistant\", \"content\": \"First answer\"},\n+        ]\n+        await session.add_items(turn_1_items)\n+\n+        turn_2_items: list[TResponseInputItem] = [\n+            {\"role\": \"user\", \"content\": \"Second question\"},\n+            {\"role\": \"assistant\", \"content\": \"Second answer\"},\n+        ]\n+        await session.add_items(turn_2_items)\n+\n+        turn_3_items: list[TResponseInputItem] = [\n+            {\"role\": \"user\", \"content\": \"Third question\"},\n+            {\"role\": \"assistant\", \"content\": \"Third answer\"},\n+        ]\n+        await session.add_items(turn_3_items)\n+\n+        all_items = await session.get_items()\n+        assert len(all_items) == 6\n+\n+        branch_name = await session.create_branch_from_turn(2, \"test_branch\")\n+        assert branch_name == \"test_branch\"\n+        assert session._current_branch_id == \"test_branch\"\n+\n+        branch_items = await session.get_items()\n+        assert len(branch_items) == 2\n+        assert branch_items[0].get(\"content\") == \"First question\"\n+        assert branch_items[1].get(\"content\") == \"First answer\"\n+\n+        await session.switch_to_branch(\"main\")\n+        assert session._current_branch_id == \"main\"\n+\n+        main_items = await session.get_items()\n+        assert len(main_items) == 6\n+\n+        branches = await session.list_branches()\n+        assert len(branches) == 2\n+        branch_ids = [branch[\"branch_id\"] for branch in branches]\n+        assert \"main\" in branch_ids\n+        assert \"test_branch\" in branch_ids\n+\n+        await session.delete_branch(\"test_branch\")\n+        branches_after_delete = await session.list_branches()\n+        assert len(branches_after_delete) == 1\n+        assert branches_after_delete[0][\"branch_id\"] == \"main\"\n+\n+\n+async def test_get_conversation_turns():\n+    async with managed_session(\"conversation_turns_test\") as session:\n+        turn_1_items: list[TResponseInputItem] = [\n+            {\"role\": \"user\", \"content\": \"Hello there\"},\n+            {\"role\": \"assistant\", \"content\": \"Hi!\"},\n+        ]\n+        await session.add_items(turn_1_items)\n+\n+        turn_2_items: list[TResponseInputItem] = [\n+            {\"role\": \"user\", \"content\": \"How are you doing today?\"},\n+            {\"role\": \"assistant\", \"content\": \"I'm doing well, thanks!\"},\n+        ]\n+        await session.add_items(turn_2_items)\n+\n+        turns = await session.get_conversation_turns()\n+        assert len(turns) == 2\n+\n+        assert turns[0][\"turn\"] == 1\n+        assert turns[0][\"content\"] == \"Hello there\"\n+        assert turns[0][\"full_content\"] == \"Hello there\"\n+        assert turns[0][\"can_branch\"] is True\n+        assert \"timestamp\" in turns[0]\n+\n+        assert turns[1][\"turn\"] == 2\n+        assert turns[1][\"content\"] == \"How are you doing today?\"\n+        assert turns[1][\"full_content\"] == \"How are you doing today?\"\n+        assert turns[1][\"can_branch\"] is True\n+\n+\n+async def test_find_turns_by_content():\n+    async with managed_session(\"find_turns_test\") as session:\n+        turn_1_items: list[TResponseInputItem] = [\n+            {\"role\": \"user\", \"content\": \"Tell me about cats\"},\n+            {\"role\": \"assistant\", \"content\": \"Cats are great pets\"},\n+        ]\n+        await session.add_items(turn_1_items)\n+\n+        turn_2_items: list[TResponseInputItem] = [\n+            {\"role\": \"user\", \"content\": \"What about dogs?\"},\n+            {\"role\": \"assistant\", \"content\": \"Dogs are also great pets\"},\n+        ]\n+        await session.add_items(turn_2_items)\n+\n+        turn_3_items: list[TResponseInputItem] = [\n+            {\"role\": \"user\", \"content\": \"Tell me about cats again\"},\n+            {\"role\": \"assistant\", \"content\": \"Cats are wonderful companions\"},\n+        ]\n+        await session.add_items(turn_3_items)\n+\n+        cat_turns = await session.find_turns_by_content(\"cats\")\n+        assert len(cat_turns) == 2\n+        assert cat_turns[0][\"turn\"] == 1\n+        assert cat_turns[1][\"turn\"] == 3\n+\n+        dog_turns = await session.find_turns_by_content(\"dogs\")\n+        assert len(dog_turns) == 1\n+        assert dog_turns[0][\"turn\"] == 2\n+\n+        no_turns = await session.find_turns_by_content(\"elephants\")\n+        assert len(no_turns) == 0\n+\n+\n+async def test_create_branch_from_content():\n+    async with managed_session(\"branch_from_content_test\") as session:\n+        turn_1_items: list[TResponseInputItem] = [\n+            {\"role\": \"user\", \"content\": \"First question about math\"},\n+            {\"role\": \"assistant\", \"content\": \"Math answer\"},\n+        ]\n+        await session.add_items(turn_1_items)\n+\n+        turn_2_items: list[TResponseInputItem] = [\n+            {\"role\": \"user\", \"content\": \"Second question about science\"},\n+            {\"role\": \"assistant\", \"content\": \"Science answer\"},\n+        ]\n+        await session.add_items(turn_2_items)\n+\n+        turn_3_items: list[TResponseInputItem] = [\n+            {\"role\": \"user\", \"content\": \"Another math question\"},\n+            {\"role\": \"assistant\", \"content\": \"Another math answer\"},\n+        ]\n+        await session.add_items(turn_3_items)\n+\n+        branch_name = await session.create_branch_from_content(\"math\", \"math_branch\")\n+        assert branch_name == \"math_branch\"\n+        assert session._current_branch_id == \"math_branch\"\n+\n+        branch_items = await session.get_items()\n+        assert len(branch_items) == 0\n+\n+        with pytest.raises(ValueError, match=\"No user turns found containing 'nonexistent'\"):\n+            await session.create_branch_from_content(\"nonexistent\", \"error_branch\")\n+\n+\n+async def test_branch_specific_operations():\n+    async with managed_session(\"branch_specific_test\") as session:\n+        turn_1_items: list[TResponseInputItem] = [\n+            {\"role\": \"user\", \"content\": \"Main branch question\"},\n+            {\"role\": \"assistant\", \"content\": \"Main branch answer\"},\n+        ]\n+        await session.add_items(turn_1_items)\n+\n+        usage_main = Usage(requests=1, input_tokens=50, output_tokens=30, total_tokens=80)\n+        run_result_main = create_mock_run_result(usage_main)\n+        await session.store_run_usage(run_result_main)\n+\n+        await session.create_branch_from_turn(1, \"test_branch\")\n+\n+        turn_2_items: list[TResponseInputItem] = [\n+            {\"role\": \"user\", \"content\": \"Branch question\"},\n+            {\"role\": \"assistant\", \"content\": \"Branch answer\"},\n+        ]\n+        await session.add_items(turn_2_items)\n+\n+        usage_branch = Usage(requests=1, input_tokens=40, output_tokens=20, total_tokens=60)\n+        run_result_branch = create_mock_run_result(usage_branch)\n+        await session.store_run_usage(run_result_branch)\n+\n+        main_items = await session.get_items(branch_id=\"main\")\n+        assert len(main_items) == 2\n+        assert main_items[0].get(\"content\") == \"Main branch question\"\n+\n+        current_items = await session.get_items()\n+        assert len(current_items) == 2\n+\n+        main_turns = await session.get_conversation_turns(branch_id=\"main\")\n+        assert len(main_turns) == 1\n+        assert main_turns[0][\"content\"] == \"Main branch question\"\n+\n+        current_turns = await session.get_conversation_turns()\n+        assert len(current_turns) == 1\n+\n+        main_usage = await session.get_session_usage(branch_id=\"main\")\n+        assert main_usage is not None\n+        assert main_usage[\"total_turns\"] == 1\n+\n+        all_usage = await session.get_session_usage()\n+        assert all_usage is not None\n+        assert all_usage[\"total_turns\"] == 2\n+\n+\n+async def test_branch_error_handling():\n+    async with managed_session(\"branch_error_test\") as session:\n+        with pytest.raises(ValueError, match=\"Turn 5 does not contain a user message\"):\n+            await session.create_branch_from_turn(5, \"error_branch\")\n+\n+        with pytest.raises(ValueError, match=\"Branch 'nonexistent' does not exist\"):\n+            await session.switch_to_branch(\"nonexistent\")\n+\n+        with pytest.raises(ValueError, match=\"Branch 'nonexistent' does not exist\"):\n+            await session.delete_branch(\"nonexistent\")\n+\n+        with pytest.raises(ValueError, match=\"Cannot delete the 'main' branch\"):\n+            await session.delete_branch(\"main\")\n+\n+        with pytest.raises(ValueError, match=\"Branch ID cannot be empty\"):\n+            await session.delete_branch(\"\")\n+\n+        with pytest.raises(ValueError, match=\"Branch ID cannot be empty\"):\n+            await session.delete_branch(\"   \")\n+\n+\n+async def test_branch_deletion_with_force():\n+    async with managed_session(\"force_delete_test\") as session:\n+        await session.add_items([{\"role\": \"user\", \"content\": \"Main question\"}])\n+        await session.add_items([{\"role\": \"user\", \"content\": \"Second question\"}])\n+\n+        await session.create_branch_from_turn(2, \"temp_branch\")\n+        assert session._current_branch_id == \"temp_branch\"\n+\n+        await session.add_items([{\"role\": \"user\", \"content\": \"Branch question\"}])\n+\n+        branches = await session.list_branches()\n+        branch_ids = [branch[\"branch_id\"] for branch in branches]\n+        assert \"temp_branch\" in branch_ids\n+\n+        with pytest.raises(ValueError, match=\"Cannot delete current branch\"):\n+            await session.delete_branch(\"temp_branch\")\n+\n+        await session.delete_branch(\"temp_branch\", force=True)\n+        assert session._current_branch_id == \"main\"\n+\n+        branches_after = await session.list_branches()\n+        assert len(branches_after) == 1\n+        assert branches_after[0][\"branch_id\"] == \"main\"\n+\n+\n+async def test_get_items_with_parameters():\n+    async with managed_session(\"get_items_params_test\") as session:\n+        items: list[TResponseInputItem] = [\n+            {\"role\": \"user\", \"content\": \"First question\"},\n+            {\"role\": \"assistant\", \"content\": \"First answer\"},\n+            {\"role\": \"user\", \"content\": \"Second question\"},\n+            {\"role\": \"assistant\", \"content\": \"Second answer\"},\n+        ]\n+        await session.add_items(items)\n+\n+        limited_items = await session.get_items(limit=2)\n+        assert len(limited_items) == 2\n+        assert limited_items[0].get(\"content\") == \"Second question\"\n+        assert limited_items[1].get(\"content\") == \"Second answer\"\n+\n+        main_items = await session.get_items(branch_id=\"main\")\n+        assert len(main_items) == 4\n+\n+        all_items = await session.get_items()\n+        assert len(all_items) == 4\n+\n+        await session.create_branch_from_turn(2, \"test_branch\")\n+\n+        branch_items: list[TResponseInputItem] = [\n+            {\"role\": \"user\", \"content\": \"Branch question\"},\n+            {\"role\": \"assistant\", \"content\": \"Branch answer\"},\n+        ]\n+        await session.add_items(branch_items)\n+\n+        branch_items_result = await session.get_items(branch_id=\"test_branch\")\n+        assert len(branch_items_result) == 4\n+\n+        main_items_from_branch = await session.get_items(branch_id=\"main\")\n+        assert len(main_items_from_branch) == 4\n+\n+\n+async def test_usage_tracking_storage(agent: Agent, usage_data: Usage):\n+    async with managed_session(\"usage_test\") as session:\n+        await session.add_items([{\"role\": \"user\", \"content\": \"First turn\"}])\n+        run_result_1 = create_mock_run_result(usage_data)\n+        await session.store_run_usage(run_result_1)\n+\n+        usage_data_2 = Usage(\n+            requests=2,\n+            input_tokens=75,\n+            output_tokens=45,\n+            total_tokens=120,\n+            input_tokens_details=InputTokensDetails(cached_tokens=20),\n+            output_tokens_details=OutputTokensDetails(reasoning_tokens=15),\n+        )\n+\n+        await session.add_items([{\"role\": \"user\", \"content\": \"Second turn\"}])\n+        run_result_2 = create_mock_run_result(usage_data_2)\n+        await session.store_run_usage(run_result_2)\n+\n+        session_usage = await session.get_session_usage()\n+        assert session_usage is not None\n+        assert session_usage[\"requests\"] == 3\n+        assert session_usage[\"total_tokens\"] == 200\n+        assert session_usage[\"input_tokens\"] == 125\n+        assert session_usage[\"output_tokens\"] == 75\n+        assert session_usage[\"total_turns\"] == 2\n+\n+        turn_1_usage = await session.get_turn_usage(1)\n+        assert isinstance(turn_1_usage, dict)\n+        assert turn_1_usage[\"requests\"] == 1\n+        assert turn_1_usage[\"total_tokens\"] == 80\n+        assert turn_1_usage[\"input_tokens_details\"][\"cached_tokens\"] == 10\n+        assert turn_1_usage[\"output_tokens_details\"][\"reasoning_tokens\"] == 5\n+\n+        turn_2_usage = await session.get_turn_usage(2)\n+        assert isinstance(turn_2_usage, dict)\n+        assert turn_2_usage[\"requests\"] == 2\n+        assert turn_2_usage[\"total_tokens\"] == 120\n+        assert turn_2_usage[\"input_tokens_details\"][\"cached_tokens\"] == 20\n+        assert turn_2_usage[\"output_tokens_details\"][\"reasoning_tokens\"] == 15\n+\n+        all_turn_usage = await session.get_turn_usage()\n+        assert isinstance(all_turn_usage, list)\n+        assert len(all_turn_usage) == 2\n+        assert all_turn_usage[0][\"user_turn_number\"] == 1\n+        assert all_turn_usage[1][\"user_turn_number\"] == 2\n+\n+\n+async def test_runner_integration_with_usage_tracking(agent: Agent):\n+    async with managed_session(\"integration_test\") as session:\n+\n+        async def store_session_usage(result: Any, session: AdvancedSQLAlchemySession):\n+            try:\n+                await session.store_run_usage(result)\n+            except Exception:\n+                pass\n+\n+        assert isinstance(agent.model, FakeModel)\n+        fake_model = agent.model\n+        fake_model.set_next_output([get_text_message(\"San Francisco\")])\n+\n+        result1 = await Runner.run(\n+            agent,\n+            \"What city is the Golden Gate Bridge in?\",\n+            session=session,\n+        )\n+        assert result1.final_output == \"San Francisco\"\n+        await store_session_usage(result1, session)\n+\n+        fake_model.set_next_output([get_text_message(\"California\")])\n+        result2 = await Runner.run(\n+            agent,\n+            \"What state is it in?\",\n+            session=session,\n+        )\n+        assert result2.final_output == \"California\"\n+        await store_session_usage(result2, session)\n+\n+        conversation_turns = await session.get_conversation_by_turns()\n+        assert len(conversation_turns) == 2\n+\n+        session_usage = await session.get_session_usage()\n+        assert session_usage is not None\n+        assert session_usage[\"total_turns\"] == 2\n+        assert \"requests\" in session_usage\n+        assert \"total_tokens\" in session_usage\n+\n+\n+async def test_sequence_ordering():\n+    async with managed_session(\"sequence_test\") as session:\n+        items: list[TResponseInputItem] = [\n+            {\"role\": \"user\", \"content\": \"Message 1\"},\n+            {\"role\": \"assistant\", \"content\": \"Response 1\"},\n+            {\"role\": \"user\", \"content\": \"Message 2\"},\n+            {\"role\": \"assistant\", \"content\": \"Response 2\"},\n+        ]\n+        await session.add_items(items)\n+\n+        retrieved = await session.get_items()\n+        assert len(retrieved) == 4\n+        assert retrieved[0].get(\"content\") == \"Message 1\"\n+        assert retrieved[1].get(\"content\") == \"Response 1\"\n+        assert retrieved[2].get(\"content\") == \"Message 2\"\n+        assert retrieved[3].get(\"content\") == \"Response 2\"\n+\n+\n+async def test_conversation_structure_with_multiple_turns():\n+    async with managed_session(\"multi_turn_test\") as session:\n+        turn_1: list[TResponseInputItem] = [\n+            {\"role\": \"user\", \"content\": \"Hello\"},\n+            {\"role\": \"assistant\", \"content\": \"Hi!\"},\n+        ]\n+        await session.add_items(turn_1)\n+\n+        turn_2: list[TResponseInputItem] = [\n+            {\"role\": \"user\", \"content\": \"How are you?\"},\n+            {\"type\": \"function_call\", \"name\": \"mood_check\", \"arguments\": \"{}\"},  # type: ignore\n+            {\"type\": \"function_call_output\", \"output\": \"I'm good\"},  # type: ignore\n+            {\"role\": \"assistant\", \"content\": \"I'm doing well!\"},\n+        ]\n+        await session.add_items(turn_2)\n+\n+        turn_3: list[TResponseInputItem] = [\n+            {\"role\": \"user\", \"content\": \"Goodbye\"},\n+            {\"role\": \"assistant\", \"content\": \"See you later!\"},\n+        ]\n+        await session.add_items(turn_3)\n+\n+        conversation_turns = await session.get_conversation_by_turns()\n+        assert len(conversation_turns) == 3\n+\n+        assert len(conversation_turns[1]) == 2\n+        assert conversation_turns[1][0][\"type\"] == \"user\"\n+        assert conversation_turns[1][1][\"type\"] == \"assistant\"\n+\n+        assert len(conversation_turns[2]) == 4\n+        turn_2_types = [item[\"type\"] for item in conversation_turns[2]]\n+        assert \"user\" in turn_2_types\n+        assert \"function_call\" in turn_2_types\n+        assert \"function_call_output\" in turn_2_types\n+        assert \"assistant\" in turn_2_types\n+\n+        assert len(conversation_turns[3]) == 2\n+\n+\n+async def test_empty_session_operations():\n+    async with managed_session(\"empty_test\") as session:\n+        items = await session.get_items()\n+        assert len(items) == 0\n+\n+        conversation = await session.get_conversation_by_turns()\n+        assert len(conversation) == 0\n+\n+        tool_usage = await session.get_tool_usage()\n+        assert len(tool_usage) == 0\n+\n+        session_usage = await session.get_session_usage()\n+        assert session_usage is None\n+\n+        turns = await session.get_conversation_turns()\n+        assert len(turns) == 0\n+\n+\n+async def test_json_serialization_edge_cases(usage_data: Usage):\n+    async with managed_session(\"json_test\") as session:\n+        await session.add_items([{\"role\": \"user\", \"content\": \"First test\"}])\n+        run_result_1 = create_mock_run_result(usage_data)\n+        await session.store_run_usage(run_result_1)\n+\n+        run_result_none = create_mock_run_result(None)\n+        await session.store_run_usage(run_result_none)\n+\n+        minimal_usage = Usage(\n+            requests=1,\n+            input_tokens=10,\n+            output_tokens=5,\n+            total_tokens=15,\n+        )\n+        await session.add_items([{\"role\": \"user\", \"content\": \"Second test\"}])\n+        run_result_2 = create_mock_run_result(minimal_usage)\n+        await session.store_run_usage(run_result_2)\n+\n+        turn_1_usage = await session.get_turn_usage(1)\n+        assert isinstance(turn_1_usage, dict)\n+        assert turn_1_usage[\"requests\"] == 1\n+        assert turn_1_usage[\"input_tokens_details\"][\"cached_tokens\"] == 10\n+\n+        turn_2_usage = await session.get_turn_usage(2)\n+        assert isinstance(turn_2_usage, dict)\n+        assert turn_2_usage[\"requests\"] == 1\n+        assert turn_2_usage[\"input_tokens_details\"][\"cached_tokens\"] == 0\n+        assert turn_2_usage[\"output_tokens_details\"][\"reasoning_tokens\"] == 0\n+\n+\n+async def test_session_isolation():\n+    async with managed_session(\"session_1\") as session1, managed_session(\"session_2\") as session2:\n+        await session1.add_items([{\"role\": \"user\", \"content\": \"Session 1 message\"}])\n+        await session2.add_items([{\"role\": \"user\", \"content\": \"Session 2 message\"}])\n+\n+        session1_items = await session1.get_items()\n+        session2_items = await session2.get_items()\n+\n+        assert len(session1_items) == 1\n+        assert len(session2_items) == 1\n+        assert session1_items[0].get(\"content\") == \"Session 1 message\"\n+        assert session2_items[0].get(\"content\") == \"Session 2 message\"\n+\n+        session1_turns = await session1.get_conversation_by_turns()\n+        session2_turns = await session2.get_conversation_by_turns()\n+\n+        assert len(session1_turns) == 1\n+        assert len(session2_turns) == 1\n+\n+\n+async def test_error_handling_in_usage_tracking(usage_data: Usage):\n+    async with managed_session(\"error_test\") as session:\n+        run_result = create_mock_run_result(usage_data)\n+        await session.store_run_usage(run_result)\n+\n+        await session._engine.dispose()\n+        await session.store_run_usage(run_result)\n+\n+\n+async def test_advanced_tool_name_extraction():\n+    async with managed_session(\"advanced_tool_names_test\") as session:\n+        items: list[TResponseInputItem] = [\n+            {\"role\": \"user\", \"content\": \"Use various tools\"},\n+            {\n+                \"type\": \"mcp_call\",\n+                \"server_label\": \"filesystem\",\n+                \"name\": \"read_file\",\n+                \"arguments\": \"{}\",\n+            },  # type: ignore\n+            {\n+                \"type\": \"mcp_approval_request\",\n+                \"server_label\": \"database\",\n+                \"name\": \"execute_query\",\n+                \"arguments\": \"{}\",\n+            },  # type: ignore\n+            {\"type\": \"computer_call\", \"arguments\": \"{}\"},  # type: ignore\n+            {\"type\": \"file_search_call\", \"arguments\": \"{}\"},  # type: ignore\n+            {\"type\": \"web_search_call\", \"arguments\": \"{}\"},  # type: ignore\n+            {\"type\": \"code_interpreter_call\", \"arguments\": \"{}\"},  # type: ignore\n+            {\"type\": \"function_call\", \"name\": \"calculator\", \"arguments\": \"{}\"},  # type: ignore\n+            {\"type\": \"custom_tool_call\", \"name\": \"custom_tool\", \"arguments\": \"{}\"},  # type: ignore\n+        ]\n+        await session.add_items(items)\n+\n+        conversation_turns = await session.get_conversation_by_turns()\n+        turn_items = conversation_turns[1]\n+\n+        tool_items = [item for item in turn_items if item[\"tool_name\"]]\n+        tool_names = [item[\"tool_name\"] for item in tool_items]\n+\n+        assert \"filesystem.read_file\" in tool_names\n+        assert \"database.execute_query\" in tool_names\n+        assert \"computer_call\" in tool_names\n+        assert \"file_search_call\" in tool_names\n+        assert \"web_search_call\" in tool_names\n+        assert \"code_interpreter_call\" in tool_names\n+        assert \"calculator\" in tool_names\n+        assert \"custom_tool\" in tool_names\n+\n+\n+async def test_branch_usage_tracking():\n+    async with managed_session(\"branch_usage_test\") as session:\n+        await session.add_items([{\"role\": \"user\", \"content\": \"Main question\"}])\n+        usage_main = Usage(requests=1, input_tokens=50, output_tokens=30, total_tokens=80)\n+        run_result_main = create_mock_run_result(usage_main)\n+        await session.store_run_usage(run_result_main)\n+\n+        await session.create_branch_from_turn(1, \"usage_branch\")\n+        await session.add_items([{\"role\": \"user\", \"content\": \"Branch question\"}])\n+        usage_branch = Usage(requests=2, input_tokens=100, output_tokens=60, total_tokens=160)\n+        run_result_branch = create_mock_run_result(usage_branch)\n+        await session.store_run_usage(run_result_branch)\n+\n+        main_usage = await session.get_session_usage(branch_id=\"main\")\n+        assert main_usage is not None\n+        assert main_usage[\"requests\"] == 1\n+        assert main_usage[\"total_tokens\"] == 80\n+        assert main_usage[\"total_turns\"] == 1\n+\n+        branch_usage = await session.get_session_usage(branch_id=\"usage_branch\")\n+        assert branch_usage is not None\n+        assert branch_usage[\"requests\"] == 2\n+        assert branch_usage[\"total_tokens\"] == 160\n+        assert branch_usage[\"total_turns\"] == 1\n+\n+        total_usage = await session.get_session_usage()\n+        assert total_usage is not None\n+        assert total_usage[\"requests\"] == 3\n+        assert total_usage[\"total_tokens\"] == 240\n+        assert total_usage[\"total_turns\"] == 2\n+\n+        branch_turn_usage = await session.get_turn_usage(branch_id=\"usage_branch\")\n+        assert isinstance(branch_turn_usage, list)\n+        assert len(branch_turn_usage) == 1\n+        assert branch_turn_usage[0][\"requests\"] == 2\n+\n+\n+async def test_tool_name_extraction():\n+    async with managed_session(\"tool_names_test\") as session:\n+        items: list[TResponseInputItem] = [\n+            {\"role\": \"user\", \"content\": \"Use tools please\"},\n+            {\"type\": \"function_call\", \"name\": \"search_web\", \"arguments\": \"{}\"},  # type: ignore\n+            {\"type\": \"function_call_output\", \"tool_name\": \"search_web\", \"output\": \"result\"},  # type: ignore\n+            {\"type\": \"function_call\", \"name\": \"calculator\", \"arguments\": \"{}\"},  # type: ignore\n+        ]\n+        await session.add_items(items)\n+\n+        conversation_turns = await session.get_conversation_by_turns()\n+        turn_items = conversation_turns[1]\n+\n+        tool_items = [item for item in turn_items if item[\"tool_name\"]]\n+        tool_names = [item[\"tool_name\"] for item in tool_items]\n+\n+        assert \"search_web\" in tool_names\n+        assert \"calculator\" in tool_names\n+\n+\n+async def test_tool_execution_integration(agent: Agent):\n+    async with managed_session(\"tool_integration_test\") as session:\n+        fake_model = cast(FakeModel, agent.model)\n+        fake_model.set_next_output(\n+            [\n+                {  # type: ignore\n+                    \"type\": \"function_call\",\n+                    \"name\": \"test_tool\",\n+                    \"arguments\": '{\"query\": \"test query\"}',\n+                    \"call_id\": \"call_123\",\n+                }\n+            ]\n+        )\n+\n+        fake_model.set_next_output([get_text_message(\"Tool executed successfully\")])\n+\n+        result = await Runner.run(\n+            agent,\n+            \"Please use the test tool\",\n+            session=session,\n+        )\n+\n+        assert \"Tool result for: test query\" in str(result.new_items)\n+\n+        tool_usage = await session.get_tool_usage()\n+        assert len(tool_usage) > 0",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/f8608f767ff995b0e9fd824e6ef7d565a7e1a70b/tests%2Fextensions%2Fmemory%2Ftest_advanced_sqlalchemy_session.py",
        "sha": "d9b3bd612dde0f8c2d1fb4a0a1463918c6c4a658",
        "status": "added"
      }
    ],
    "status": 200
  },
  "started_at": "2026-01-20T04:53:07.320936Z"
}
