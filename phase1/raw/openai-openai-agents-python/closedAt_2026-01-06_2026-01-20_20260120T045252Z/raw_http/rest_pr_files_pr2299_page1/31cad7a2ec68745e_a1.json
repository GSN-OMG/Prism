{
  "finished_at": "2026-01-20T04:56:27.381634Z",
  "meta": {
    "attempt": 1,
    "request_fingerprint": "31cad7a2ec68745e",
    "tag": "rest_pr_files_pr2299_page1"
  },
  "request": {
    "body": null,
    "headers": {
      "Accept": "application/vnd.github+json",
      "X-GitHub-Api-Version": "2022-11-28"
    },
    "method": "GET",
    "url": "https://api.github.com/repos/openai/openai-agents-python/pulls/2299/files?per_page=100&page=1"
  },
  "response": {
    "headers": {
      "access-control-allow-origin": "*",
      "access-control-expose-headers": "ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Resource, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, X-GitHub-SSO, X-GitHub-Request-Id, Deprecation, Sunset",
      "cache-control": "private, max-age=60, s-maxage=60",
      "content-length": "15639",
      "content-security-policy": "default-src 'none'",
      "content-type": "application/json; charset=utf-8",
      "date": "Tue, 20 Jan 2026 04:56:27 GMT",
      "etag": "\"206130f09cd718a3b2b377b54d45d8c2c48526977ad77ee4c95b1b18e66952ee\"",
      "github-authentication-token-expiration": "2026-02-19 04:41:20 UTC",
      "last-modified": "Thu, 15 Jan 2026 14:21:44 GMT",
      "referrer-policy": "origin-when-cross-origin, strict-origin-when-cross-origin",
      "server": "github.com",
      "strict-transport-security": "max-age=31536000; includeSubdomains; preload",
      "vary": "Accept, Authorization, Cookie, X-GitHub-OTP,Accept-Encoding, Accept, X-Requested-With",
      "x-accepted-oauth-scopes": "",
      "x-content-type-options": "nosniff",
      "x-frame-options": "deny",
      "x-github-api-version-selected": "2022-11-28",
      "x-github-media-type": "github.v3; format=json",
      "x-github-request-id": "DC1C:221B33:154133D:1E4BBA8:696F0AFB",
      "x-oauth-scopes": "repo",
      "x-ratelimit-limit": "5000",
      "x-ratelimit-remaining": "4955",
      "x-ratelimit-reset": "1768885989",
      "x-ratelimit-resource": "core",
      "x-ratelimit-used": "45",
      "x-xss-protection": "0"
    },
    "json": [
      {
        "additions": 68,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/ed7ec6209d1572e124a3d3ec04473de19253bd1e/src%2Fagents%2F_run_impl.py",
        "changes": 72,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/src%2Fagents%2F_run_impl.py?ref=ed7ec6209d1572e124a3d3ec04473de19253bd1e",
        "deletions": 4,
        "filename": "src/agents/_run_impl.py",
        "patch": "@@ -1739,6 +1739,9 @@ async def execute(\n         shell_output_payload: list[dict[str, Any]] | None = None\n         provider_meta: dict[str, Any] | None = None\n         max_output_length: int | None = None\n+        requested_max_output_length = _normalize_max_output_length(\n+            shell_call.action.max_output_length\n+        )\n \n         try:\n             executor_result = call.shell_tool.executor(request)\n@@ -1748,15 +1751,31 @@ async def execute(\n \n             if isinstance(result, ShellResult):\n                 normalized = [_normalize_shell_output(entry) for entry in result.output]\n+                result_max_output_length = _normalize_max_output_length(result.max_output_length)\n+                if result_max_output_length is None:\n+                    max_output_length = requested_max_output_length\n+                elif requested_max_output_length is None:\n+                    max_output_length = result_max_output_length\n+                else:\n+                    max_output_length = min(result_max_output_length, requested_max_output_length)\n+                if max_output_length is not None:\n+                    normalized = _truncate_shell_outputs(normalized, max_output_length)\n                 output_text = _render_shell_outputs(normalized)\n+                if max_output_length is not None:\n+                    output_text = output_text[:max_output_length]\n                 shell_output_payload = [_serialize_shell_output(entry) for entry in normalized]\n                 provider_meta = dict(result.provider_data or {})\n-                max_output_length = result.max_output_length\n             else:\n                 output_text = str(result)\n+                if requested_max_output_length is not None:\n+                    max_output_length = requested_max_output_length\n+                    output_text = output_text[:max_output_length]\n         except Exception as exc:\n             status = \"failed\"\n             output_text = _format_shell_error(exc)\n+            if requested_max_output_length is not None:\n+                max_output_length = requested_max_output_length\n+                output_text = output_text[:max_output_length]\n             logger.error(\"Shell executor failed: %s\", exc, exc_info=True)\n \n         await asyncio.gather(\n@@ -2029,6 +2048,51 @@ def _render_shell_outputs(outputs: Sequence[ShellCommandOutput]) -> str:\n     return \"\\n\\n\".join(rendered_chunks)\n \n \n+def _truncate_shell_outputs(\n+    outputs: Sequence[ShellCommandOutput], max_length: int\n+) -> list[ShellCommandOutput]:\n+    if max_length <= 0:\n+        return [\n+            ShellCommandOutput(\n+                stdout=\"\",\n+                stderr=\"\",\n+                outcome=output.outcome,\n+                command=output.command,\n+                provider_data=output.provider_data,\n+            )\n+            for output in outputs\n+        ]\n+\n+    remaining = max_length\n+    truncated: list[ShellCommandOutput] = []\n+    for output in outputs:\n+        stdout = \"\"\n+        stderr = \"\"\n+        if remaining > 0 and output.stdout:\n+            stdout = output.stdout[:remaining]\n+            remaining -= len(stdout)\n+        if remaining > 0 and output.stderr:\n+            stderr = output.stderr[:remaining]\n+            remaining -= len(stderr)\n+        truncated.append(\n+            ShellCommandOutput(\n+                stdout=stdout,\n+                stderr=stderr,\n+                outcome=output.outcome,\n+                command=output.command,\n+                provider_data=output.provider_data,\n+            )\n+        )\n+\n+    return truncated\n+\n+\n+def _normalize_max_output_length(value: int | None) -> int | None:\n+    if value is None:\n+        return None\n+    return max(0, value)\n+\n+\n def _format_shell_error(error: Exception | BaseException | Any) -> str:\n     if isinstance(error, Exception):\n         message = str(error)\n@@ -2078,9 +2142,9 @@ def _coerce_shell_call(tool_call: Any) -> ShellCallData:\n     )\n     timeout_ms = int(timeout_value) if isinstance(timeout_value, (int, float)) else None\n \n-    max_length_value = _get_mapping_or_attr(\n-        action_payload, \"max_output_length\"\n-    ) or _get_mapping_or_attr(action_payload, \"maxOutputLength\")\n+    max_length_value = _get_mapping_or_attr(action_payload, \"max_output_length\")\n+    if max_length_value is None:\n+        max_length_value = _get_mapping_or_attr(action_payload, \"maxOutputLength\")\n     max_output_length = (\n         int(max_length_value) if isinstance(max_length_value, (int, float)) else None\n     )",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/ed7ec6209d1572e124a3d3ec04473de19253bd1e/src%2Fagents%2F_run_impl.py",
        "sha": "7552f1db7dc107d267e0cbb21b1af47e3e4b6feb",
        "status": "modified"
      },
      {
        "additions": 241,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/ed7ec6209d1572e124a3d3ec04473de19253bd1e/tests%2Ftest_shell_tool.py",
        "changes": 245,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/tests%2Ftest_shell_tool.py?ref=ed7ec6209d1572e124a3d3ec04473de19253bd1e",
        "deletions": 4,
        "filename": "tests/test_shell_tool.py",
        "patch": "@@ -94,15 +94,19 @@ async def test_shell_tool_structured_output_is_rendered() -> None:\n async def test_shell_tool_executor_failure_returns_error() -> None:\n     class ExplodingExecutor:\n         def __call__(self, request):\n-            raise RuntimeError(\"boom\")\n+            raise RuntimeError(\"boom\" * 10)\n \n     shell_tool = ShellTool(executor=ExplodingExecutor())\n     tool_call = {\n         \"type\": \"shell_call\",\n         \"id\": \"shell_call_fail\",\n         \"call_id\": \"call_shell_fail\",\n         \"status\": \"completed\",\n-        \"action\": {\"commands\": [\"echo boom\"], \"timeout_ms\": 1000},\n+        \"action\": {\n+            \"commands\": [\"echo boom\"],\n+            \"timeout_ms\": 1000,\n+            \"max_output_length\": 6,\n+        },\n     }\n     tool_run = ToolRunShellCall(tool_call=tool_call, shell_tool=shell_tool)\n     agent = Agent(name=\"shell-agent\", tools=[shell_tool])\n@@ -117,12 +121,13 @@ def __call__(self, request):\n     )\n \n     assert isinstance(result, ToolCallOutputItem)\n-    assert \"boom\" in result.output\n+    assert result.output == \"boombo\"\n     raw_item = cast(dict[str, Any], result.raw_item)\n     assert raw_item[\"type\"] == \"shell_call_output\"\n     assert raw_item[\"status\"] == \"failed\"\n+    assert raw_item[\"max_output_length\"] == 6\n     assert isinstance(raw_item[\"output\"], list)\n-    assert \"boom\" in raw_item[\"output\"][0][\"stdout\"]\n+    assert raw_item[\"output\"][0][\"stdout\"] == \"boombo\"\n     first_output = raw_item[\"output\"][0]\n     assert first_output[\"outcome\"][\"type\"] == \"exit\"\n     assert first_output[\"outcome\"][\"exit_code\"] == 1\n@@ -135,3 +140,235 @@ def __call__(self, request):\n     assert \"status\" not in payload_dict\n     assert \"shell_output\" not in payload_dict\n     assert \"provider_data\" not in payload_dict\n+\n+\n+@pytest.mark.asyncio\n+async def test_shell_tool_output_respects_max_output_length() -> None:\n+    shell_tool = ShellTool(\n+        executor=lambda request: ShellResult(\n+            output=[\n+                ShellCommandOutput(\n+                    stdout=\"0123456789\",\n+                    stderr=\"abcdef\",\n+                    outcome=ShellCallOutcome(type=\"exit\", exit_code=0),\n+                )\n+            ],\n+        )\n+    )\n+\n+    tool_call = {\n+        \"type\": \"shell_call\",\n+        \"id\": \"shell_call\",\n+        \"call_id\": \"call_shell\",\n+        \"status\": \"completed\",\n+        \"action\": {\n+            \"commands\": [\"echo hi\"],\n+            \"timeout_ms\": 1000,\n+            \"max_output_length\": 6,\n+        },\n+    }\n+\n+    tool_run = ToolRunShellCall(tool_call=tool_call, shell_tool=shell_tool)\n+    agent = Agent(name=\"shell-agent\", tools=[shell_tool])\n+    context_wrapper: RunContextWrapper[Any] = RunContextWrapper(context=None)\n+\n+    result = await ShellAction.execute(\n+        agent=agent,\n+        call=tool_run,\n+        hooks=RunHooks[Any](),\n+        context_wrapper=context_wrapper,\n+        config=RunConfig(),\n+    )\n+\n+    assert isinstance(result, ToolCallOutputItem)\n+    assert result.output == \"012345\"\n+    raw_item = cast(dict[str, Any], result.raw_item)\n+    assert raw_item[\"max_output_length\"] == 6\n+    assert raw_item[\"output\"][0][\"stdout\"] == \"012345\"\n+    assert raw_item[\"output\"][0][\"stderr\"] == \"\"\n+\n+\n+@pytest.mark.asyncio\n+async def test_shell_tool_uses_smaller_max_output_length() -> None:\n+    shell_tool = ShellTool(\n+        executor=lambda request: ShellResult(\n+            output=[\n+                ShellCommandOutput(\n+                    stdout=\"0123456789\",\n+                    stderr=\"abcdef\",\n+                    outcome=ShellCallOutcome(type=\"exit\", exit_code=0),\n+                )\n+            ],\n+            max_output_length=8,\n+        )\n+    )\n+\n+    tool_call = {\n+        \"type\": \"shell_call\",\n+        \"id\": \"shell_call\",\n+        \"call_id\": \"call_shell\",\n+        \"status\": \"completed\",\n+        \"action\": {\n+            \"commands\": [\"echo hi\"],\n+            \"timeout_ms\": 1000,\n+            \"max_output_length\": 6,\n+        },\n+    }\n+\n+    tool_run = ToolRunShellCall(tool_call=tool_call, shell_tool=shell_tool)\n+    agent = Agent(name=\"shell-agent\", tools=[shell_tool])\n+    context_wrapper: RunContextWrapper[Any] = RunContextWrapper(context=None)\n+\n+    result = await ShellAction.execute(\n+        agent=agent,\n+        call=tool_run,\n+        hooks=RunHooks[Any](),\n+        context_wrapper=context_wrapper,\n+        config=RunConfig(),\n+    )\n+\n+    assert isinstance(result, ToolCallOutputItem)\n+    assert result.output == \"012345\"\n+    raw_item = cast(dict[str, Any], result.raw_item)\n+    assert raw_item[\"max_output_length\"] == 6\n+    assert raw_item[\"output\"][0][\"stdout\"] == \"012345\"\n+    assert raw_item[\"output\"][0][\"stderr\"] == \"\"\n+\n+\n+@pytest.mark.asyncio\n+async def test_shell_tool_executor_can_override_max_output_length_to_zero() -> None:\n+    shell_tool = ShellTool(\n+        executor=lambda request: ShellResult(\n+            output=[\n+                ShellCommandOutput(\n+                    stdout=\"0123456789\",\n+                    stderr=\"abcdef\",\n+                    outcome=ShellCallOutcome(type=\"exit\", exit_code=0),\n+                )\n+            ],\n+            max_output_length=0,\n+        )\n+    )\n+\n+    tool_call = {\n+        \"type\": \"shell_call\",\n+        \"id\": \"shell_call\",\n+        \"call_id\": \"call_shell\",\n+        \"status\": \"completed\",\n+        \"action\": {\n+            \"commands\": [\"echo hi\"],\n+            \"timeout_ms\": 1000,\n+            \"max_output_length\": 6,\n+        },\n+    }\n+\n+    tool_run = ToolRunShellCall(tool_call=tool_call, shell_tool=shell_tool)\n+    agent = Agent(name=\"shell-agent\", tools=[shell_tool])\n+    context_wrapper: RunContextWrapper[Any] = RunContextWrapper(context=None)\n+\n+    result = await ShellAction.execute(\n+        agent=agent,\n+        call=tool_run,\n+        hooks=RunHooks[Any](),\n+        context_wrapper=context_wrapper,\n+        config=RunConfig(),\n+    )\n+\n+    assert isinstance(result, ToolCallOutputItem)\n+    assert result.output == \"\"\n+    raw_item = cast(dict[str, Any], result.raw_item)\n+    assert raw_item[\"max_output_length\"] == 0\n+    assert raw_item[\"output\"][0][\"stdout\"] == \"\"\n+    assert raw_item[\"output\"][0][\"stderr\"] == \"\"\n+\n+\n+@pytest.mark.asyncio\n+async def test_shell_tool_action_can_request_zero_max_output_length() -> None:\n+    shell_tool = ShellTool(\n+        executor=lambda request: ShellResult(\n+            output=[\n+                ShellCommandOutput(\n+                    stdout=\"0123456789\",\n+                    stderr=\"abcdef\",\n+                    outcome=ShellCallOutcome(type=\"exit\", exit_code=0),\n+                )\n+            ],\n+        )\n+    )\n+\n+    tool_call = {\n+        \"type\": \"shell_call\",\n+        \"id\": \"shell_call\",\n+        \"call_id\": \"call_shell\",\n+        \"status\": \"completed\",\n+        \"action\": {\n+            \"commands\": [\"echo hi\"],\n+            \"timeout_ms\": 1000,\n+            \"max_output_length\": 0,\n+        },\n+    }\n+\n+    tool_run = ToolRunShellCall(tool_call=tool_call, shell_tool=shell_tool)\n+    agent = Agent(name=\"shell-agent\", tools=[shell_tool])\n+    context_wrapper: RunContextWrapper[Any] = RunContextWrapper(context=None)\n+\n+    result = await ShellAction.execute(\n+        agent=agent,\n+        call=tool_run,\n+        hooks=RunHooks[Any](),\n+        context_wrapper=context_wrapper,\n+        config=RunConfig(),\n+    )\n+\n+    assert isinstance(result, ToolCallOutputItem)\n+    assert result.output == \"\"\n+    raw_item = cast(dict[str, Any], result.raw_item)\n+    assert raw_item[\"max_output_length\"] == 0\n+    assert raw_item[\"output\"][0][\"stdout\"] == \"\"\n+    assert raw_item[\"output\"][0][\"stderr\"] == \"\"\n+\n+\n+@pytest.mark.asyncio\n+async def test_shell_tool_action_negative_max_output_length_clamps_to_zero() -> None:\n+    shell_tool = ShellTool(\n+        executor=lambda request: ShellResult(\n+            output=[\n+                ShellCommandOutput(\n+                    stdout=\"0123456789\",\n+                    stderr=\"abcdef\",\n+                    outcome=ShellCallOutcome(type=\"exit\", exit_code=0),\n+                )\n+            ],\n+        )\n+    )\n+\n+    tool_call = {\n+        \"type\": \"shell_call\",\n+        \"id\": \"shell_call\",\n+        \"call_id\": \"call_shell\",\n+        \"status\": \"completed\",\n+        \"action\": {\n+            \"commands\": [\"echo hi\"],\n+            \"timeout_ms\": 1000,\n+            \"max_output_length\": -5,\n+        },\n+    }\n+\n+    tool_run = ToolRunShellCall(tool_call=tool_call, shell_tool=shell_tool)\n+    agent = Agent(name=\"shell-agent\", tools=[shell_tool])\n+    context_wrapper: RunContextWrapper[Any] = RunContextWrapper(context=None)\n+\n+    result = await ShellAction.execute(\n+        agent=agent,\n+        call=tool_run,\n+        hooks=RunHooks[Any](),\n+        context_wrapper=context_wrapper,\n+        config=RunConfig(),\n+    )\n+\n+    assert isinstance(result, ToolCallOutputItem)\n+    assert result.output == \"\"\n+    raw_item = cast(dict[str, Any], result.raw_item)\n+    assert raw_item[\"max_output_length\"] == 0\n+    assert raw_item[\"output\"][0][\"stdout\"] == \"\"\n+    assert raw_item[\"output\"][0][\"stderr\"] == \"\"",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/ed7ec6209d1572e124a3d3ec04473de19253bd1e/tests%2Ftest_shell_tool.py",
        "sha": "349dab348dede2abb7b47ac2fb92264f9f009e78",
        "status": "modified"
      }
    ],
    "status": 200
  },
  "started_at": "2026-01-20T04:56:26.955540Z"
}
