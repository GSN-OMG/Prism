{
  "finished_at": "2026-01-20T04:55:12.443782Z",
  "meta": {
    "attempt": 1,
    "request_fingerprint": "f349b6ef132a264f",
    "tag": "rest_pr_files_pr2275_page1"
  },
  "request": {
    "body": null,
    "headers": {
      "Accept": "application/vnd.github+json",
      "X-GitHub-Api-Version": "2022-11-28"
    },
    "method": "GET",
    "url": "https://api.github.com/repos/openai/openai-agents-python/pulls/2275/files?per_page=100&page=1"
  },
  "response": {
    "headers": {
      "access-control-allow-origin": "*",
      "access-control-expose-headers": "ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Resource, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, X-GitHub-SSO, X-GitHub-Request-Id, Deprecation, Sunset",
      "cache-control": "private, max-age=60, s-maxage=60",
      "content-length": "19246",
      "content-security-policy": "default-src 'none'",
      "content-type": "application/json; charset=utf-8",
      "date": "Tue, 20 Jan 2026 04:55:12 GMT",
      "etag": "\"1a9f258fbe472d84bf79617011f1a44ca645aaf90f3522f8776c7dc1f6eb5cfb\"",
      "github-authentication-token-expiration": "2026-02-19 04:41:20 UTC",
      "last-modified": "Thu, 08 Jan 2026 09:27:17 GMT",
      "referrer-policy": "origin-when-cross-origin, strict-origin-when-cross-origin",
      "server": "github.com",
      "strict-transport-security": "max-age=31536000; includeSubdomains; preload",
      "vary": "Accept, Authorization, Cookie, X-GitHub-OTP,Accept-Encoding, Accept, X-Requested-With",
      "x-accepted-oauth-scopes": "",
      "x-content-type-options": "nosniff",
      "x-frame-options": "deny",
      "x-github-api-version-selected": "2022-11-28",
      "x-github-media-type": "github.v3; format=json",
      "x-github-request-id": "DB74:221B33:153F057:1E4908C:696F0AAF",
      "x-oauth-scopes": "repo",
      "x-ratelimit-limit": "5000",
      "x-ratelimit-remaining": "4973",
      "x-ratelimit-reset": "1768885989",
      "x-ratelimit-resource": "core",
      "x-ratelimit-used": "27",
      "x-xss-protection": "0"
    },
    "json": [
      {
        "additions": 6,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/938ce2759140d8bccb1b1d373c6e291c58b65253/src%2Fagents%2F__init__.py",
        "changes": 6,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/src%2Fagents%2F__init__.py?ref=938ce2759140d8bccb1b1d373c6e291c58b65253",
        "deletions": 0,
        "filename": "src/agents/__init__.py",
        "patch": "@@ -24,6 +24,9 @@\n     ModelBehaviorError,\n     OutputGuardrailTripwireTriggered,\n     RunErrorDetails,\n+    SessionError,\n+    SessionNotFoundError,\n+    SessionSerializationError,\n     ToolInputGuardrailTripwireTriggered,\n     ToolOutputGuardrailTripwireTriggered,\n     UserError,\n@@ -255,6 +258,9 @@ def enable_verbose_stdout_logging():\n     \"MaxTurnsExceeded\",\n     \"ModelBehaviorError\",\n     \"UserError\",\n+    \"SessionError\",\n+    \"SessionNotFoundError\",\n+    \"SessionSerializationError\",\n     \"InputGuardrail\",\n     \"InputGuardrailResult\",\n     \"OutputGuardrail\",",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/938ce2759140d8bccb1b1d373c6e291c58b65253/src%2Fagents%2F__init__.py",
        "sha": "316ab554d8ff4394410f4fb2a130c6ba25d3da3f",
        "status": "modified"
      },
      {
        "additions": 42,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/938ce2759140d8bccb1b1d373c6e291c58b65253/src%2Fagents%2Fexceptions.py",
        "changes": 42,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/src%2Fagents%2Fexceptions.py?ref=938ce2759140d8bccb1b1d373c6e291c58b65253",
        "deletions": 0,
        "filename": "src/agents/exceptions.py",
        "patch": "@@ -129,3 +129,45 @@ def __init__(self, guardrail: ToolOutputGuardrail[Any], output: ToolGuardrailFun\n         self.guardrail = guardrail\n         self.output = output\n         super().__init__(f\"Tool output guardrail {guardrail.__class__.__name__} triggered tripwire\")\n+\n+\n+class SessionError(AgentsException):\n+    \"\"\"Exception raised when a session operation fails.\n+\n+    This is the base class for all session-related exceptions, providing\n+    consistent error handling for session storage, retrieval, and manipulation.\n+    \"\"\"\n+\n+    session_id: str | None\n+    \"\"\"The ID of the session that caused the error, if available.\"\"\"\n+\n+    def __init__(self, message: str, session_id: str | None = None):\n+        self.session_id = session_id\n+        self.message = message\n+        if session_id:\n+            super().__init__(f\"Session '{session_id}': {message}\")\n+        else:\n+            super().__init__(message)\n+\n+\n+class SessionNotFoundError(SessionError):\n+    \"\"\"Exception raised when a session cannot be found.\n+\n+    This exception is raised when attempting to retrieve or manipulate\n+    a session that does not exist in the storage backend.\n+    \"\"\"\n+\n+    def __init__(self, session_id: str):\n+        super().__init__(f\"Session not found\", session_id=session_id)\n+\n+\n+class SessionSerializationError(SessionError):\n+    \"\"\"Exception raised when session data cannot be serialized or deserialized.\n+\n+    This exception is raised when session items contain data that cannot\n+    be properly converted to/from the storage format.\n+    \"\"\"\n+\n+    def __init__(self, message: str, session_id: str | None = None):\n+        super().__init__(f\"Serialization error: {message}\", session_id=session_id)\n+",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/938ce2759140d8bccb1b1d373c6e291c58b65253/src%2Fagents%2Fexceptions.py",
        "sha": "1ef0f25ae9897e3ae601876678f35f0d8e274ec7",
        "status": "modified"
      },
      {
        "additions": 57,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/938ce2759140d8bccb1b1d373c6e291c58b65253/tests%2Ftest_session_exceptions.py",
        "changes": 352,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/tests%2Ftest_session_exceptions.py?ref=938ce2759140d8bccb1b1d373c6e291c58b65253",
        "deletions": 295,
        "filename": "tests/test_session_exceptions.py",
        "patch": "@@ -1,302 +1,64 @@\n-from __future__ import annotations\n-\n-import asyncio\n-import json\n-from typing import Any\n-from unittest.mock import AsyncMock, Mock\n+\"\"\"Tests for session exception classes.\"\"\"\n \n-import pytest\n-import websockets.exceptions\n+from __future__ import annotations\n \n-from agents.realtime.events import RealtimeError\n-from agents.realtime.model import RealtimeModel, RealtimeModelConfig, RealtimeModelListener\n-from agents.realtime.model_events import (\n-    RealtimeModelErrorEvent,\n-    RealtimeModelEvent,\n-    RealtimeModelExceptionEvent,\n+from agents.exceptions import (\n+    AgentsException,\n+    SessionError,\n+    SessionNotFoundError,\n+    SessionSerializationError,\n )\n-from agents.realtime.session import RealtimeSession\n-\n-\n-class FakeRealtimeModel(RealtimeModel):\n-    \"\"\"Fake model for testing that forwards events to listeners.\"\"\"\n-\n-    def __init__(self):\n-        self._listeners: list[RealtimeModelListener] = []\n-        self._events_to_send: list[RealtimeModelEvent] = []\n-        self._is_connected = False\n-        self._send_task: asyncio.Task[None] | None = None\n-\n-    def set_next_events(self, events: list[RealtimeModelEvent]) -> None:\n-        \"\"\"Set events to be sent to listeners.\"\"\"\n-        self._events_to_send = events.copy()\n-\n-    async def connect(self, options: RealtimeModelConfig) -> None:\n-        \"\"\"Fake connection that starts sending events.\"\"\"\n-        self._is_connected = True\n-        self._send_task = asyncio.create_task(self._send_events())\n-\n-    async def _send_events(self) -> None:\n-        \"\"\"Send queued events to all listeners.\"\"\"\n-        for event in self._events_to_send:\n-            await asyncio.sleep(0.001)  # Small delay to simulate async behavior\n-            for listener in self._listeners:\n-                await listener.on_event(event)\n-\n-    def add_listener(self, listener: RealtimeModelListener) -> None:\n-        \"\"\"Add a listener.\"\"\"\n-        self._listeners.append(listener)\n-\n-    def remove_listener(self, listener: RealtimeModelListener) -> None:\n-        \"\"\"Remove a listener.\"\"\"\n-        if listener in self._listeners:\n-            self._listeners.remove(listener)\n-\n-    async def close(self) -> None:\n-        \"\"\"Close the fake model.\"\"\"\n-        self._is_connected = False\n-        if self._send_task and not self._send_task.done():\n-            self._send_task.cancel()\n-            try:\n-                await self._send_task\n-            except asyncio.CancelledError:\n-                pass\n-\n-    async def send_message(\n-        self, message: Any, other_event_data: dict[str, Any] | None = None\n-    ) -> None:\n-        \"\"\"Fake send message.\"\"\"\n-        pass\n-\n-    async def send_audio(self, audio: bytes, *, commit: bool = False) -> None:\n-        \"\"\"Fake send audio.\"\"\"\n-        pass\n-\n-    async def send_event(self, event: Any) -> None:\n-        \"\"\"Fake send event.\"\"\"\n-        pass\n-\n-    async def send_tool_output(self, tool_call: Any, output: str, start_response: bool) -> None:\n-        \"\"\"Fake send tool output.\"\"\"\n-        pass\n-\n-    async def interrupt(self) -> None:\n-        \"\"\"Fake interrupt.\"\"\"\n-        pass\n-\n-\n-@pytest.fixture\n-def fake_agent():\n-    \"\"\"Create a fake agent for testing.\"\"\"\n-    agent = Mock()\n-    agent.get_all_tools = AsyncMock(return_value=[])\n-    agent.get_system_prompt = AsyncMock(return_value=\"test instructions\")\n-    agent.handoffs = []\n-    return agent\n-\n-\n-@pytest.fixture\n-def fake_model():\n-    \"\"\"Create a fake model for testing.\"\"\"\n-    return FakeRealtimeModel()\n \n \n class TestSessionExceptions:\n-    \"\"\"Test exception handling in RealtimeSession.\"\"\"\n-\n-    @pytest.mark.asyncio\n-    async def test_end_to_end_exception_propagation_and_cleanup(\n-        self, fake_model: FakeRealtimeModel, fake_agent\n-    ):\n-        \"\"\"Test that exceptions are stored, trigger cleanup, and are raised in __aiter__.\"\"\"\n-        # Create test exception\n-        test_exception = ValueError(\"Test error\")\n-        exception_event = RealtimeModelExceptionEvent(\n-            exception=test_exception, context=\"Test context\"\n-        )\n-\n-        # Set up session\n-        session = RealtimeSession(fake_model, fake_agent, None)\n-\n-        # Set events to send\n-        fake_model.set_next_events([exception_event])\n-\n-        # Start session\n-        async with session:\n-            # Try to iterate and expect exception\n-            with pytest.raises(ValueError, match=\"Test error\"):\n-                async for _ in session:\n-                    pass  # Should never reach here\n-\n-        # Verify cleanup occurred\n-        assert session._closed is True\n-        assert session._stored_exception == test_exception\n-        assert fake_model._is_connected is False\n-        assert len(fake_model._listeners) == 0\n-\n-    @pytest.mark.asyncio\n-    async def test_websocket_connection_closure_type_distinction(\n-        self, fake_model: FakeRealtimeModel, fake_agent\n-    ):\n-        \"\"\"Test different WebSocket closure types generate appropriate events.\"\"\"\n-        # Test ConnectionClosed (should create exception event)\n-        error_closure = websockets.exceptions.ConnectionClosed(None, None)\n-        error_event = RealtimeModelExceptionEvent(\n-            exception=error_closure, context=\"WebSocket connection closed unexpectedly\"\n-        )\n-\n-        session = RealtimeSession(fake_model, fake_agent, None)\n-        fake_model.set_next_events([error_event])\n-\n-        with pytest.raises(websockets.exceptions.ConnectionClosed):\n-            async with session:\n-                async for _event in session:\n-                    pass\n-\n-        # Verify error closure triggered cleanup\n-        assert session._closed is True\n-        assert isinstance(session._stored_exception, websockets.exceptions.ConnectionClosed)\n-\n-    @pytest.mark.asyncio\n-    async def test_json_parsing_error_handling(self, fake_model: FakeRealtimeModel, fake_agent):\n-        \"\"\"Test JSON parsing errors are properly handled and contextualized.\"\"\"\n-        # Create JSON decode error\n-        json_error = json.JSONDecodeError(\"Invalid JSON\", \"bad json\", 0)\n-        json_exception_event = RealtimeModelExceptionEvent(\n-            exception=json_error, context=\"Failed to parse WebSocket message as JSON\"\n-        )\n-\n-        session = RealtimeSession(fake_model, fake_agent, None)\n-        fake_model.set_next_events([json_exception_event])\n-\n-        with pytest.raises(json.JSONDecodeError):\n-            async with session:\n-                async for _event in session:\n-                    pass\n-\n-        # Verify context is preserved\n-        assert session._stored_exception == json_error\n-        assert session._closed is True\n-\n-    @pytest.mark.asyncio\n-    async def test_exception_context_preservation(self, fake_model: FakeRealtimeModel, fake_agent):\n-        \"\"\"Test that exception context information is preserved through the handling process.\"\"\"\n-        test_contexts = [\n-            (\"Failed to send audio\", RuntimeError(\"Audio encoding failed\")),\n-            (\"WebSocket error in message listener\", ConnectionError(\"Network error\")),\n-            (\"Failed to send event: response.create\", OSError(\"Socket closed\")),\n+    \"\"\"Tests for session exception classes.\"\"\"\n+\n+    def test_session_error_base_class(self) -> None:\n+        \"\"\"SessionError should be a subclass of AgentsException.\"\"\"\n+        assert issubclass(SessionError, AgentsException)\n+\n+    def test_session_error_with_session_id(self) -> None:\n+        \"\"\"SessionError should include session_id in message when provided.\"\"\"\n+        error = SessionError(\"Database connection failed\", session_id=\"sess_123\")\n+        assert error.session_id == \"sess_123\"\n+        assert \"sess_123\" in str(error)\n+        assert \"Database connection failed\" in str(error)\n+\n+    def test_session_error_without_session_id(self) -> None:\n+        \"\"\"SessionError should work without session_id.\"\"\"\n+        error = SessionError(\"General session failure\")\n+        assert error.session_id is None\n+        assert \"General session failure\" in str(error)\n+\n+    def test_session_not_found_error(self) -> None:\n+        \"\"\"SessionNotFoundError should be a subclass of SessionError.\"\"\"\n+        assert issubclass(SessionNotFoundError, SessionError)\n+        error = SessionNotFoundError(\"sess_missing\")\n+        assert error.session_id == \"sess_missing\"\n+        assert \"sess_missing\" in str(error)\n+        assert \"not found\" in str(error).lower()\n+\n+    def test_session_serialization_error(self) -> None:\n+        \"\"\"SessionSerializationError should be a subclass of SessionError.\"\"\"\n+        assert issubclass(SessionSerializationError, SessionError)\n+        error = SessionSerializationError(\"Invalid JSON\", session_id=\"sess_456\")\n+        assert error.session_id == \"sess_456\"\n+        assert \"Invalid JSON\" in str(error)\n+        assert \"Serialization\" in str(error)\n+\n+    def test_session_serialization_error_without_session_id(self) -> None:\n+        \"\"\"SessionSerializationError should work without session_id.\"\"\"\n+        error = SessionSerializationError(\"Circular reference detected\")\n+        assert error.session_id is None\n+        assert \"Circular reference detected\" in str(error)\n+\n+    def test_exceptions_have_run_data_attribute(self) -> None:\n+        \"\"\"All session exceptions should have run_data attribute from AgentsException.\"\"\"\n+        errors = [\n+            SessionError(\"test\"),\n+            SessionNotFoundError(\"sess_test\"),\n+            SessionSerializationError(\"test\"),\n         ]\n-\n-        for context, exception in test_contexts:\n-            exception_event = RealtimeModelExceptionEvent(exception=exception, context=context)\n-\n-            session = RealtimeSession(fake_model, fake_agent, None)\n-            fake_model.set_next_events([exception_event])\n-\n-            with pytest.raises(type(exception)):\n-                async with session:\n-                    async for _event in session:\n-                        pass\n-\n-            # Verify the exact exception is stored\n-            assert session._stored_exception == exception\n-            assert session._closed is True\n-\n-            # Reset for next iteration\n-            fake_model._is_connected = False\n-            fake_model._listeners.clear()\n-\n-    @pytest.mark.asyncio\n-    async def test_multiple_exception_handling_behavior(\n-        self, fake_model: FakeRealtimeModel, fake_agent\n-    ):\n-        \"\"\"Test behavior when multiple exceptions occur before consumption.\"\"\"\n-        # Create multiple exceptions\n-        first_exception = ValueError(\"First error\")\n-        second_exception = RuntimeError(\"Second error\")\n-\n-        first_event = RealtimeModelExceptionEvent(\n-            exception=first_exception, context=\"First context\"\n-        )\n-        second_event = RealtimeModelExceptionEvent(\n-            exception=second_exception, context=\"Second context\"\n-        )\n-\n-        session = RealtimeSession(fake_model, fake_agent, None)\n-        fake_model.set_next_events([first_event, second_event])\n-\n-        # Start session and let events process\n-        async with session:\n-            # Give time for events to be processed\n-            await asyncio.sleep(0.05)\n-\n-        # The first exception should be stored (second should overwrite, but that's\n-        # the current behavior). In practice, once an exception occurs, cleanup\n-        # should prevent further processing\n-        assert session._stored_exception is not None\n-        assert session._closed is True\n-\n-    @pytest.mark.asyncio\n-    async def test_exception_during_guardrail_processing(\n-        self, fake_model: FakeRealtimeModel, fake_agent\n-    ):\n-        \"\"\"Test that exceptions don't interfere with guardrail task cleanup.\"\"\"\n-        # Create exception event\n-        test_exception = RuntimeError(\"Processing error\")\n-        exception_event = RealtimeModelExceptionEvent(\n-            exception=test_exception, context=\"Processing failed\"\n-        )\n-\n-        session = RealtimeSession(fake_model, fake_agent, None)\n-\n-        # Add some fake guardrail tasks\n-        fake_task1 = Mock()\n-        fake_task1.done.return_value = False\n-        fake_task1.cancel = Mock()\n-\n-        fake_task2 = Mock()\n-        fake_task2.done.return_value = True\n-        fake_task2.cancel = Mock()\n-\n-        session._guardrail_tasks = {fake_task1, fake_task2}\n-\n-        fake_model.set_next_events([exception_event])\n-\n-        with pytest.raises(RuntimeError, match=\"Processing error\"):\n-            async with session:\n-                async for _event in session:\n-                    pass\n-\n-        # Verify guardrail tasks were properly cleaned up\n-        fake_task1.cancel.assert_called_once()\n-        fake_task2.cancel.assert_not_called()  # Already done\n-        assert len(session._guardrail_tasks) == 0\n-\n-    @pytest.mark.asyncio\n-    async def test_normal_events_still_work_before_exception(\n-        self, fake_model: FakeRealtimeModel, fake_agent\n-    ):\n-        \"\"\"Test that normal events are processed before an exception occurs.\"\"\"\n-        # Create normal event followed by exception\n-        normal_event = RealtimeModelErrorEvent(error={\"message\": \"Normal error\"})\n-        exception_event = RealtimeModelExceptionEvent(\n-            exception=ValueError(\"Fatal error\"), context=\"Fatal context\"\n-        )\n-\n-        session = RealtimeSession(fake_model, fake_agent, None)\n-        fake_model.set_next_events([normal_event, exception_event])\n-\n-        events_received = []\n-\n-        with pytest.raises(ValueError, match=\"Fatal error\"):\n-            async with session:\n-                async for event in session:\n-                    events_received.append(event)\n-\n-        # Should have received events before exception\n-        assert len(events_received) >= 1\n-        # Look for the error event (might not be first due to history_updated\n-        # being emitted initially)\n-        error_events = [e for e in events_received if hasattr(e, \"type\") and e.type == \"error\"]\n-        assert len(error_events) >= 1\n-        assert isinstance(error_events[0], RealtimeError)\n+        for error in errors:\n+            assert hasattr(error, \"run_data\")\n+            assert error.run_data is None",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/938ce2759140d8bccb1b1d373c6e291c58b65253/tests%2Ftest_session_exceptions.py",
        "sha": "276bef2c014d565e9060efcee28a8a9706dd4df1",
        "status": "modified"
      }
    ],
    "status": 200
  },
  "started_at": "2026-01-20T04:55:11.791318Z"
}
