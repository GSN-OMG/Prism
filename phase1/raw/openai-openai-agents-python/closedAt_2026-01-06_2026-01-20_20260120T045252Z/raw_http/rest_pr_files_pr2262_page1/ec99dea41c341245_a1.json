{
  "finished_at": "2026-01-20T04:54:40.462681Z",
  "meta": {
    "attempt": 1,
    "request_fingerprint": "ec99dea41c341245",
    "tag": "rest_pr_files_pr2262_page1"
  },
  "request": {
    "body": null,
    "headers": {
      "Accept": "application/vnd.github+json",
      "X-GitHub-Api-Version": "2022-11-28"
    },
    "method": "GET",
    "url": "https://api.github.com/repos/openai/openai-agents-python/pulls/2262/files?per_page=100&page=1"
  },
  "response": {
    "headers": {
      "access-control-allow-origin": "*",
      "access-control-expose-headers": "ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Resource, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, X-GitHub-SSO, X-GitHub-Request-Id, Deprecation, Sunset",
      "cache-control": "private, max-age=60, s-maxage=60",
      "content-length": "826403",
      "content-security-policy": "default-src 'none'",
      "content-type": "application/json; charset=utf-8",
      "date": "Tue, 20 Jan 2026 04:54:39 GMT",
      "etag": "\"534ecb4200c08a06a418ae50f996824b424e53461353b01b461c1340359adfba\"",
      "github-authentication-token-expiration": "2026-02-19 04:41:20 UTC",
      "last-modified": "Tue, 06 Jan 2026 03:06:54 GMT",
      "referrer-policy": "origin-when-cross-origin, strict-origin-when-cross-origin",
      "server": "github.com",
      "strict-transport-security": "max-age=31536000; includeSubdomains; preload",
      "vary": "Accept, Authorization, Cookie, X-GitHub-OTP,Accept-Encoding, Accept, X-Requested-With",
      "x-accepted-oauth-scopes": "",
      "x-content-type-options": "nosniff",
      "x-frame-options": "deny",
      "x-github-api-version-selected": "2022-11-28",
      "x-github-media-type": "github.v3; format=json",
      "x-github-request-id": "DB2A:3782ED:1628C45:1F336F5:696F0A8F",
      "x-oauth-scopes": "repo",
      "x-ratelimit-limit": "5000",
      "x-ratelimit-remaining": "4981",
      "x-ratelimit-reset": "1768885989",
      "x-ratelimit-resource": "core",
      "x-ratelimit-used": "19",
      "x-xss-protection": "0"
    },
    "json": [
      {
        "additions": 34,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Fagents.md",
        "changes": 68,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fja%2Fagents.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 34,
        "filename": "docs/ja/agents.md",
        "patch": "@@ -4,16 +4,16 @@ search:\n ---\n # エージェント\n \n-エージェントはアプリの中核となる基本コンポーネントです。エージェントは、instructions とツールで構成された大規模言語モデル ( LLM ) です。\n+エージェントはアプリの中核となる構成要素です。エージェントは、instructions とツールで構成された 大規模言語モデル ( LLM ) です。\n \n ## 基本設定\n \n エージェントで最も一般的に設定するプロパティは次のとおりです。\n \n--   `name`: エージェントを識別する必須の文字列です。\n--   `instructions`: 開発者メッセージまたは system prompt とも呼ばれます。\n--   `model`: 使用する LLM と、temperature、top_p などのモデル調整パラメーターを設定するための任意の `model_settings`。\n--   `tools`: エージェントがタスク達成のために使用できるツールです。\n+- `name`: エージェントを識別する必須の文字列です。\n+- `instructions`: developer message または system prompt とも呼ばれます。\n+- `model`: 使用する LLM と、temperature、top_p などのモデル調整パラメーターを設定するオプションの `model_settings`。\n+- `tools`: エージェントがタスクを達成するために使用できるツールです。\n \n ```python\n from agents import Agent, ModelSettings, function_tool\n@@ -33,7 +33,7 @@ agent = Agent(\n \n ## コンテキスト\n \n-エージェントは `context` 型に対してジェネリックです。コンテキストは依存性注入のためのツールで、あなたが作成して `Runner.run()` に渡すオブジェクトです。これはすべてのエージェント、ツール、ハンドオフなどに渡され、エージェントの実行における依存関係や状態をまとめて保持します。コンテキストには任意の Python オブジェクトを提供できます。\n+エージェントはその `context` 型に対してジェネリックです。コンテキストは依存性注入のためのツールで、あなたが作成して `Runner.run()` に渡すオブジェクトです。これはすべてのエージェント、ツール、ハンドオフなどに渡され、エージェント実行のための依存関係と状態の入れ物として機能します。コンテキストには任意の Python オブジェクトを提供できます。\n \n ```python\n @dataclass\n@@ -50,9 +50,9 @@ agent = Agent[UserContext](\n )\n ```\n \n-## 出力型\n+## 出力タイプ\n \n-デフォルトでは、エージェントはプレーンテキスト (すなわち `str`) を出力します。特定の型の出力を生成させたい場合は、`output_type` パラメーターを使用できます。一般的な選択肢は [Pydantic](https://docs.pydantic.dev/) オブジェクトの使用ですが、Pydantic の [TypeAdapter](https://docs.pydantic.dev/latest/api/type_adapter/) にラップできる任意の型 (dataclasses、lists、TypedDict など) をサポートします。\n+デフォルトでは、エージェントはプレーンテキスト (すなわち `str`) を出力します。特定の型の出力をエージェントに生成させたい場合は、`output_type` パラメーターを使用できます。一般的な選択肢は [Pydantic](https://docs.pydantic.dev/) オブジェクトですが、Pydantic の [TypeAdapter](https://docs.pydantic.dev/latest/api/type_adapter/) でラップできる任意の型をサポートします。例えば dataclasses、リスト、TypedDict などです。\n \n ```python\n from pydantic import BaseModel\n@@ -75,18 +75,18 @@ agent = Agent(\n \n     `output_type` を渡すと、モデルは通常のプレーンテキスト応答ではなく [structured outputs](https://platform.openai.com/docs/guides/structured-outputs) を使用するようになります。\n \n-## マルチエージェントの設計パターン\n+## マルチ エージェント システムの設計パターン\n \n-マルチエージェントシステムの設計には多くの方法がありますが、広く適用できるパターンとして次の 2 つがよく見られます。\n+マルチ エージェント システムの設計には多くの方法がありますが、一般的に幅広く適用できるパターンとして次の 2 つがあります。\n \n-1. マネージャー (エージェントをツールとして): 中央のマネージャー/オーケストレーターが、ツールとして公開された特化サブエージェントを呼び出し、会話の制御を保持します。\n-2. ハンドオフ: 対等なエージェント同士で制御を専門エージェントに引き渡し、そのエージェントが会話を引き継ぎます。これは分散型です。\n+1. マネージャー（ツールとしての エージェント）: 中央のマネージャー/オーケストレーターが、専門のサブ エージェントをツールとして呼び出し、会話の制御を保持します。\n+2. ハンドオフ: 対等なエージェント同士が、会話を引き継ぐ専門エージェントに制御をハンドオフします。これは分散型です。\n \n-詳細は [実践的なエージェント構築ガイド](https://cdn.openai.com/business-guides-and-resources/a-practical-guide-to-building-agents.pdf) を参照してください。\n+詳細は [エージェント構築の実践ガイド](https://cdn.openai.com/business-guides-and-resources/a-practical-guide-to-building-agents.pdf) をご覧ください。\n \n-### マネージャー (エージェントをツールとして)\n+### マネージャー（ツールとしての エージェント）\n \n-`customer_facing_agent` はすべてのユーザー対応を処理し、ツールとして公開された特化サブエージェントを呼び出します。詳細は [ツール](tools.md#agents-as-tools) のドキュメントをご覧ください。\n+`customer_facing_agent` がすべてのユーザー対応を行い、ツールとして公開された専門サブ エージェントを呼び出します。詳細は [tools](tools.md#agents-as-tools) ドキュメントをご覧ください。\n \n ```python\n from agents import Agent\n@@ -115,7 +115,7 @@ customer_facing_agent = Agent(\n \n ### ハンドオフ\n \n-ハンドオフは、エージェントが委譲できるサブエージェントです。ハンドオフが発生すると、委譲先のエージェントが会話履歴を受け取り、会話を引き継ぎます。このパターンにより、単一のタスクに秀でたモジュール式の専門エージェントが可能になります。詳細は [ハンドオフ](handoffs.md) のドキュメントをご覧ください。\n+ハンドオフは、エージェントが委任できるサブ エージェントです。ハンドオフが発生すると、委任先のエージェントが会話履歴を受け取り、会話を引き継ぎます。このパターンにより、単一のタスクに優れたモジュール型・専門特化のエージェントが可能になります。詳細は [handoffs](handoffs.md) ドキュメントをご覧ください。\n \n ```python\n from agents import Agent\n@@ -134,9 +134,9 @@ triage_agent = Agent(\n )\n ```\n \n-## 動的 instructions\n+## 動的インストラクション\n \n-多くの場合、エージェントを作成する際に instructions を指定できますが、関数を介して動的な instructions を提供することもできます。関数はエージェントとコンテキストを受け取り、プロンプトを返す必要があります。通常の関数と `async` 関数のどちらも使用できます。\n+多くの場合、エージェント作成時に instructions を指定できますが、関数を通じて動的なインストラクションを提供することもできます。関数はエージェントとコンテキストを受け取り、プロンプトを返す必要があります。通常の関数と `async` 関数の両方が使用できます。\n \n ```python\n def dynamic_instructions(\n@@ -151,15 +151,15 @@ agent = Agent[UserContext](\n )\n ```\n \n-## ライフサイクルイベント (フック)\n+## ライフサイクルイベント（フック）\n \n-エージェントのライフサイクルを観察したい場合があります。たとえば、イベントをログに記録したり、特定のイベントが発生したときにデータを事前取得したりできます。`hooks` プロパティでエージェントのライフサイクルにフックできます。[`AgentHooks`][agents.lifecycle.AgentHooks] クラスをサブクラス化し、関心のあるメソッドをオーバーライドしてください。\n+エージェントのライフサイクルを観察したい場合があります。たとえば、イベントをログに記録したり、特定のイベント発生時にデータを事前取得したりする場合です。`hooks` プロパティを使ってエージェントのライフサイクルにフックできます。[`AgentHooks`][agents.lifecycle.AgentHooks] クラスをサブクラス化し、関心のあるメソッドをオーバーライドします。\n \n ## ガードレール\n \n-ガードレールにより、エージェントの実行と並行してユーザー入力に対するチェック/バリデーションを実行し、エージェントの出力が生成された後にも実行できます。たとえば、ユーザー入力とエージェント出力の関連性をスクリーニングできます。詳細は [ガードレール](guardrails.md) のドキュメントをご覧ください。\n+ガードレールにより、エージェントの実行と並行して ユーザー入力に対するチェック/バリデーションを実行し、エージェントの出力が生成された後にもチェックできます。たとえば、ユーザーの入力やエージェントの出力を関連性でスクリーニングできます。詳細は [guardrails](guardrails.md) ドキュメントをご覧ください。\n \n-## エージェントの複製/コピー\n+## エージェントのクローン/コピー\n \n エージェントの `clone()` メソッドを使用すると、エージェントを複製し、必要に応じて任意のプロパティを変更できます。\n \n@@ -178,12 +178,12 @@ robot_agent = pirate_agent.clone(\n \n ## ツール使用の強制\n \n-ツールのリストを指定しても、LLM が必ずしもツールを使用するとは限りません。[`ModelSettings.tool_choice`][agents.model_settings.ModelSettings.tool_choice] を設定することでツール使用を強制できます。有効な値は次のとおりです。\n+ツールのリストを指定しても、LLM が必ずしもツールを使用するとは限りません。[`ModelSettings.tool_choice`][agents.model_settings.ModelSettings.tool_choice] を設定してツール使用を強制できます。有効な値は次のとおりです。\n \n-1. `auto`: ツールを使用するかどうかを LLM に委ねます。\n-2. `required`: LLM にツールの使用を要求します (ただし、どのツールを使うかは賢く判断します)。\n-3. `none`: LLM にツールを使用しないことを要求します。\n-4. 特定の文字列 (例: `my_tool`) を設定すると、その特定のツールを LLM に使用させます。\n+1. `auto`: LLM がツールを使用するかどうかを判断します。\n+2. `required`: LLM にツールの使用を必須にします（どのツールを使うかは賢く判断できます）。\n+3. `none`: LLM にツールを使用しないことを必須にします。\n+4. 特定の文字列（例: `my_tool`）を設定すると、LLM にその特定のツールの使用を必須にします。\n \n ```python\n from agents import Agent, Runner, function_tool, ModelSettings\n@@ -201,12 +201,12 @@ agent = Agent(\n )\n ```\n \n-## ツール使用時の動作\n+## ツール使用の挙動\n \n-`Agent` の設定にある `tool_use_behavior` パラメーターは、ツール出力の扱い方を制御します。\n+`Agent` 構成の `tool_use_behavior` パラメーターは、ツール出力の扱い方を制御します。\n \n-- `\"run_llm_again\"`: デフォルト。ツールを実行し、LLM が結果を処理して最終応答を生成します。\n-- `\"stop_on_first_tool\"`: 最初のツール呼び出しの出力を、その後の LLM 処理なしで最終応答として使用します。\n+- `\"run_llm_again\"`: デフォルト。ツールを実行し、その結果を LLM が処理して最終応答を生成します。\n+- `\"stop_on_first_tool\"`: 最初のツール呼び出しの出力を、追加の LLM 処理なしで最終応答として使用します。\n \n ```python\n from agents import Agent, Runner, function_tool, ModelSettings\n@@ -224,7 +224,7 @@ agent = Agent(\n )\n ```\n \n-- `StopAtTools(stop_at_tool_names=[...])`: 指定したいずれかのツールが呼び出された場合に停止し、その出力を最終応答として使用します。\n+- `StopAtTools(stop_at_tool_names=[...])`: 指定したいずれかのツールが呼び出された時点で停止し、その出力を最終応答として使用します。\n \n ```python\n from agents import Agent, Runner, function_tool\n@@ -248,7 +248,7 @@ agent = Agent(\n )\n ```\n \n-- `ToolsToFinalOutputFunction`: ツール結果を処理し、停止するか LLM を継続するかを判断するカスタム関数です。\n+- `ToolsToFinalOutputFunction`: ツール結果を処理し、停止するか LLM を続行するかを決定するカスタム関数です。\n \n ```python\n from agents import Agent, Runner, function_tool, FunctionToolResult, RunContextWrapper\n@@ -286,4 +286,4 @@ agent = Agent(\n \n !!! note\n \n-    無限ループを防ぐため、フレームワークはツール呼び出し後に `tool_choice` を自動的に \"auto\" にリセットします。この動作は [`agent.reset_tool_choice`][agents.agent.Agent.reset_tool_choice] で設定できます。無限ループは、ツール結果が LLM に送られ、その `tool_choice` により LLM がさらに別のツール呼び出しを生成し続けるために発生します。\n\\ No newline at end of file\n+    無限ループを防ぐため、フレームワークはツール呼び出し後に `tool_choice` を自動的に \"auto\" にリセットします。この挙動は [`agent.reset_tool_choice`][agents.agent.Agent.reset_tool_choice] で構成可能です。無限ループが起きる理由は、ツール結果が LLM に送られ、`tool_choice` によって LLM がさらに別のツール呼び出しを生成し続けるためです。\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Fagents.md",
        "sha": "bcdc1d7ad91980bf0f9360d29278479b6efaf1e0",
        "status": "modified"
      },
      {
        "additions": 22,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Fconfig.md",
        "changes": 32,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fja%2Fconfig.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 10,
        "filename": "docs/ja/config.md",
        "patch": "@@ -6,15 +6,15 @@ search:\n \n ## API キーとクライアント\n \n-デフォルトでは、この SDK はインポートされるとすぐに、 LLM リクエストとトレーシングのために `OPENAI_API_KEY` 環境変数を探します。アプリ起動前にその環境変数を設定できない場合は、[set_default_openai_key()][agents.set_default_openai_key] 関数でキーを設定できます。\n+既定では、SDK はインポートされた直後から LLM リクエストと トレーシング のために `OPENAI_API_KEY` 環境変数を探します。アプリ起動前にその環境変数を設定できない場合は、[set_default_openai_key()][agents.set_default_openai_key] 関数でキーを設定できます。\n \n ```python\n from agents import set_default_openai_key\n \n set_default_openai_key(\"sk-...\")\n ```\n \n-また、使用する OpenAI クライアントを設定することもできます。デフォルトでは、この SDK は環境変数または上で設定したデフォルトキーから API キーを取得して `AsyncOpenAI` インスタンスを作成します。これを変更するには、[set_default_openai_client()][agents.set_default_openai_client] 関数を使用します。\n+また、使用する OpenAI クライアントを設定することもできます。既定では、SDK は環境変数または上で設定した既定キーを用いて `AsyncOpenAI` インスタンスを作成します。これを変更するには、[set_default_openai_client()][agents.set_default_openai_client] 関数を使用します。\n \n ```python\n from openai import AsyncOpenAI\n@@ -24,7 +24,7 @@ custom_client = AsyncOpenAI(base_url=\"...\", api_key=\"...\")\n set_default_openai_client(custom_client)\n ```\n \n-最後に、使用する OpenAI API をカスタマイズすることもできます。デフォルトでは OpenAI Responses API を使用します。これを上書きして Chat Completions API を使用するには、[set_default_openai_api()][agents.set_default_openai_api] 関数を使用します。\n+最後に、使用する OpenAI API をカスタマイズすることもできます。既定では OpenAI Responses API を使用します。これを上書きして Chat Completions API を使うには、[set_default_openai_api()][agents.set_default_openai_api] 関数を使用します。\n \n ```python\n from agents import set_default_openai_api\n@@ -34,15 +34,27 @@ set_default_openai_api(\"chat_completions\")\n \n ## トレーシング\n \n-トレーシングはデフォルトで有効です。デフォルトでは、上記の OpenAI API キー（つまり環境変数または設定したデフォルトキー）を使用します。トレーシングに使用する API キーを個別に設定するには、[`set_tracing_export_api_key`][agents.set_tracing_export_api_key] 関数を使用します。\n+トレーシング は既定で有効です。既定では上記の OpenAI API キー（すなわち環境変数または設定した既定キー）を使用します。トレーシング に使用する API キーを個別に設定するには、[`set_tracing_export_api_key`][agents.set_tracing_export_api_key] 関数を使用します。\n \n ```python\n from agents import set_tracing_export_api_key\n \n set_tracing_export_api_key(\"sk-...\")\n ```\n \n-[`set_tracing_disabled()`][agents.set_tracing_disabled] 関数を使用して、トレーシングを完全に無効化することもできます。\n+グローバルなエクスポーターを変更せずに、実行ごとに トレーシング 用 API キーを設定することもできます。\n+\n+```python\n+from agents import Runner, RunConfig\n+\n+await Runner.run(\n+    agent,\n+    input=\"Hello\",\n+    run_config=RunConfig(tracing={\"api_key\": \"sk-tracing-123\"}),\n+)\n+```\n+\n+[`set_tracing_disabled()`][agents.set_tracing_disabled] 関数を使用して、トレーシング を完全に無効化することもできます。\n \n ```python\n from agents import set_tracing_disabled\n@@ -52,7 +64,7 @@ set_tracing_disabled(True)\n \n ## デバッグログ\n \n-この SDK には、ハンドラーが設定されていない 2 つの Python ロガーがあります。デフォルトでは、これは警告とエラーが `stdout` に送られ、それ以外のログは抑制されることを意味します。\n+SDK には、ハンドラーが設定されていない 2 つの Python ロガーがあります。既定では、警告とエラーは `stdout` に送られ、それ以外のログは抑制されます。\n \n 詳細なログを有効にするには、[`enable_verbose_stdout_logging()`][agents.enable_verbose_stdout_logging] 関数を使用します。\n \n@@ -81,17 +93,17 @@ logger.setLevel(logging.WARNING)\n logger.addHandler(logging.StreamHandler())\n ```\n \n-### ログ中の機微情報\n+### ログ内の機密データ\n \n-一部のログには機微情報（例: ユーザー データ）が含まれる場合があります。これらのデータをログ出力しないようにするには、以下の環境変数を設定します。\n+一部のログには機密データ（例: ユーザー データ）が含まれる場合があります。これらのデータがログに出力されないようにするには、以下の環境変数を設定します。\n \n-LLM の入力と出力のログを無効化するには:\n+LLM の入力と出力のログ出力を無効化するには:\n \n ```bash\n export OPENAI_AGENTS_DONT_LOG_MODEL_DATA=1\n ```\n \n-ツールの入力と出力のログを無効化するには:\n+ツールの入力と出力のログ出力を無効化するには:\n \n ```bash\n export OPENAI_AGENTS_DONT_LOG_TOOL_DATA=1",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Fconfig.md",
        "sha": "1cd364a55885c8cf66704b93cd3acc9dbe5d9a20",
        "status": "modified"
      },
      {
        "additions": 28,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Fcontext.md",
        "changes": 56,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fja%2Fcontext.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 28,
        "filename": "docs/ja/context.md",
        "patch": "@@ -4,30 +4,30 @@ search:\n ---\n # コンテキスト管理\n \n-コンテキストは多義的な用語です。重要になるコンテキストには主に 2 つの種類があります。\n+コンテキストという語は多義的です。気にすべきコンテキストには主に 2 つの種類があります。\n \n-1. コードからローカルに利用可能なコンテキスト: これは、ツール関数の実行時、`on_handoff` のようなコールバック、ライフサイクルフックなどで必要になる可能性のあるデータや依存関係です。\n-2. LLM に利用可能なコンテキスト: これは、応答を生成する際に LLM が参照できるデータです。\n+1. コードからローカルに利用できるコンテキスト: これは、ツール関数の実行時、`on_handoff` のようなコールバック、ライフサイクルフックなどで必要となるデータや依存関係です。\n+2. LLM に提供されるコンテキスト: これは、LLM が応答を生成する際に目にできるデータです。\n \n ## ローカルコンテキスト\n \n これは [`RunContextWrapper`][agents.run_context.RunContextWrapper] クラスと、その中の [`context`][agents.run_context.RunContextWrapper.context] プロパティによって表現されます。仕組みは次のとおりです。\n \n 1. 任意の Python オブジェクトを作成します。一般的なパターンとしては、dataclass や Pydantic オブジェクトを使います。\n-2. そのオブジェクトを各種の実行メソッドに渡します（例: `Runner.run(..., **context=whatever**)`）。\n-3. すべてのツール呼び出し、ライフサイクルフックなどに、`RunContextWrapper[T]` というラッパーオブジェクトが渡されます。ここで `T` はコンテキストオブジェクトの型を表し、`wrapper.context` でアクセスできます。\n+2. そのオブジェクトを各種の実行メソッド（例: `Runner.run(..., **context=whatever**)`）に渡します。\n+3. すべてのツール呼び出しやライフサイクルフックなどには、`RunContextWrapper[T]` というラッパーオブジェクトが渡されます。ここで `T` はコンテキストオブジェクトの型を表し、`wrapper.context` からアクセスできます。\n \n-  **最重要** 事項: 特定のエージェント実行におけるすべてのエージェント、ツール関数、ライフサイクルなどは、同じ型のコンテキストを使わなければなりません。\n+ **最も重要な点** は、特定のエージェント実行におけるすべてのエージェント、ツール関数、ライフサイクルなどが、同じ「型」のコンテキストを使用しなければならないことです。\n \n コンテキストは次のような用途に使えます。\n \n-- 実行のためのコンテキストデータ（例: ユーザー名/uid など、ユーザーに関する情報）\n-- 依存関係（例: ロガーオブジェクト、データフェッチャーなど）\n-- ヘルパー関数\n+-   実行のためのコンテキストデータ（例: ユーザー名 / UID など、ユーザーに関する情報）\n+-   依存関係（例: ロガーオブジェクト、データフェッチャーなど）\n+-   ヘルパー関数\n \n !!! danger \"注意\"\n \n-    コンテキストオブジェクトは LLM には送信されません。これは純粋にローカルなオブジェクトであり、読み書きやメソッド呼び出しが可能です。\n+    コンテキストオブジェクトは LLM に **送信されません**。これは純粋にローカルなオブジェクトで、読み書きやメソッド呼び出しができます。\n \n ```python\n import asyncio\n@@ -66,18 +66,18 @@ if __name__ == \"__main__\":\n     asyncio.run(main())\n ```\n \n-1. これはコンテキストオブジェクトです。ここでは dataclass を使用していますが、任意の型を使えます。\n+1. これはコンテキストオブジェクトです。ここでは dataclass を使っていますが、任意の型を使用できます。\n 2. これはツールです。`RunContextWrapper[UserInfo]` を受け取ることがわかります。ツールの実装はコンテキストから読み取ります。\n-3. 型チェッカーがエラーを検出できるように、エージェントにジェネリックな `UserInfo` を指定します（たとえば、異なるコンテキスト型を受け取るツールを渡そうとした場合など）。\n-4. `run` 関数にコンテキストが渡されます。\n+3. 型チェッカーがエラーを検出できるよう、エージェントにジェネリックな `UserInfo` を付与しています（たとえば、異なるコンテキスト型を取るツールを渡そうとした場合など）。\n+4. コンテキストは `run` 関数に渡されます。\n 5. エージェントはツールを正しく呼び出して年齢を取得します。\n \n ---\n \n-### 応用: `ToolContext`\n+### 上級: `ToolContext`\n \n-場合によっては、実行中のツールに関する追加メタデータ（名前、呼び出し ID、raw 引数文字列など）にアクセスしたいことがあります。  \n-そのためには、`RunContextWrapper` を拡張した [`ToolContext`][agents.tool_context.ToolContext] クラスを使用できます。\n+場合によっては、実行中のツールに関する追加メタデータ（名前、コール ID、raw な引数文字列など）へアクセスしたいことがあります。  \n+そのために、`RunContextWrapper` を拡張した [`ToolContext`][agents.tool_context.ToolContext] クラスを使えます。\n \n ```python\n from typing import Annotated\n@@ -106,22 +106,22 @@ agent = Agent(\n ```\n \n `ToolContext` は `RunContextWrapper` と同じ `.context` プロパティに加えて、  \n-現在のツール呼び出しに特化した追加フィールドを提供します。\n+現在のツール呼び出しに固有の次のフィールドを提供します。\n \n-- `tool_name` – 呼び出されているツールの名前  \n-- `tool_call_id` – このツール呼び出しの一意の識別子  \n-- `tool_arguments` – ツールに渡された raw 引数文字列  \n+- `tool_name` – 呼び出されるツールの名前  \n+- `tool_call_id` – このツール呼び出しの一意な識別子  \n+- `tool_arguments` – ツールに渡された raw な引数文字列  \n \n-実行中にツールレベルのメタデータが必要な場合は `ToolContext` を使用します。  \n-エージェントとツール間で一般的にコンテキストを共有するだけなら、`RunContextWrapper` で十分です。\n+実行中にツールレベルのメタデータが必要な場合は `ToolContext` を使用してください。  \n+エージェントとツール間で一般的にコンテキストを共有するだけであれば、`RunContextWrapper` で十分です。\n \n ---\n \n-## エージェント/LLM コンテキスト\n+## エージェント / LLM のコンテキスト\n \n-LLM が呼び出されるとき、LLM が参照できるのは会話履歴のデータだけです。つまり、新しいデータを LLM に利用可能にしたい場合は、その履歴で参照できる形で提供する必要があります。方法はいくつかあります。\n+LLM が呼び出されるとき、LLM が目にできるデータは会話履歴に含まれるもの **のみ** です。したがって、新しいデータを LLM に利用可能にしたい場合は、その履歴で利用できるようにする必要があります。方法はいくつかあります。\n \n-1. エージェントの `instructions` に追加します。これは「システムプロンプト」または「開発者メッセージ」とも呼ばれます。システムプロンプトは静的な文字列にも、コンテキストを受け取って文字列を出力する動的関数にもできます。これは常に有用な情報（例: ユーザー名や現在の日付）に対して一般的な手法です。\n-2. `Runner.run` を呼び出すときの `input` に追加します。これは `instructions` の手法に似ていますが、[指揮系統](https://cdn.openai.com/spec/model-spec-2024-05-08.html#follow-the-chain-of-command) の下位にメッセージを配置できます。\n-3. 関数ツールとして公開します。これはオンデマンドのコンテキストに有用です。LLM が必要に応じてデータを要求し、ツールを呼び出してそのデータを取得できます。\n-4. リトリーバルや Web 検索を使用します。これらは、ファイルやデータベース（リトリーバル）から、または Web（Web 検索）から関連データを取得できる特殊なツールです。これは、応答を関連するコンテキストデータに基づいて根拠付けるのに有用です。\n\\ No newline at end of file\n+1. エージェントの `instructions` に追加します。これは「システムプロンプト」または「開発者メッセージ」とも呼ばれます。システムプロンプトは静的な文字列でも、コンテキストを受け取って文字列を出力する動的な関数でもかまいません。これは常に有用な情報（例: ユーザーの名前や現在の日付）に適した一般的な手法です。\n+2. `Runner.run` を呼び出すときの `input` に追加します。これは `instructions` の手法に似ていますが、[指揮系統](https://cdn.openai.com/spec/model-spec-2024-05-08.html#follow-the-chain-of-command) の下位にあるメッセージを持てます。\n+3. 関数ツールで公開します。これはオンデマンドのコンテキストに有用です。LLM がいつデータを必要とするかを判断し、そのデータを取得するためにツールを呼び出せます。\n+4. リトリーバルまたは Web 検索を使用します。これらは、ファイルやデータベース（リトリーバル）、または Web（Web 検索）から関連データを取得できる特別なツールです。これは、関連するコンテキストデータで応答を「根拠付け」るのに有用です。\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Fcontext.md",
        "sha": "5d21ed62a64dd6c54fa5dcefabb68f92b3b604d1",
        "status": "modified"
      },
      {
        "additions": 84,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Fexamples.md",
        "changes": 168,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fja%2Fexamples.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 84,
        "filename": "docs/ja/examples.md",
        "patch": "@@ -4,90 +4,90 @@ search:\n ---\n # コード例\n \n-[リポジトリ](https://github.com/openai/openai-agents-python/tree/main/examples) の examples セクションで、SDK のさまざまな実装サンプルをご覧ください。これらのコード例は、異なるパターンや機能を示す複数のカテゴリーに整理されています。\n+[リポジトリ](https://github.com/openai/openai-agents-python/tree/main/examples) の examples セクションで、SDK のさまざまなサンプル実装をご確認ください。これらのコード例は、異なるパターンや機能を示す複数のカテゴリーに整理されています。\n \n ## カテゴリー\n \n--   **[agent_patterns](https://github.com/openai/openai-agents-python/tree/main/examples/agent_patterns):**\n-    このカテゴリーのコード例は、以下のような一般的なエージェント設計パターンを示します\n-\n-    -   決定論的ワークフロー\n-    -   ツールとしてのエージェント\n-    -   エージェントの並列実行\n-    -   条件付きのツール使用\n-    -   入出力のガードレール\n-    -   LLM を審査員として利用\n-    -   ルーティング\n-    -   ストリーミング ガードレール\n-\n--   **[basic](https://github.com/openai/openai-agents-python/tree/main/examples/basic):**\n-    これらのコード例は、SDK の基礎的な機能を示します\n-\n-    -   Hello world のコード例（デフォルトモデル、GPT-5、オープンウェイトモデル）\n-    -   エージェントのライフサイクル管理\n-    -   動的な system prompt\n-    -   ストリーミング出力（テキスト、アイテム、function call の引数）\n-    -   プロンプトテンプレート\n-    -   ファイル処理（ローカル / リモート、画像 / PDF）\n-    -   使用状況の追跡\n-    -   非厳密な出力型\n-    -   以前のレスポンス ID の利用\n-\n--   **[customer_service](https://github.com/openai/openai-agents-python/tree/main/examples/customer_service):**\n-    航空会社向けのカスタマーサービス システムの例です。\n-\n--   **[financial_research_agent](https://github.com/openai/openai-agents-python/tree/main/examples/financial_research_agent):**\n-    金融データ分析のために、エージェントとツールで構造化された調査ワークフローを示す金融リサーチ エージェントです。\n-\n--   **[handoffs](https://github.com/openai/openai-agents-python/tree/main/examples/handoffs):**\n-    メッセージフィルタリングを用いたエージェントのハンドオフの実用的なコード例をご覧ください。\n-\n--   **[hosted_mcp](https://github.com/openai/openai-agents-python/tree/main/examples/hosted_mcp):**\n-    ホストされた MCP (Model Context Protocol) コネクタと承認フローの使い方を示すコード例です。\n-\n--   **[mcp](https://github.com/openai/openai-agents-python/tree/main/examples/mcp):**\n-    MCP (Model Context Protocol) を用いてエージェントを構築する方法を学べます。以下を含みます:\n-\n-    -   ファイルシステムのコード例\n-    -   Git のコード例\n-    -   MCP プロンプトサーバーのコード例\n-    -   SSE (Server-Sent Events) のコード例\n-    -   ストリーム可能な HTTP のコード例\n-\n--   **[memory](https://github.com/openai/openai-agents-python/tree/main/examples/memory):**\n-    エージェント向けのさまざまなメモリ実装のコード例です。以下を含みます:\n-\n-    -   SQLite セッションストレージ\n-    -   高度な SQLite セッションストレージ\n-    -   Redis セッションストレージ\n-    -   SQLAlchemy セッションストレージ\n-    -   暗号化セッションストレージ\n-    -   OpenAI セッションストレージ\n-\n--   **[model_providers](https://github.com/openai/openai-agents-python/tree/main/examples/model_providers):**\n-    カスタムプロバイダーや LiteLLM 統合を含む、非 OpenAI モデルを SDK で使用する方法を学びます。\n-\n--   **[realtime](https://github.com/openai/openai-agents-python/tree/main/examples/realtime):**\n-    SDK を使ってリアルタイムな体験を構築する方法を示すコード例です。以下を含みます:\n-\n-    -   Web アプリケーション\n-    -   コマンドライン インターフェイス\n-    -   Twilio 統合\n-\n--   **[reasoning_content](https://github.com/openai/openai-agents-python/tree/main/examples/reasoning_content):**\n-    推論コンテンツと structured outputs を扱う方法を示すコード例です。\n-\n--   **[research_bot](https://github.com/openai/openai-agents-python/tree/main/examples/research_bot):**\n-    複雑なマルチエージェントのリサーチ ワークフローを示す、シンプルな ディープリサーチ クローンです。\n-\n--   **[tools](https://github.com/openai/openai-agents-python/tree/main/examples/tools):**\n-    次のような OpenAI がホストするツール の実装方法を学びます:\n-\n-    -   Web 検索、およびフィルター付きの Web 検索\n-    -   ファイル検索\n-    -   Code Interpreter\n-    -   コンピュータ操作\n-    -   画像生成\n-\n--   **[voice](https://github.com/openai/openai-agents-python/tree/main/examples/voice):**\n-    TTS と STT モデルを用いた音声エージェントのコード例をご覧ください。音声のストリーミングのコード例も含みます。\n\\ No newline at end of file\n+- **[agent_patterns](https://github.com/openai/openai-agents-python/tree/main/examples/agent_patterns):**\n+  このカテゴリーのコード例は、次のような一般的なエージェント設計パターンを示します。\n+\n+  - 決定的ワークフロー\n+  - ツールとしてのエージェント\n+  - エージェントの並列実行\n+  - 条件付きのツール使用\n+  - 入出力ガードレール\n+  - LLM を審判として\n+  - ルーティング\n+  - ストリーミング ガードレール\n+\n+- **[basic](https://github.com/openai/openai-agents-python/tree/main/examples/basic):**\n+  これらのコード例は、次のような SDK の基礎機能を紹介します。\n+\n+  - Hello world コード例 (Default model、GPT-5、open-weight model)\n+  - エージェントのライフサイクル管理\n+  - 動的なシステムプロンプト\n+  - ストリーミング出力 (テキスト、アイテム、function call args)\n+  - プロンプトテンプレート\n+  - ファイル処理 (ローカルとリモート、画像と PDF)\n+  - 利用状況のトラッキング\n+  - 非厳密な出力型\n+  - 直前のレスポンス ID の利用\n+\n+- **[customer_service](https://github.com/openai/openai-agents-python/tree/main/examples/customer_service):**\n+  航空会社向けのカスタマーサービス システムのコード例です。\n+\n+- **[financial_research_agent](https://github.com/openai/openai-agents-python/tree/main/examples/financial_research_agent):**\n+  金融データ分析のためのエージェントとツールで、構造化されたリサーチ ワークフローを示す金融リサーチ エージェントです。\n+\n+- **[handoffs](https://github.com/openai/openai-agents-python/tree/main/examples/handoffs):**\n+  メッセージフィルタリングを伴うエージェントのハンドオフの実用的なコード例です。\n+\n+- **[hosted_mcp](https://github.com/openai/openai-agents-python/tree/main/examples/hosted_mcp):**\n+  hosted MCP (Model context protocol) コネクタと承認フローの使い方を示すコード例です。\n+\n+- **[mcp](https://github.com/openai/openai-agents-python/tree/main/examples/mcp):**\n+  MCP (Model context protocol) を使ってエージェントを構築する方法を学べます。次を含みます:\n+\n+  - ファイルシステムのコード例\n+  - Git のコード例\n+  - MCP プロンプト サーバーのコード例\n+  - SSE (Server-Sent Events) のコード例\n+  - ストリーム可能な HTTP のコード例\n+\n+- **[memory](https://github.com/openai/openai-agents-python/tree/main/examples/memory):**\n+  エージェント向けのさまざまなメモリ実装のコード例です。次を含みます:\n+\n+  - SQLite セッションストレージ\n+  - 高度な SQLite セッションストレージ\n+  - Redis セッションストレージ\n+  - SQLAlchemy セッションストレージ\n+  - 暗号化されたセッションストレージ\n+  - OpenAI セッションストレージ\n+\n+- **[model_providers](https://github.com/openai/openai-agents-python/tree/main/examples/model_providers):**\n+  カスタムプロバイダーや LiteLLM 連携を含む、OpenAI 以外のモデルを SDK で使う方法を紹介します。\n+\n+- **[realtime](https://github.com/openai/openai-agents-python/tree/main/examples/realtime):**\n+  SDK を用いてリアルタイム体験を構築するコード例です。次を含みます:\n+\n+  - Web アプリケーション\n+  - コマンドライン インターフェイス\n+  - Twilio 連携\n+\n+- **[reasoning_content](https://github.com/openai/openai-agents-python/tree/main/examples/reasoning_content):**\n+  reasoning content と structured outputs の扱い方を示すコード例です。\n+\n+- **[research_bot](https://github.com/openai/openai-agents-python/tree/main/examples/research_bot):**\n+  複雑なマルチエージェントのリサーチ ワークフローを示す、シンプルなディープリサーチ クローンです。\n+\n+- **[tools](https://github.com/openai/openai-agents-python/tree/main/examples/tools):**\n+  次のような OpenAI がホストするツールの実装方法を学べます。\n+\n+  - Web 検索、およびフィルター付き Web 検索\n+  - ファイル検索\n+  - Code Interpreter\n+  - コンピュータ操作\n+  - 画像生成\n+\n+- **[voice](https://github.com/openai/openai-agents-python/tree/main/examples/voice):**\n+  TTS と STT モデルを用いた音声エージェントのコード例をご覧ください。音声のストリーミング コード例も含みます。\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Fexamples.md",
        "sha": "2e175071cbf8ae78d641da19f9fa6aacef3b6926",
        "status": "modified"
      },
      {
        "additions": 22,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Fguardrails.md",
        "changes": 44,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fja%2Fguardrails.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 22,
        "filename": "docs/ja/guardrails.md",
        "patch": "@@ -4,54 +4,54 @@ search:\n ---\n # ガードレール\n \n-ガードレールは、 ユーザー 入力や エージェント 出力のチェックと検証を可能にします。たとえば、顧客対応を支援する非常に賢い（つまり遅く/高価な）モデルを使う エージェント がいるとします。悪意のある ユーザー が、数学の宿題を手伝うようモデルに依頼するようなことは避けたいはずです。そこで、速く/安価なモデルでガードレールを実行できます。ガードレールが不正使用を検知した場合、即座にエラーを発生させて高価なモデルの実行を防ぎ、時間とコストを節約できます（ **blocking ガードレールを使用する場合。parallel ガードレールでは、ガードレールが完了する前に高価なモデルがすでに実行を開始している可能性があります。詳細は以下の「実行モード」を参照してください** ）。\n+ガードレールは、 ユーザー 入力やエージェント出力に対するチェックとバリデーションを可能にします。例えば、顧客からのリクエスト対応に非常に賢い（その分、遅く/高価な）モデルを使うエージェントがあるとします。悪意のある ユーザー がモデルに数学の宿題を手伝わせるよう求めることは避けたいはずです。そのため、速く/安価なモデルでガードレールを実行できます。ガードレールが悪意ある利用を検知した場合、ただちにエラーを送出し、高価なモデルの実行を防げるため、時間と費用を節約できます（ **ブロッキング ガードレールを使用する場合**。並列ガードレールでは、ガードレールの完了前に高価なモデルが実行を開始している可能性があります。詳細は下記「実行モード」を参照してください）。\n \n ガードレールには 2 種類あります:\n \n-1. 入力ガードレール: 初回の ユーザー 入力で実行されます\n-2. 出力ガードレール: 最終的な エージェント 出力で実行されます\n+1. 入力ガードレールは最初の ユーザー 入力で実行されます\n+2. 出力ガードレールは最終的なエージェント出力で実行されます\n \n ## 入力ガードレール\n \n 入力ガードレールは 3 ステップで実行されます:\n \n-1. まず、ガードレールは エージェント に渡されたものと同じ入力を受け取ります。\n-2. 次に、ガードレール関数が実行され、[`GuardrailFunctionOutput`][agents.guardrail.GuardrailFunctionOutput] を生成し、それが [`InputGuardrailResult`][agents.guardrail.InputGuardrailResult] にラップされます。\n-3. 最後に、[`.tripwire_triggered`][agents.guardrail.GuardrailFunctionOutput.tripwire_triggered] が true かどうかを確認します。true の場合、[`InputGuardrailTripwireTriggered`][agents.exceptions.InputGuardrailTripwireTriggered] 例外が送出され、 ユーザー への適切な応答や例外処理が可能になります。\n+1. 最初に、ガードレールはエージェントに渡されたものと同じ入力を受け取ります。\n+2. 次に、ガードレール関数が実行され、[`GuardrailFunctionOutput`][agents.guardrail.GuardrailFunctionOutput] を生成し、これを [`InputGuardrailResult`][agents.guardrail.InputGuardrailResult] にラップします。\n+3. 最後に、[`.tripwire_triggered`][agents.guardrail.GuardrailFunctionOutput.tripwire_triggered] が true かを確認します。true の場合、[`InputGuardrailTripwireTriggered`][agents.exceptions.InputGuardrailTripwireTriggered] 例外を送出し、 ユーザー への適切な対応や例外処理ができるようにします。\n \n !!! Note\n \n-    入力ガードレールは ユーザー 入力で実行されることを想定しているため、 エージェント のガードレールは、その エージェント が「最初の」 エージェント の場合にのみ実行されます。なぜ `guardrails` プロパティが エージェント 側にあり、`Runner.run` に渡さないのかと疑問に思われるかもしれません。これは、ガードレールが実際の Agent（エージェント）に密接に関係する傾向があるためです。 エージェント ごとに異なるガードレールを実行することになるため、コードを同じ場所に置くほうが可読性に役立ちます。\n+    入力ガードレールは ユーザー 入力に対して実行されることを想定しているため、エージェントのガードレールは、そのエージェントが「最初の」エージェントの場合にのみ実行されます。なぜ `guardrails` プロパティがエージェント側にあり、`Runner.run` に渡さないのか疑問に思うかもしれません。これは、ガードレールが実際のエージェントに密接に関連する傾向があるためです。エージェントごとに異なるガードレールを実行することになるため、コードを同じ場所に置くことは可読性の面で有用です。\n \n ### 実行モード\n \n 入力ガードレールは 2 つの実行モードをサポートします:\n \n-- **並列実行**（デフォルト、`run_in_parallel=True`）: ガードレールは エージェント の実行と同時に並行して動作します。両者が同時に開始されるため待ち時間が最小になります。ただし、ガードレールが失敗した場合でも、キャンセルされるまでに エージェント がすでにトークンを消費したり ツール を実行している可能性があります。\n+- **並列実行**（デフォルト、`run_in_parallel=True`）: ガードレールはエージェントの実行と同時に並行して動作します。両者が同時に開始するため、待ち時間に最も優れます。ただし、ガードレールが失敗した場合、キャンセルされるまでにエージェントがすでにトークンを消費し、ツールを実行している可能性があります。\n \n-- **ブロッキング実行**（`run_in_parallel=False`）: ガードレールは エージェント の開始「前」に実行・完了します。ガードレールのトリップワイヤーが発火した場合、 エージェント は実行されず、トークン消費や ツール の実行を防げます。コスト最適化や ツール 呼び出しによる副作用を避けたい場合に最適です。\n+- **ブロッキング実行**（`run_in_parallel=False`）: ガードレールはエージェントが開始する「前に」実行・完了します。ガードレールのトリップワイヤーが発火した場合、エージェントは実行されず、トークン消費やツール実行を防げます。これはコスト最適化や、ツール呼び出しによる副作用を避けたい場合に最適です。\n \n ## 出力ガードレール\n \n 出力ガードレールは 3 ステップで実行されます:\n \n-1. まず、ガードレールは エージェント が生成した出力を受け取ります。\n-2. 次に、ガードレール関数が実行され、[`GuardrailFunctionOutput`][agents.guardrail.GuardrailFunctionOutput] を生成し、それが [`OutputGuardrailResult`][agents.guardrail.OutputGuardrailResult] にラップされます。\n-3. 最後に、[`.tripwire_triggered`][agents.guardrail.GuardrailFunctionOutput.tripwire_triggered] が true かどうかを確認します。true の場合、[`OutputGuardrailTripwireTriggered`][agents.exceptions.OutputGuardrailTripwireTriggered] 例外が送出され、 ユーザー への適切な応答や例外処理が可能になります。\n+1. 最初に、ガードレールはエージェントが生成した出力を受け取ります。\n+2. 次に、ガードレール関数が実行され、[`GuardrailFunctionOutput`][agents.guardrail.GuardrailFunctionOutput] を生成し、これを [`OutputGuardrailResult`][agents.guardrail.OutputGuardrailResult] にラップします。\n+3. 最後に、[`.tripwire_triggered`][agents.guardrail.GuardrailFunctionOutput.tripwire_triggered] が true かを確認します。true の場合、[`OutputGuardrailTripwireTriggered`][agents.exceptions.OutputGuardrailTripwireTriggered] 例外を送出し、 ユーザー への適切な対応や例外処理ができるようにします。\n \n !!! Note\n \n-    出力ガードレールは最終的な エージェント 出力に対して実行されることを想定しているため、その エージェント が「最後の」 エージェント の場合にのみ実行されます。入力ガードレールと同様に、ガードレールは実際の Agent（エージェント）に密接に関係するため、コードを同じ場所に置くほうが可読性に役立ちます。\n+    出力ガードレールは最終的なエージェント出力に対して実行されることを想定しているため、エージェントのガードレールは、そのエージェントが「最後の」エージェントの場合にのみ実行されます。入力ガードレールと同様、ガードレールは実際のエージェントに密接に関連する傾向があるため、コードを同じ場所に置くことは可読性の面で有用です。\n \n-    出力ガードレールは常に エージェント の完了後に実行されるため、`run_in_parallel` パラメーターはサポートしません。\n+    出力ガードレールは常にエージェントの完了後に実行されるため、`run_in_parallel` パラメーターはサポートしません。\n \n ## トリップワイヤー\n \n-入力または出力がガードレールに不合格となった場合、ガードレールはトリップワイヤーでそれを示せます。トリップワイヤーが発火したガードレールを検知したらただちに `{Input,Output}GuardrailTripwireTriggered` 例外を送出し、 エージェント の実行を停止します。\n+入力または出力がガードレールに不合格となった場合、ガードレールはトリップワイヤーでこれを通知できます。トリップワイヤーが発火したガードレールを検知するとすぐに、`{Input,Output}GuardrailTripwireTriggered` 例外を送出し、エージェントの実行を停止します。\n \n ## ガードレールの実装\n \n-入力を受け取り、[`GuardrailFunctionOutput`][agents.guardrail.GuardrailFunctionOutput] を返す関数を用意する必要があります。次の例では、内部で エージェント を実行してこれを行います。\n+入力を受け取り、[`GuardrailFunctionOutput`][agents.guardrail.GuardrailFunctionOutput] を返す関数を用意する必要があります。以下の例では、その裏でエージェントを実行することで実現します。\n \n ```python\n from pydantic import BaseModel\n@@ -104,10 +104,10 @@ async def main():\n         print(\"Math homework guardrail tripped\")\n ```\n \n-1. この エージェント をガードレール関数内で使用します。\n-2. これは エージェント の入力/コンテキストを受け取り、結果を返すガードレール関数です。\n+1. このエージェントをガードレール関数内で使用します。\n+2. これがエージェントの入力/コンテキストを受け取り、結果を返すガードレール関数です。\n 3. ガードレール結果に追加情報を含めることができます。\n-4. これはワークフローを定義する実際の エージェント です。\n+4. これがワークフローを定義する実際のエージェントです。\n \n 出力ガードレールも同様です。\n \n@@ -162,7 +162,7 @@ async def main():\n         print(\"Math output guardrail tripped\")\n ```\n \n-1. これは実際の エージェント の出力型です。\n+1. これは実際のエージェントの出力型です。\n 2. これはガードレールの出力型です。\n-3. これは エージェント の出力を受け取り、結果を返すガードレール関数です。\n-4. これはワークフローを定義する実際の エージェント です。\n\\ No newline at end of file\n+3. これがエージェントの出力を受け取り、結果を返すガードレール関数です。\n+4. これがワークフローを定義する実際のエージェントです。\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Fguardrails.md",
        "sha": "e47cf7cffb632e1c8665cd325c9298c2f7949bbd",
        "status": "modified"
      },
      {
        "additions": 19,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Fhandoffs.md",
        "changes": 38,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fja%2Fhandoffs.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 19,
        "filename": "docs/ja/handoffs.md",
        "patch": "@@ -4,19 +4,19 @@ search:\n ---\n # ハンドオフ\n \n-ハンドオフは、ある エージェント が別の エージェント にタスクを委譲できるようにするものです。これは、異なる エージェント がそれぞれ別の分野を専門とするシナリオで特に有用です。たとえば、カスタマーサポートアプリでは、注文状況、返金、FAQ などをそれぞれ担当する エージェント がいるかもしれません。\n+ハンドオフは、ある エージェント から別の エージェント へタスクを委譲できる機能です。これは、異なる エージェント がそれぞれ別の分野に特化している場面で特に有用です。たとえば、カスタマーサポートアプリでは、注文状況、返金、FAQ などのタスクを個別に担当する エージェント が存在するかもしれません。\n \n-ハンドオフは LLM に対してはツールとして表現されます。たとえば、`Refund Agent` という エージェント へのハンドオフがある場合、ツール名は `transfer_to_refund_agent` になります。\n+ハンドオフは LLM にはツールとして提示されます。たとえば、`Refund Agent` という エージェント へのハンドオフがある場合、ツール名は `transfer_to_refund_agent` になります。\n \n ## ハンドオフの作成\n \n-すべての エージェント は [`handoffs`][agents.agent.Agent.handoffs] パラメーターを持ち、これは直接 `Agent` を受け取るか、ハンドオフをカスタマイズする `Handoff` オブジェクトを受け取ります。\n+すべての エージェント は [`handoffs`][agents.agent.Agent.handoffs] パラメーターを持ち、これは `Agent` を直接渡すことも、ハンドオフをカスタマイズする `Handoff` オブジェクトを渡すこともできます。\n \n-Agents SDK が提供する [`handoff()`][agents.handoffs.handoff] 関数を使ってハンドオフを作成できます。この関数では、引き渡し先の エージェント に加えて、任意のオーバーライドや入力フィルターを指定できます。\n+Agents SDK が提供する [`handoff()`][agents.handoffs.handoff] 関数を使ってハンドオフを作成できます。この関数では、ハンドオフ先の エージェント を指定し、任意でオーバーライドや入力フィルターを設定できます。\n \n ### 基本的な使い方\n \n-以下のようにシンプルなハンドオフを作成できます。\n+以下はシンプルなハンドオフの作り方です。\n \n ```python\n from agents import Agent, handoff\n@@ -28,19 +28,19 @@ refund_agent = Agent(name=\"Refund agent\")\n triage_agent = Agent(name=\"Triage agent\", handoffs=[billing_agent, handoff(refund_agent)])\n ```\n \n-1. `billing_agent` のように エージェント を直接使うことも、`handoff()` 関数を使うこともできます。\n+1. `billing_agent` のように エージェント をそのまま使うことも、`handoff()` 関数を使うこともできます。\n \n ### `handoff()` 関数によるハンドオフのカスタマイズ\n \n [`handoff()`][agents.handoffs.handoff] 関数では、さまざまなカスタマイズが可能です。\n \n-- `agent`: 引き渡し先の エージェント です。\n-- `tool_name_override`: 既定では `Handoff.default_tool_name()` が使用され、`transfer_to_<agent_name>` に解決されます。これを上書きできます。\n-- `tool_description_override`: `Handoff.default_tool_description()` の既定のツール説明を上書きします。\n-- `on_handoff`: ハンドオフが呼び出されたときに実行されるコールバック関数です。ハンドオフが発生することが分かった時点でのデータ取得の開始などに有用です。この関数は エージェント のコンテキストを受け取り、オプションで LLM が生成した入力も受け取れます。入力データは `input_type` パラメーターで制御します。\n-- `input_type`: ハンドオフが想定する入力タイプ（任意）。\n-- `input_filter`: 次の エージェント が受け取る入力をフィルタリングできます。詳細は以下を参照してください。\n-- `is_enabled`: ハンドオフが有効かどうか。真偽値、または真偽値を返す関数を指定でき、実行時に動的に有効/無効を切り替えられます。\n+- `agent`: ハンドオフ先の エージェント です。\n+- `tool_name_override`: 既定では `Handoff.default_tool_name()` が使われ、`transfer_to_<agent_name>` に解決されます。これを上書きできます。\n+- `tool_description_override`: `Handoff.default_tool_description()` による既定のツール説明を上書きします。\n+- `on_handoff`: ハンドオフが呼び出されたときに実行されるコールバック関数です。ハンドオフの実行が分かった時点でデータ取得を開始するなどに有用です。この関数は エージェント コンテキストを受け取り、任意で LLM が生成した入力も受け取れます。入力データは `input_type` パラメーターで制御します。\n+- `input_type`: ハンドオフが想定する入力の型（任意）。\n+- `input_filter`: 次の エージェント が受け取る入力をフィルタリングできます。詳細は下記を参照してください。\n+- `is_enabled`: ハンドオフを有効化するかどうか。ブール値またはブール値を返す関数を受け取り、実行時に動的に有効・無効を切り替えられます。\n \n ```python\n from agents import Agent, handoff, RunContextWrapper\n@@ -58,9 +58,9 @@ handoff_obj = handoff(\n )\n ```\n \n-## ハンドオフの入力\n+## ハンドオフ入力\n \n-状況によっては、ハンドオフの呼び出し時に LLM にデータを提供してほしい場合があります。たとえば、「エスカレーション エージェント」へのハンドオフを想像してください。ログ記録のために理由を提供してほしいかもしれません。\n+状況によっては、ハンドオフを呼び出す際に LLM にデータを提供してほしい場合があります。たとえば、「 Escalation agent 」へのハンドオフを考えてみましょう。ログに残せるよう、理由を渡したいかもしれません。\n \n ```python\n from pydantic import BaseModel\n@@ -84,9 +84,9 @@ handoff_obj = handoff(\n \n ## 入力フィルター\n \n-ハンドオフが発生すると、新しい エージェント が会話を引き継ぎ、これまでの会話履歴全体を閲覧できるかのように振る舞います。これを変更したい場合は、[`input_filter`][agents.handoffs.Handoff.input_filter] を設定できます。入力フィルターは、既存の入力を [`HandoffInputData`][agents.handoffs.HandoffInputData] 経由で受け取り、新しい `HandoffInputData` を返す関数です。\n+ハンドオフが発生すると、新しい エージェント が会話を引き継いだかのように振る舞い、これまでの会話履歴全体を閲覧できます。これを変更したい場合は、[`input_filter`][agents.handoffs.Handoff.input_filter] を設定できます。入力フィルターは、既存の入力を [`HandoffInputData`][agents.handoffs.HandoffInputData] として受け取り、新しい `HandoffInputData` を返す関数です。\n \n-既定では、ランナーは前の書き起こしを 1 つのアシスタント要約メッセージに折りたたみます（[`RunConfig.nest_handoff_history`][agents.run.RunConfig.nest_handoff_history] を参照）。この要約は、同一の実行中に複数回のハンドオフが発生した場合に新しいターンが追記される `<CONVERSATION HISTORY>` ブロック内に表示されます。完全な `input_filter` を書かずに生成されたメッセージを置き換えるには、[`RunConfig.handoff_history_mapper`][agents.run.RunConfig.handoff_history_mapper] を指定して独自のマッピング関数を提供できます。既定は、ハンドオフ側と実行側のいずれも明示的な `input_filter` を提供しない場合にのみ適用されるため、既にペイロードをカスタマイズしている既存のコード（このリポジトリの code examples を含む）は変更なしで現在の動作を維持します。単一のハンドオフについてネスト動作を上書きしたい場合は、[`handoff(...)`][agents.handoffs.handoff] に `nest_handoff_history=True` または `False` を渡して、[`Handoff.nest_handoff_history`][agents.handoffs.Handoff.nest_handoff_history] を設定してください。生成された要約のラッパー文言だけを変更したい場合は、エージェントを実行する前に [`set_conversation_history_wrappers`][agents.handoffs.set_conversation_history_wrappers]（必要に応じて [`reset_conversation_history_wrappers`][agents.handoffs.reset_conversation_history_wrappers]）を呼び出してください。\n+既定では、ランナーは直前までの発話を 1 つの assistant サマリーメッセージに折りたたみます（[`RunConfig.nest_handoff_history`][agents.run.RunConfig.nest_handoff_history] を参照）。このサマリーは、同一実行中に複数回のハンドオフが起きた場合に新しいターンが追加され続ける `<CONVERSATION HISTORY>` ブロック内に現れます。完全な `input_filter` を書かずに生成メッセージを置き換えたい場合は、[`RunConfig.handoff_history_mapper`][agents.run.RunConfig.handoff_history_mapper] を指定して独自のマッピング関数を提供できます。この既定は、ハンドオフ側と実行側のどちらからも明示的な `input_filter` が与えられていない場合にのみ適用されるため、すでにペイロードをカスタマイズしている既存コード（このリポジトリの code examples を含む）は変更なしで現在の挙動を維持します。単一のハンドオフについてネスト動作を上書きしたい場合は、[`handoff(...)`][agents.handoffs.handoff] に `nest_handoff_history=True` または `False` を渡して、[`Handoff.nest_handoff_history`][agents.handoffs.Handoff.nest_handoff_history] を設定してください。生成されたサマリーのラッパーテキストだけを変更したい場合は、エージェントを実行する前に [`set_conversation_history_wrappers`][agents.handoffs.set_conversation_history_wrappers]（必要に応じて [`reset_conversation_history_wrappers`][agents.handoffs.reset_conversation_history_wrappers]）を呼び出してください。\n \n よくあるパターン（たとえば履歴からすべてのツール呼び出しを削除するなど）は、[`agents.extensions.handoff_filters`][] に実装済みです。\n \n@@ -102,11 +102,11 @@ handoff_obj = handoff(\n )\n ```\n \n-1. これは、`FAQ agent` が呼び出されたときに、履歴からすべてのツールを自動的に削除します。\n+1. これは、`FAQ agent` が呼び出されたときに履歴からツールを自動的にすべて削除します。\n \n ## 推奨プロンプト\n \n-LLMs がハンドオフを正しく理解できるようにするため、エージェント にハンドオフに関する情報を含めることを推奨します。[`agents.extensions.handoff_prompt.RECOMMENDED_PROMPT_PREFIX`][] に推奨のプレフィックスがあり、または [`agents.extensions.handoff_prompt.prompt_with_handoff_instructions`][] を呼び出して、推奨データをプロンプトに自動的に追加できます。\n+LLM がハンドオフを正しく理解できるように、エージェント にハンドオフに関する情報を含めることを推奨します。[`agents.extensions.handoff_prompt.RECOMMENDED_PROMPT_PREFIX`][] に推奨のプレフィックスがあり、または [`agents.extensions.handoff_prompt.prompt_with_handoff_instructions`][] を呼び出して、推奨情報を自動的にプロンプトへ追加できます。\n \n ```python\n from agents import Agent",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Fhandoffs.md",
        "sha": "dc0d3465e1723b901c74dc812716f98987c653f0",
        "status": "modified"
      },
      {
        "additions": 18,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Findex.md",
        "changes": 36,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fja%2Findex.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 18,
        "filename": "docs/ja/index.md",
        "patch": "@@ -4,31 +4,31 @@ search:\n ---\n # OpenAI Agents SDK\n \n-[OpenAI Agents SDK](https://github.com/openai/openai-agents-python) は、抽象化を最小限に抑えた軽量で使いやすいパッケージで、エージェント型の AI アプリを構築できるようにします。これは、以前の エージェント 向け実験である Swarm の本番運用可能なアップグレードです。Agents SDK には、ごく少数の基本コンポーネントがあります:\n+[OpenAI Agents SDK](https://github.com/openai/openai-agents-python) は、抽象化を最小限に抑えた軽量で使いやすいパッケージで、エージェント型 AI アプリを構築できます。これは、以前のエージェント向け実験である [Swarm](https://github.com/openai/swarm/tree/main) の本番運用向けアップグレードです。Agents SDK には、ごく少数の基本コンポーネントがあります。\n \n--   **エージェント** : instructions と tools を備えた LLM\n--   **ハンドオフ** : 特定のタスクを他の エージェント に委任できる機能\n--   **ガードレール** : エージェント の入力と出力を検証する機能\n--   **セッション** : エージェント の実行間で会話履歴を自動的に保持する機能\n+-   **エージェント**: Instructions とツールを備えた LLM\n+-   **ハンドオフ**: 特定のタスクを他のエージェントに委譲可能にします\n+-   **ガードレール**: エージェントの入力と出力の検証を可能にします\n+-   **セッション**: エージェントの実行間で会話履歴を自動的に維持します\n \n-Python と組み合わせることで、これらの基本コンポーネントはツールと エージェント 間の複雑な関係を表現するのに十分強力であり、急な学習コストなしに実用的なアプリケーションを構築できます。さらに、SDK には組み込みの  **トレーシング**  があり、エージェントのフローを可視化・デバッグできるほか、評価を行い、アプリケーション向けにモデルをファインチューニングすることもできます。\n+Python と組み合わせることで、これらの基本コンポーネントはツールとエージェント間の複雑な関係を表現でき、学習コストをかけずに実運用アプリケーションを構築できます。さらに、この SDK には組み込みの **トレーシング** があり、エージェントのフローを可視化・デバッグし、評価したり、アプリケーション向けにモデルをファインチューニングすることもできます。\n \n ## Agents SDK を使う理由\n \n-この SDK の設計原則は次の 2 つです:\n+この SDK は次の 2 つの設計原則に基づいています。\n \n-1. 使う価値のある十分な機能を備えつつ、学習が速いよう基本コンポーネントは少数に保つ。\n-2. そのままでも十分に動作しつつ、挙動を細部までカスタマイズできる。\n+1. 使う価値があるだけの機能を備えつつ、学習が早く済むよう基本コンポーネントは少数にする。\n+2. すぐに高い性能で使える一方で、動作を細かくカスタマイズできる。\n \n-SDK の主な機能は次のとおりです:\n+主な機能は以下のとおりです。\n \n--   エージェント ループ: tools の呼び出し、結果を LLM へ渡す処理、LLM が完了と判断するまでのループを内蔵。\n--   Python ファースト: 新しい抽象化を学ぶのではなく、言語の組み込み機能で エージェント をオーケストレーションおよび連携。\n--   ハンドオフ: 複数の エージェント 間の調整と委任を可能にする強力な機能。\n--   ガードレール: エージェント と並行して入力の検証やチェックを実行し、失敗時は早期に中断。\n--   セッション: エージェント 実行間の会話履歴を自動管理し、手動の状態管理を不要に。\n--   関数ツール: 任意の Python 関数をツール化し、スキーマ自動生成と Pydantic による検証を提供。\n--   トレーシング: 組み込みの  トレーシング  でワークフローの可視化・デバッグ・監視に加え、OpenAI の評価、ファインチューニング、蒸留ツール群を活用可能。\n+-   エージェント ループ: ツールの呼び出し、結果の LLM への送信、LLM が完了するまでのループを処理する組み込みのエージェント ループ。\n+-   Python ファースト: 新しい抽象化を学ぶのではなく、言語の組み込み機能でエージェントをオーケストレーション／連鎖できます。\n+-   ハンドオフ: 複数のエージェント間の調整と委譲を可能にする強力な機能。\n+-   ガードレール: エージェントと並行して入力の検証やチェックを実行し、失敗時は早期に中断。\n+-   セッション: エージェントの実行間で会話履歴を自動的に管理し、手動の状態管理を不要に。\n+-   関数ツール: 任意の Python 関数をツール化し、自動スキーマ生成と Pydantic ベースの検証を提供。\n+-   トレーシング: ワークフローの可視化・デバッグ・監視を可能にし、OpenAI の評価、ファインチューニング、蒸留ツール群も活用できます。\n \n ## インストール\n \n@@ -51,7 +51,7 @@ print(result.final_output)\n # Infinite loop's dance.\n ```\n \n-( _これを実行する場合は、`OPENAI_API_KEY` 環境変数を設定してください_ )\n+(_実行する場合は、`OPENAI_API_KEY` 環境変数を設定してください_)\n \n ```bash\n export OPENAI_API_KEY=sk-...",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Findex.md",
        "sha": "a5db97ba5f096b543fc045534c50b3fc5a655a2a",
        "status": "modified"
      },
      {
        "additions": 50,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Fmcp.md",
        "changes": 97,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fja%2Fmcp.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 47,
        "filename": "docs/ja/mcp.md",
        "patch": "@@ -4,34 +4,35 @@ search:\n ---\n # Model context protocol (MCP)\n \n-[Model context protocol](https://modelcontextprotocol.io/introduction) (MCP) は、アプリケーションがツールとコンテキストを言語モデルへ公開する方法を標準化します。公式ドキュメントより:\n+[Model context protocol](https://modelcontextprotocol.io/introduction) (MCP) は、アプリケーションがツールやコンテキストを言語モデルに公開する方法を標準化します。公式ドキュメントより:\n \n-> MCP is an open protocol that standardizes how applications provide context to LLMs. Think of MCP like a USB-C port for AI\n-> applications. Just as USB-C provides a standardized way to connect your devices to various peripherals and accessories, MCP\n-> provides a standardized way to connect AI models to different data sources and tools.\n+> MCP は、アプリケーションが LLMs にコンテキストを提供する方法を標準化するオープンプロトコルです。MCP は AI\n+> アプリケーション向けの USB‑C ポートのようなものだと考えてください。USB‑C がさまざまな周辺機器やアクセサリにデバイスを接続するための標準化された方法を提供するのと同様に、MCP は\n+> AI モデルをさまざまなデータソースやツールに接続するための標準化された方法を提供します。\n \n-Agents Python SDK は複数の MCP トランスポートに対応します。これにより既存の MCP サーバーを再利用したり、独自に構築してファイルシステム、HTTP、またはコネクター対応のツールを エージェント に公開できます。\n+Agents の Python SDK は複数の MCP トランスポートを理解します。これにより、既存の MCP サーバーを再利用したり、独自の MCP サーバーを構築して、ファイルシステム、HTTP、またはコネクタで支えられたツールを エージェント に公開できます。\n \n ## MCP 統合の選択\n \n-MCP サーバーを エージェント に接続する前に、ツール呼び出しをどこで実行するか、どのトランスポートに到達できるかを決めます。以下のマトリクスは Python SDK がサポートするオプションをまとめたものです。\n+MCP サーバーを エージェント に接続する前に、ツール呼び出しをどこで実行するか、どのトランスポートに到達できるかを決めます。以下のマトリクスは、Python SDK がサポートするオプションの概要です。\n \n-| 必要なこと                                                                           | 推奨オプション                                           |\n-| ------------------------------------------------------------------------------------ | -------------------------------------------------------- |\n-| OpenAI の Responses API に、モデルの代理として外部公開可能な MCP サーバーを呼ばせたい | **ホスト型 MCP サーバー ツール** via [`HostedMCPTool`][agents.tool.HostedMCPTool] |\n-| ローカルまたはリモートで稼働する Streamable HTTP サーバーに接続したい                | **Streamable HTTP MCP サーバー** via [`MCPServerStreamableHttp`][agents.mcp.server.MCPServerStreamableHttp] |\n-| Server-Sent Events を用いた HTTP を実装するサーバーと通信したい                       | **HTTP with SSE MCP サーバー** via [`MCPServerSse`][agents.mcp.server.MCPServerSse] |\n-| ローカルプロセスを起動し、stdin/stdout 経由で通信したい                               | **stdio MCP サーバー** via [`MCPServerStdio`][agents.mcp.server.MCPServerStdio] |\n+| What you need                                                                        | Recommended option                                    |\n+| ------------------------------------------------------------------------------------ | ----------------------------------------------------- |\n+| Let OpenAI's Responses API call a publicly reachable MCP server on the model's behalf|  **Hosted MCP server tools**  via [`HostedMCPTool`][agents.tool.HostedMCPTool] |\n+| Connect to Streamable HTTP servers that you run locally or remotely                  |  **Streamable HTTP MCP servers**  via [`MCPServerStreamableHttp`][agents.mcp.server.MCPServerStreamableHttp] |\n+| Talk to servers that implement HTTP with Server-Sent Events                          |  **HTTP with SSE MCP servers**  via [`MCPServerSse`][agents.mcp.server.MCPServerSse] |\n+| Launch a local process and communicate over stdin/stdout                             |  **stdio MCP servers**  via [`MCPServerStdio`][agents.mcp.server.MCPServerStdio] |\n \n-以下のセクションでは、それぞれのオプションの設定方法と、どのトランスポートを選ぶべきかの目安を説明します。\n+以下のセクションでは、それぞれのオプションの手順、設定方法、どのトランスポートを選ぶべきかを説明します。\n \n-## 1. ホスト型 MCP サーバー ツール\n+## 1. Hosted MCP server tools\n \n-ホスト型ツールは、ツールの往復処理全体を OpenAI のインフラ内で完結させます。あなたのコードがツール一覧取得や呼び出しを行う代わりに、[`HostedMCPTool`][agents.tool.HostedMCPTool] は サーバーラベル（および任意のコネクター メタデータ）を Responses API に転送します。モデルはリモートサーバーのツールを一覧し、あなたの Python プロセスへの追加のコールバックなしでそれらを実行します。ホスト型ツールは現在、Responses API のホスト型 MCP 連携をサポートする OpenAI モデルで動作します。\n+Hosted ツールは、ツールの往復処理全体を OpenAI のインフラに委ねます。あなたのコードがツールを列挙・呼び出す代わりに、[`HostedMCPTool`][agents.tool.HostedMCPTool] が サーバーラベル（および任意のコネクタメタデータ）を Responses API に転送します。モデルはリモートサーバーのツールを列挙し、あなたの Python プロセスへの追加のコールバックなしにそれらを起動します。Hosted ツールは現在、Responses API の hosted MCP 統合をサポートする OpenAI モデルで動作します。\n \n-### 基本的なホスト型 MCP ツール\n+### 基本的な hosted MCP ツール\n \n-エージェント の `tools` リストに [`HostedMCPTool`][agents.tool.HostedMCPTool] を追加してホスト型ツールを作成します。`tool_config` の dict は、REST API に送る JSON をそのまま反映します:\n+エージェントの `tools` リストに [`HostedMCPTool`][agents.tool.HostedMCPTool] を追加して hosted ツールを作成します。`tool_config`\n+dict は、REST API に送信する JSON を反映します:\n \n ```python\n import asyncio\n@@ -59,11 +60,11 @@ async def main() -> None:\n asyncio.run(main())\n ```\n \n-ホスト型サーバーはツールを自動的に公開します。`mcp_servers` に追加する必要はありません。\n+Hosted サーバーはツールを自動的に公開します。`mcp_servers` に追加する必要はありません。\n \n-### ストリーミングによるホスト型 MCP の実行結果\n+### hosted MCP の結果の ストリーミング\n \n-ホスト型ツールは 関数ツール とまったく同じ方法で ストリーミング をサポートします。`Runner.run_streamed` に `stream=True` を渡すと、モデルがまだ動作中でも増分の MCP 出力を消費できます:\n+Hosted ツールは、関数ツールとまったく同じ方法で結果の ストリーミング をサポートします。`Runner.run_streamed` に `stream=True` を渡して、モデルの処理中に増分的な MCP 出力を消費します:\n \n ```python\n result = Runner.run_streamed(agent, \"Summarise this repository's top languages\")\n@@ -75,7 +76,7 @@ print(result.final_output)\n \n ### 任意の承認フロー\n \n-サーバーが機微な操作を実行できる場合、各ツール実行前に人間またはプログラムによる承認を必須にできます。`tool_config` の `require_approval` に、単一のポリシー（`\"always\"`、`\"never\"`）またはツール名からポリシーへの dict を設定します。判断を Python 内で行うには、`on_approval_request` コールバックを指定します。\n+サーバーが機微な操作を実行できる場合、各ツール実行の前に人間またはプログラムによる承認を要求できます。`tool_config` の `require_approval` を単一のポリシー（`\"always\"`、`\"never\"`）またはツール名からポリシーへの dict で設定します。Python 内で判断するには、`on_approval_request` コールバックを指定します。\n \n ```python\n from agents import MCPToolApprovalFunctionResult, MCPToolApprovalRequest\n@@ -103,11 +104,11 @@ agent = Agent(\n )\n ```\n \n-コールバックは同期・非同期のどちらでもよく、モデルが実行を継続するために承認データを必要とするたびに呼び出されます。\n+コールバックは同期または非同期のいずれでも構いません。モデルが実行を続けるために承認データを必要とするたびに呼び出されます。\n \n-### コネクター対応のホスト型サーバー\n+### コネクタで支えられた hosted サーバー\n \n-ホスト型 MCP は OpenAI コネクターにも対応しています。`server_url` を指定する代わりに、`connector_id` とアクセストークンを指定します。Responses API が認証を処理し、ホスト型サーバーはコネクターのツールを公開します。\n+Hosted MCP は OpenAI コネクタにも対応しています。`server_url` を指定する代わりに、`connector_id` とアクセストークンを指定します。Responses API が認証を処理し、hosted サーバーがコネクタのツールを公開します。\n \n ```python\n import os\n@@ -123,12 +124,13 @@ HostedMCPTool(\n )\n ```\n \n-ストリーミング、承認、コネクターを含む完全なホスト型ツールのサンプルは\n+ストリーミング、承認、コネクタを含む完全に動作する hosted ツールのサンプルは\n [`examples/hosted_mcp`](https://github.com/openai/openai-agents-python/tree/main/examples/hosted_mcp) にあります。\n \n ## 2. Streamable HTTP MCP サーバー\n \n-ネットワーク接続を自分で管理したい場合は、[`MCPServerStreamableHttp`][agents.mcp.server.MCPServerStreamableHttp] を使用します。Streamable HTTP サーバーは、トランスポートを自分で制御したい場合や、サーバーを自社インフラ内で動かしつつレイテンシを低く抑えたい場合に最適です。\n+ネットワーク接続を自分で管理したい場合は、\n+[`MCPServerStreamableHttp`][agents.mcp.server.MCPServerStreamableHttp] を使用します。Streamable HTTP サーバーは、トランスポートを制御したい場合や、低レイテンシーを維持しながら自分のインフラ内でサーバーを実行したい場合に最適です。\n \n ```python\n import asyncio\n@@ -163,16 +165,17 @@ async def main() -> None:\n asyncio.run(main())\n ```\n \n-コンストラクターは次の追加オプションを受け付けます:\n+コンストラクターは追加オプションを受け付けます:\n \n - `client_session_timeout_seconds` は HTTP の読み取りタイムアウトを制御します。\n-- `use_structured_content` は `tool_result.structured_content` をテキスト出力より優先するかどうかを切り替えます。\n-- `max_retry_attempts` と `retry_backoff_seconds_base` は `list_tools()` と `call_tool()` に自動リトライを追加します。\n-- `tool_filter` は公開するツールをサブセットに絞り込めます（[ツールのフィルタリング](#tool-filtering) を参照）。\n+- `use_structured_content` は、テキスト出力よりも `tool_result.structured_content` を優先するかどうかを切り替えます。\n+- `max_retry_attempts` と `retry_backoff_seconds_base` は、`list_tools()` と `call_tool()` に自動リトライを追加します。\n+- `tool_filter` を使用すると、一部のツールのみを公開できます（[ツールのフィルタリング](#tool-filtering) を参照）。\n \n ## 3. HTTP with SSE MCP サーバー\n \n-MCP サーバーが HTTP with SSE トランスポートを実装している場合は、[`MCPServerSse`][agents.mcp.server.MCPServerSse] をインスタンス化します。トランスポート以外は、API は Streamable HTTP サーバーと同一です。\n+MCP サーバーが HTTP with SSE トランスポートを実装している場合は、\n+[`MCPServerSse`][agents.mcp.server.MCPServerSse] をインスタンス化します。トランスポート以外は、API は Streamable HTTP サーバーと同一です。\n \n ```python\n \n@@ -201,7 +204,7 @@ async with MCPServerSse(\n \n ## 4. stdio MCP サーバー\n \n-ローカルのサブプロセスとして動作する MCP サーバーには、[`MCPServerStdio`][agents.mcp.server.MCPServerStdio] を使用します。SDK はプロセスを起動し、パイプを開いたまま維持し、コンテキストマネージャの終了時に自動でクローズします。これは、迅速なプロトタイプ作成や、サーバーがコマンドラインのエントリポイントのみを公開している場合に役立ちます。\n+ローカルのサブプロセスとして実行する MCP サーバーには、[`MCPServerStdio`][agents.mcp.server.MCPServerStdio] を使用します。SDK はプロセスを起動し、パイプを開いたままにし、コンテキストマネージャの終了時に自動的にクローズします。これは、迅速なプロトタイピングや、サーバーがコマンドラインのエントリポイントのみを公開している場合に有用です。\n \n ```python\n from pathlib import Path\n@@ -229,11 +232,11 @@ async with MCPServerStdio(\n \n ## ツールのフィルタリング\n \n-各 MCP サーバーはツールフィルターをサポートしており、エージェント に必要な機能だけを公開できます。フィルタリングは、構築時にも、実行ごとの動的制御でも可能です。\n+各 MCP サーバーはツールフィルターをサポートしており、エージェント が必要とする関数のみを公開できます。フィルタリングは、構築時または実行ごとに動的に行えます。\n \n-### 静的なツールフィルタリング\n+### 静的ツールフィルタリング\n \n-[`create_static_tool_filter`][agents.mcp.create_static_tool_filter] を使用して、シンプルな許可/ブロックリストを設定します:\n+[`create_static_tool_filter`][agents.mcp.create_static_tool_filter] を使用して、シンプルな allow/block リストを設定します:\n \n ```python\n from pathlib import Path\n@@ -251,11 +254,11 @@ filesystem_server = MCPServerStdio(\n )\n ```\n \n-`allowed_tool_names` と `blocked_tool_names` の両方が指定された場合、SDK はまず許可リストを適用し、その後残った集合からブロック対象を除外します。\n+`allowed_tool_names` と `blocked_tool_names` の両方が指定された場合、SDK はまず許可リストを適用し、その後、残りの集合からブロックされたツールを削除します。\n \n-### 動的なツールフィルタリング\n+### 動的ツールフィルタリング\n \n-より高度なロジックが必要な場合は、[`ToolFilterContext`][agents.mcp.ToolFilterContext] を受け取る呼び出し可能オブジェクトを渡します。呼び出し可能オブジェクトは同期・非同期いずれも可能で、ツールを公開すべきときに `True` を返します。\n+より高度なロジックには、[`ToolFilterContext`][agents.mcp.ToolFilterContext] を受け取る呼び出し可能オブジェクトを渡します。呼び出し可能オブジェクトは同期でも非同期でもよく、ツールを公開すべき場合に `True` を返します。\n \n ```python\n from pathlib import Path\n@@ -279,14 +282,14 @@ async with MCPServerStdio(\n     ...\n ```\n \n-フィルターコンテキストは、アクティブな `run_context`、ツールを要求している `agent`、および `server_name` を公開します。\n+フィルターコンテキストは、アクティブな `run_context`、ツールを要求する `agent`、および `server_name` を公開します。\n \n ## プロンプト\n \n-MCP サーバーは、エージェントの instructions を動的に生成する プロンプト も提供できます。プロンプトをサポートするサーバーは次の 2 つのメソッドを公開します:\n+MCP サーバーは、エージェントの instructions を動的に生成するプロンプトも提供できます。プロンプトをサポートするサーバーは 2 つのメソッドを公開します:\n \n - `list_prompts()` は利用可能なプロンプトテンプレートを列挙します。\n-- `get_prompt(name, arguments)` は、任意のパラメーター付きで具体的なプロンプトを取得します。\n+- `get_prompt(name, arguments)` は、必要に応じて パラメーター 付きで具体的なプロンプトを取得します。\n \n ```python\n from agents import Agent\n@@ -306,19 +309,19 @@ agent = Agent(\n \n ## キャッシュ\n \n-各 エージェント 実行は、各 MCP サーバーに対して `list_tools()` を呼び出します。リモートサーバーは顕著なレイテンシを導入しうるため、すべての MCP サーバークラスは `cache_tools_list` オプションを公開しています。ツール定義が頻繁に変わらないと確信できる場合にのみ `True` を設定してください。後で新しい一覧を強制するには、サーバーインスタンスで `invalidate_tools_cache()` を呼び出します。\n+各 エージェント 実行は、各 MCP サーバーで `list_tools()` を呼び出します。リモートサーバーは目立ったレイテンシーをもたらす可能性があるため、すべての MCP サーバークラスは `cache_tools_list` オプションを公開しています。ツール定義が頻繁に変更されないと確信できる場合にのみ、これを `True` に設定してください。後で新しいリストを強制するには、サーバーインスタンスで `invalidate_tools_cache()` を呼び出します。\n \n ## トレーシング\n \n-[トレーシング](./tracing.md) は、以下を含む MCP の活動を自動的に取得します:\n+[トレーシング](./tracing.md) は MCP のアクティビティを自動的に取得します。含まれるもの:\n \n-1. ツール一覧のための MCP サーバーへの呼び出し。\n+1. ツールを列挙するための MCP サーバーへの呼び出し。\n 2. ツール呼び出しに関する MCP 関連情報。\n \n-![MCP トレーシングのスクリーンショット](../assets/images/mcp-tracing.jpg)\n+![MCP Tracing Screenshot](../assets/images/mcp-tracing.jpg)\n \n ## 参考資料\n \n-- [Model Context Protocol](https://modelcontextprotocol.io/) – 仕様と設計ガイド。\n+- [Model Context Protocol](https://modelcontextprotocol.io/) – 仕様および設計ガイド。\n - [examples/mcp](https://github.com/openai/openai-agents-python/tree/main/examples/mcp) – 実行可能な stdio、SSE、Streamable HTTP のサンプル。\n-- [examples/hosted_mcp](https://github.com/openai/openai-agents-python/tree/main/examples/hosted_mcp) – 承認やコネクターを含む、完全なホスト型 MCP のデモ。\n\\ No newline at end of file\n+- [examples/hosted_mcp](https://github.com/openai/openai-agents-python/tree/main/examples/hosted_mcp) – 承認やコネクタを含む完全な hosted MCP のデモ。\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Fmcp.md",
        "sha": "4c417eb11f6aa8a42923c1ee2a134db763b98032",
        "status": "modified"
      },
      {
        "additions": 39,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Fmodels%2Findex.md",
        "changes": 78,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fja%2Fmodels%2Findex.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 39,
        "filename": "docs/ja/models/index.md",
        "patch": "@@ -4,20 +4,20 @@ search:\n ---\n # モデル\n \n-Agents SDK には、2 つの形で OpenAI モデルのサポートが標準で含まれています。\n+Agents SDK には、OpenAI モデルを次の 2 種類の方法でそのまま利用できるサポートが含まれています。\n \n--  **推奨**: [`OpenAIResponsesModel`][agents.models.openai_responses.OpenAIResponsesModel]。新しい [Responses API](https://platform.openai.com/docs/api-reference/responses) を使って OpenAI API を呼び出します。\n--  [`OpenAIChatCompletionsModel`][agents.models.openai_chatcompletions.OpenAIChatCompletionsModel]。 [Chat Completions API](https://platform.openai.com/docs/api-reference/chat) を使って OpenAI API を呼び出します。\n+-  **推奨**: 新しい [Responses API](https://platform.openai.com/docs/api-reference/responses) を使って OpenAI API を呼び出す [`OpenAIResponsesModel`][agents.models.openai_responses.OpenAIResponsesModel]\n+-  [Chat Completions API](https://platform.openai.com/docs/api-reference/chat) を使って OpenAI API を呼び出す [`OpenAIChatCompletionsModel`][agents.models.openai_chatcompletions.OpenAIChatCompletionsModel]\n \n ## OpenAI モデル\n \n-`Agent` の初期化時にモデルを指定しない場合は、デフォルトのモデルが使用されます。現在のデフォルトは互換性と低レイテンシのために [`gpt-4.1`](https://platform.openai.com/docs/models/gpt-4.1) です。アクセス権がある場合は、明示的な `model_settings` を維持しつつ、より高品質な [`gpt-5.2`](https://platform.openai.com/docs/models/gpt-5.2) に設定することを推奨します。\n+`Agent` を初期化する際にモデルを指定しない場合は、既定のモデルが使用されます。現在の既定は互換性と低レイテンシのために [`gpt-4.1`](https://platform.openai.com/docs/models/gpt-4.1) です。アクセス権がある場合は、明示的な `model_settings` を維持しつつ、より高品質な [`gpt-5.2`](https://platform.openai.com/docs/models/gpt-5.2) をエージェントに設定することを推奨します。\n \n-[`gpt-5.2`](https://platform.openai.com/docs/models/gpt-5.2) などの他のモデルに切り替えたい場合は、次のセクションの手順に従ってください。\n+[`gpt-5.2`](https://platform.openai.com/docs/models/gpt-5.2) のような他のモデルに切り替えたい場合は、次のセクションの手順に従ってください。\n \n-### デフォルトの OpenAI モデル\n+### 既定の OpenAI モデル\n \n-カスタムモデルを設定していないすべてのエージェントで特定のモデルを一貫して使用したい場合は、エージェントを実行する前に `OPENAI_DEFAULT_MODEL` 環境変数を設定してください。\n+カスタムモデルを設定していないすべてのエージェントで特定のモデルを常に使用したい場合は、エージェントを実行する前に `OPENAI_DEFAULT_MODEL` 環境変数を設定してください。\n \n ```bash\n export OPENAI_DEFAULT_MODEL=gpt-5\n@@ -26,9 +26,9 @@ python3 my_awesome_agent.py\n \n #### GPT-5 モデル\n \n-この方法で GPT-5 のいずれかの推論モデル（[`gpt-5`](https://platform.openai.com/docs/models/gpt-5)、[`gpt-5-mini`](https://platform.openai.com/docs/models/gpt-5-mini)、または [`gpt-5-nano`](https://platform.openai.com/docs/models/gpt-5-nano)）を使用する場合、SDK はデフォルトで適切な `ModelSettings` を適用します。具体的には、`reasoning.effort` と `verbosity` の両方を `\"low\"` に設定します。これらの設定を自分で構成したい場合は、`agents.models.get_default_model_settings(\"gpt-5\")` を呼び出してください。\n+この方法で GPT-5 の推論モデル（[`gpt-5`](https://platform.openai.com/docs/models/gpt-5)、[`gpt-5-mini`](https://platform.openai.com/docs/models/gpt-5-mini)、または [`gpt-5-nano`](https://platform.openai.com/docs/models/gpt-5-nano)）を使用する場合、SDK は既定で妥当な `ModelSettings` を適用します。具体的には、`reasoning.effort` と `verbosity` の両方を `\"low\"` に設定します。これらの設定を自分で構築したい場合は、`agents.models.get_default_model_settings(\"gpt-5\")` を呼び出してください。\n \n-レイテンシを下げたい場合や特定の要件がある場合は、別のモデルと設定を選択できます。デフォルトモデルの推論努力度を調整するには、独自の `ModelSettings` を渡します。\n+レイテンシの低減や特定の要件のために、別のモデルや設定を選択できます。既定モデルの推論負荷を調整するには、独自の `ModelSettings` を渡します。\n \n ```python\n from openai.types.shared import Reasoning\n@@ -44,21 +44,21 @@ my_agent = Agent(\n )\n ```\n \n-とくに低レイテンシを重視する場合、[`gpt-5-mini`](https://platform.openai.com/docs/models/gpt-5-mini) または [`gpt-5-nano`](https://platform.openai.com/docs/models/gpt-5-nano) を `reasoning.effort=\"minimal\"` で使用すると、デフォルト設定より高速に応答を返すことが多いです。ただし、Responses API の一部の組み込みツール（ファイル検索や画像生成など）は `\"minimal\"` の推論努力度をサポートしていないため、この Agents SDK ではデフォルトを `\"low\"` にしています。\n+特にレイテンシ低減のためには、[`gpt-5-mini`](https://platform.openai.com/docs/models/gpt-5-mini) または [`gpt-5-nano`](https://platform.openai.com/docs/models/gpt-5-nano) を `reasoning.effort=\"minimal\"` で使用すると、既定設定より高速に応答が返ることがよくあります。ただし、Responses API の一部の組み込みツール（ファイル検索や画像生成など）は `\"minimal\"` の推論負荷をサポートしていません。そのため、この Agents SDK の既定は `\"low\"` になっています。\n \n #### 非 GPT-5 モデル\n \n-カスタムの `model_settings` なしで GPT-5 以外のモデル名を渡した場合、SDK はあらゆるモデルと互換性のある汎用的な `ModelSettings` にフォールバックします。\n+カスタムの `model_settings` なしで GPT-5 以外のモデル名を渡した場合、SDK は任意のモデルと互換性のある汎用的な `ModelSettings` にフォールバックします。\n \n ## 非 OpenAI モデル\n \n-[LiteLLM 連携](./litellm.md)を通じて、ほとんどの非 OpenAI モデルを使用できます。まず、litellm の依存関係グループをインストールします。\n+[LiteLLM 連携](./litellm.md)を使って、ほとんどの非 OpenAI モデルを利用できます。まず、litellm の依存関係グループをインストールします。\n \n ```bash\n pip install \"openai-agents[litellm]\"\n ```\n \n-次に、`litellm/` プレフィックスを付けて [対応モデル](https://docs.litellm.ai/docs/providers) を使用します。\n+次に、`litellm/` プレフィックスを付けて、[サポートされているモデル](https://docs.litellm.ai/docs/providers) を使用します。\n \n ```python\n claude_agent = Agent(model=\"litellm/anthropic/claude-3-5-sonnet-20240620\", ...)\n@@ -67,29 +67,29 @@ gemini_agent = Agent(model=\"litellm/gemini/gemini-2.5-flash-preview-04-17\", ...)\n \n ### 非 OpenAI モデルを使う他の方法\n \n-他の LLM プロバイダーを、さらに 3 つの方法で統合できます（code examples は [こちら](https://github.com/openai/openai-agents-python/tree/main/examples/model_providers/)）。\n+他の LLM プロバイダーを次の 3 つの方法でも統合できます（code examples は[こちら](https://github.com/openai/openai-agents-python/tree/main/examples/model_providers/)）。\n \n-1. [`set_default_openai_client`][agents.set_default_openai_client] は、グローバルに `AsyncOpenAI` のインスタンスを LLM クライアントとして使用したい場合に便利です。これは LLM プロバイダーが OpenAI 互換の API エンドポイントを持ち、`base_url` と `api_key` を設定できるケース向けです。設定可能な code examples は [examples/model_providers/custom_example_global.py](https://github.com/openai/openai-agents-python/tree/main/examples/model_providers/custom_example_global.py) を参照してください。\n-2. [`ModelProvider`][agents.models.interface.ModelProvider] は `Runner.run` のレベルで指定します。これにより、「この実行内のすべてのエージェントでカスタムのモデルプロバイダーを使用する」と指定できます。設定可能な code examples は [examples/model_providers/custom_example_provider.py](https://github.com/openai/openai-agents-python/tree/main/examples/model_providers/custom_example_provider.py) を参照してください。\n-3. [`Agent.model`][agents.agent.Agent.model] は、特定の Agent インスタンスでモデルを指定できます。これにより、エージェントごとに異なるプロバイダーを組み合わせて使用できます。設定可能な code examples は [examples/model_providers/custom_example_agent.py](https://github.com/openai/openai-agents-python/tree/main/examples/model_providers/custom_example_agent.py) を参照してください。最も多くの利用可能なモデルを簡単に使う方法は、[LiteLLM 連携](./litellm.md)です。\n+1. [`set_default_openai_client`][agents.set_default_openai_client] は、LLM クライアントとして `AsyncOpenAI` のインスタンスをグローバルに使用したい場合に便利です。これは LLM プロバイダーが OpenAI 互換の API エンドポイントを提供し、`base_url` と `api_key` を設定できるケース向けです。設定可能なサンプルは [examples/model_providers/custom_example_global.py](https://github.com/openai/openai-agents-python/tree/main/examples/model_providers/custom_example_global.py) を参照してください。\n+2. [`ModelProvider`][agents.models.interface.ModelProvider] は `Runner.run` レベルで指定します。これにより、「この実行に含まれるすべてのエージェントでカスタムのモデルプロバイダーを使う」と指定できます。設定可能なサンプルは [examples/model_providers/custom_example_provider.py](https://github.com/openai/openai-agents-python/tree/main/examples/model_providers/custom_example_provider.py) を参照してください。\n+3. [`Agent.model`][agents.agent.Agent.model] は、特定の Agent インスタンスでモデルを指定できます。これにより、エージェントごとに異なるプロバイダーを組み合わせて使用できます。設定可能なサンプルは [examples/model_providers/custom_example_agent.py](https://github.com/openai/openai-agents-python/tree/main/examples/model_providers/custom_example_agent.py) を参照してください。最も多くの利用可能なモデルを手軽に使う方法は、[LiteLLM 連携](./litellm.md) 経由です。\n \n `platform.openai.com` の API キーがない場合は、`set_tracing_disabled()` でトレーシングを無効化するか、[別のトレーシング プロセッサー](../tracing.md) を設定することを推奨します。\n \n !!! note\n \n-    これらの code examples では、Responses API をまだサポートしていない LLM プロバイダーがほとんどであるため、Chat Completions API/モデルを使用しています。もしお使いの LLM プロバイダーが対応している場合は、Responses の使用を推奨します。\n+    これらの code examples では、Responses API をまだサポートしていない LLM プロバイダーが多いため、Chat Completions API/モデルを使用しています。プロバイダーが Responses API をサポートしている場合は、Responses の利用を推奨します。\n \n ## モデルの組み合わせ\n \n-単一のワークフロー内で、エージェントごとに異なるモデルを使用したい場合があります。たとえば、振り分けには小型で高速なモデルを、複雑なタスクには大型で高性能なモデルを使うことが考えられます。[`Agent`][agents.Agent] を構成する際、次のいずれかの方法で特定のモデルを選択できます。\n+1 つのワークフロー内で、エージェントごとに異なるモデルを使用したい場合があります。例えば、トリアージには小型で高速なモデルを使い、複雑なタスクには大型で高性能なモデルを使うなどです。[`Agent`][agents.Agent] を設定する際、次のいずれかの方法で特定のモデルを選択できます。\n \n 1. モデル名を直接渡す。\n-2. 任意のモデル名 + その名前を Model インスタンスにマップできる [`ModelProvider`][agents.models.interface.ModelProvider] を渡す。\n-3. [`Model`][agents.models.interface.Model] の実装を直接渡す。\n+2. 任意のモデル名と、それを Model インスタンスにマップできる [`ModelProvider`][agents.models.interface.ModelProvider] を渡す。\n+3. [`Model`][agents.models.interface.Model] 実装を直接提供する。\n \n !!!note\n \n-    SDK は [`OpenAIResponsesModel`][agents.models.openai_responses.OpenAIResponsesModel] と [`OpenAIChatCompletionsModel`][agents.models.openai_chatcompletions.OpenAIChatCompletionsModel] の両方の形をサポートしますが、両者はサポートする機能やツールのセットが異なるため、各ワークフローでは単一のモデル形状を使用することを推奨します。ワークフローでモデル形状を混在させる必要がある場合は、使用するすべての機能が両方で利用可能であることを確認してください。\n+    SDK は [`OpenAIResponsesModel`][agents.models.openai_responses.OpenAIResponsesModel] と [`OpenAIChatCompletionsModel`][agents.models.openai_chatcompletions.OpenAIChatCompletionsModel] の両方の形をサポートしていますが、両者はサポートする機能やツールのセットが異なるため、各ワークフローでは単一のモデル形状を使用することを推奨します。ワークフローでモデル形状を混在させる必要がある場合は、使用するすべての機能が両方で利用可能であることを必ず確認してください。\n \n ```python\n from agents import Agent, Runner, AsyncOpenAI, OpenAIChatCompletionsModel\n@@ -122,10 +122,10 @@ async def main():\n     print(result.final_output)\n ```\n \n-1. OpenAI のモデル名を直接指定します。\n-2. [`Model`][agents.models.interface.Model] の実装を提供します。\n+1. OpenAI のモデル名を直接設定します。\n+2. [`Model`][agents.models.interface.Model] 実装を提供します。\n \n-エージェントで使用するモデルをさらに構成したい場合は、[`ModelSettings`][agents.models.interface.ModelSettings] を渡してください。これは temperature などの任意のモデル構成パラメーターを提供します。\n+エージェントで使用するモデルをさらに構成したい場合は、`temperature` などの任意のモデル構成パラメーターを提供する [`ModelSettings`][agents.models.interface.ModelSettings] を渡せます。\n \n ```python\n from agents import Agent, ModelSettings\n@@ -138,7 +138,7 @@ english_agent = Agent(\n )\n ```\n \n-また、OpenAI の Responses API を使用する場合、[いくつかの他の任意パラメーター](https://platform.openai.com/docs/api-reference/responses/create)（例: `user`、`service_tier` など）があります。トップレベルで指定できない場合は、`extra_args` を使って渡すこともできます。\n+また、OpenAI の Responses API を使用する場合、[他にもいくつかの任意パラメーター](https://platform.openai.com/docs/api-reference/responses/create)（例: `user`、`service_tier` など）があります。トップレベルで指定できない場合は、`extra_args` を使って渡すことができます。\n \n ```python\n from agents import Agent, ModelSettings\n@@ -156,22 +156,22 @@ english_agent = Agent(\n \n ## 他の LLM プロバイダー利用時の一般的な問題\n \n-### トレーシングクライアントのエラー 401\n+### トレーシング クライアントのエラー 401\n \n-トレーシング関連のエラーが発生する場合、トレースは OpenAI のサーバーへアップロードされるため、OpenAI の API キーをお持ちでないことが原因です。解決策は次の 3 つです。\n+トレーシングに関連するエラーが発生する場合、トレースは OpenAI のサーバーにアップロードされ、OpenAI の API キーがないことが原因です。解決するには次の 3 つの選択肢があります。\n \n 1. トレーシングを完全に無効化する: [`set_tracing_disabled(True)`][agents.set_tracing_disabled]\n-2. トレーシング用に OpenAI キーを設定する: [`set_tracing_export_api_key(...)`][agents.set_tracing_export_api_key]。この API キーはトレースのアップロードのみに使用され、[platform.openai.com](https://platform.openai.com/) のものが必要です。\n-3. 非 OpenAI のトレース プロセッサーを使用する。詳しくは [tracing のドキュメント](../tracing.md#custom-tracing-processors) を参照してください。\n+2. トレーシング用の OpenAI キーを設定する: [`set_tracing_export_api_key(...)`][agents.set_tracing_export_api_key]。この API キーはトレースのアップロードのみに使用され、[platform.openai.com](https://platform.openai.com/) のものが必要です。\n+3. 非 OpenAI のトレース プロセッサーを使用する。[tracing ドキュメント](../tracing.md#custom-tracing-processors) を参照してください。\n \n ### Responses API のサポート\n \n-SDK はデフォルトで Responses API を使用しますが、他の多くの LLM プロバイダーはまだサポートしていません。その結果、404 などの問題が発生する場合があります。解決するには次の 2 つの方法があります。\n+SDK は既定で Responses API を使用しますが、他の多くの LLM プロバイダーはまだサポートしていません。その結果、404 などの問題が発生する可能性があります。解決策は次の 2 つです。\n \n 1. [`set_default_openai_api(\"chat_completions\")`][agents.set_default_openai_api] を呼び出す。これは環境変数で `OPENAI_API_KEY` と `OPENAI_BASE_URL` を設定している場合に機能します。\n-2. [`OpenAIChatCompletionsModel`][agents.models.openai_chatcompletions.OpenAIChatCompletionsModel] を使用する。code examples は [こちら](https://github.com/openai/openai-agents-python/tree/main/examples/model_providers/) にあります。\n+2. [`OpenAIChatCompletionsModel`][agents.models.openai_chatcompletions.OpenAIChatCompletionsModel] を使用する。code examples は[こちら](https://github.com/openai/openai-agents-python/tree/main/examples/model_providers/)にあります。\n \n-### structured outputs のサポート\n+### Structured outputs のサポート\n \n 一部のモデルプロバイダーは [structured outputs](https://platform.openai.com/docs/guides/structured-outputs) をサポートしていません。これにより、次のようなエラーが発生することがあります。\n \n@@ -181,12 +181,12 @@ BadRequestError: Error code: 400 - {'error': {'message': \"'response_format.type'\n \n ```\n \n-これは一部のモデルプロバイダーの制約で、JSON 出力自体はサポートしているものの、出力に使用する `json_schema` を指定できないというものです。現在これに対する改善に取り組んでいますが、JSON schema 出力をサポートしているプロバイダーを利用することを推奨します。そうでない場合、不正な形式の JSON によりアプリが頻繁に動作しなくなる可能性があります。\n+これは一部のモデルプロバイダー側の制約で、JSON 出力はサポートしていても、出力に使用する `json_schema` を指定できないというものです。現在これに対する修正に取り組んでいますが、JSON schema 出力をサポートするプロバイダーに依存することを推奨します。そうでない場合、不正な JSON が原因でアプリが頻繁に動作しなくなる可能性があります。\n \n-## 複数プロバイダー間でのモデル混在\n+## プロバイダーをまたぐモデルの混在\n \n-モデルプロバイダー間の機能差に注意しないと、エラーが発生する可能性があります。たとえば、OpenAI は structured outputs、マルチモーダル入力、ホスト型のファイル検索と Web 検索をサポートしていますが、他の多くのプロバイダーはこれらの機能をサポートしていません。次の制限に注意してください。\n+モデルプロバイダー間の機能差に注意しないと、エラーに直面する可能性があります。例えば、OpenAI は structured outputs、マルチモーダル入力、ホスト型の ファイル検索 と Web 検索 をサポートしますが、多くの他プロバイダーはこれらの機能をサポートしていません。次の制約に注意してください。\n \n--  サポートしていない `tools` を理解しないプロバイダーには送らない\n--  テキスト専用のモデルを呼び出す前に、マルチモーダル入力を除外する\n--  structured JSON 出力をサポートしないプロバイダーは、無効な JSON を出力する場合がある点に注意する\n\\ No newline at end of file\n+-  理解しないプロバイダーに対してサポートされていない `tools` を送らない\n+-  テキスト専用のモデルを呼び出す前に、マルチモーダル入力をフィルタリングする\n+-  structured JSON 出力をサポートしないプロバイダーは、無効な JSON を出力することがある点に注意する\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Fmodels%2Findex.md",
        "sha": "354ae12eb4885acd0b9ad7020e62ffa83cbc4eb7",
        "status": "modified"
      },
      {
        "additions": 7,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Fmodels%2Flitellm.md",
        "changes": 14,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fja%2Fmodels%2Flitellm.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 7,
        "filename": "docs/ja/models/litellm.md",
        "patch": "@@ -2,17 +2,17 @@\n search:\n   exclude: true\n ---\n-# LiteLLM を使った任意モデルの利用\n+# LiteLLM による任意モデルの利用\n \n !!! note\n \n-    LiteLLM 連携はベータです。特に小規模なモデルプロバイダーでは問題が発生する可能性があります。問題があれば [Github issues](https://github.com/openai/openai-agents-python/issues) からご報告ください。迅速に対応します。\n+    LiteLLM 統合はベータ版です。特に小規模なモデルプロバイダーでは問題が発生する可能性があります。問題があれば [Github issues](https://github.com/openai/openai-agents-python/issues) から報告してください。迅速に修正します。\n \n-[LiteLLM](https://docs.litellm.ai/docs/) は、単一のインターフェースで 100+ のモデルを利用できるライブラリです。Agents SDK に LiteLLM 連携を追加し、任意の AI モデルを利用できるようにしました。\n+[LiteLLM](https://docs.litellm.ai/docs/) は、単一のインターフェースで 100 以上のモデルを利用できるライブラリです。Agents SDK には LiteLLM 統合が追加されており、任意の AI モデルを利用できます。\n \n ## セットアップ\n \n-`litellm` が利用可能になっていることを確認します。オプションの `litellm` 依存関係グループをインストールしてください。\n+`litellm` が利用可能である必要があります。オプションの `litellm` 依存関係グループをインストールしてください。\n \n ```bash\n pip install \"openai-agents[litellm]\"\n@@ -22,13 +22,13 @@ pip install \"openai-agents[litellm]\"\n \n ## 例\n \n-これは完全に動作するサンプルです。実行すると、モデル名と API キーの入力を求められます。例えば次のように入力できます。\n+これは完全に動作する例です。実行すると、モデル名と API キーの入力を求められます。たとえば、次を入力できます。\n \n - `openai/gpt-4.1`（モデル）と OpenAI の API キー\n - `anthropic/claude-3-5-sonnet-20240620`（モデル）と Anthropic の API キー\n - など\n \n-LiteLLM でサポートされるモデルの一覧は、[litellm providers docs](https://docs.litellm.ai/docs/providers) を参照してください。\n+LiteLLM でサポートされているモデルの一覧は、[litellm providers docs](https://docs.litellm.ai/docs/providers) を参照してください。\n \n ```python\n from __future__ import annotations\n@@ -91,4 +91,4 @@ agent = Agent(\n )\n ```\n \n-`include_usage=True` の場合、LiteLLM のリクエストは、組み込みの OpenAI モデルと同様に、`result.context_wrapper.usage` を通じてトークン数とリクエスト数を報告します。\n\\ No newline at end of file\n+`include_usage=True` を指定すると、LiteLLM のリクエストは組み込みの OpenAI モデルと同様に、`result.context_wrapper.usage` を通じてトークン数とリクエスト数を報告します。\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Fmodels%2Flitellm.md",
        "sha": "16e3f3708341c162f451faaabac4aa05daef8052",
        "status": "modified"
      },
      {
        "additions": 21,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Fmulti_agent.md",
        "changes": 42,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fja%2Fmulti_agent.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 21,
        "filename": "docs/ja/multi_agent.md",
        "patch": "@@ -4,38 +4,38 @@ search:\n ---\n # 複数のエージェントのオーケストレーション\n \n-オーケストレーションとは、アプリ内でのエージェントの流れを指します。どのエージェントを、どの順番で実行し、次に何をするかをどのように決めるのか。エージェントをオーケストレーションする方法は主に 2 つあります。\n+オーケストレーションとは、アプリ内でのエージェントの流れのことです。どのエージェントが、どの順番で実行され、次に何をするかをどう決めるか。エージェントをオーケストレーションする方法は主に 2 つあります。\n \n-1. LLM に意思決定させる: LLM の知性を使って計画・推論し、それに基づいて取るべきステップを決定します。\n+1. LLM に意思決定を任せる: これは LLM の知能を使って計画・推論し、その結果に基づいて取るべき手順を決めます。\n 2. コードでオーケストレーションする: コードでエージェントの流れを決定します。\n \n-これらのパターンは組み合わせて使えます。それぞれにトレードオフがあります（以下を参照）。\n+これらのパターンは組み合わせて使えます。各々のトレードオフは以下のとおりです。\n \n ## LLM によるオーケストレーション\n \n-エージェントは、instructions、tools、ハンドオフを備えた LLM です。これは、オープンエンドな課題が与えられたときに、LLM が自律的に計画を立て、ツールでアクションやデータ取得を行い、ハンドオフでタスクをサブエージェントに委任できることを意味します。たとえば、リサーチ用エージェントには次のようなツールを備えられます。\n+エージェントとは、指示、ツール、ハンドオフを備えた LLM です。つまり、オープンエンドなタスクが与えられたとき、LLM はタスクへの取り組み方を自律的に計画し、ツールを使って行動やデータ取得を行い、ハンドオフでサブエージェントにタスクを委任できます。たとえば、リサーチ用のエージェントには次のようなツールを備えられます。\n \n-- Web 検索でオンライン情報を見つける\n-- ファイル検索と取得でプロプライエタリデータや接続を横断的に検索する\n-- コンピュータ操作でコンピュータ上のアクションを実行する\n-- コード実行でデータ分析を行う\n-- 計画、レポート作成などに優れた専門エージェントへのハンドオフ\n+-   オンラインで情報を見つけるための Web 検索\n+-   企業データやコネクションを横断して探すための ファイル検索 と取得\n+-   コンピュータ操作 によるコンピュータ上でのアクション実行\n+-   データ分析のためのコード実行\n+-   計画、レポート作成などに長けた専門エージェントへのハンドオフ\n \n-このパターンは、課題がオープンエンドで、LLM の知性に依存したい場合に適しています。ここで重要な戦術は次のとおりです。\n+このパターンは、タスクがオープンエンドで、LLM の知能に依存したい場合に適しています。重要なポイントは次のとおりです。\n \n-1. 良いプロンプトに投資する。利用可能なツール、使い方、遵守すべきパラメーターを明確にします。\n-2. アプリを監視して反復する。問題が起きる箇所を確認し、プロンプトを改善します。\n-3. エージェントに内省と改善を許可する。たとえばループで実行し自己批評させる、またはエラーメッセージを提供して改善させます。\n-4. 何でもできる汎用エージェントではなく、1 つのタスクに特化して卓越したエージェントを用意します。\n-5. [evals](https://platform.openai.com/docs/guides/evals) に投資します。これによりエージェントを訓練してスキルを向上できます。\n+1. 良いプロンプトに投資する。利用可能なツール、使い方、運用すべきパラメーターを明確にします。\n+2. アプリを監視し、反復改善する。問題点を観察し、プロンプトを改善します。\n+3. エージェントに内省と改善をさせる。例えばループで実行して自己批評させる、あるいはエラーメッセージを与えて改善させます。\n+4. 何でもこなす汎用エージェントではなく、1 つのタスクに特化して卓越したエージェントを用意する。\n+5. [evals](https://platform.openai.com/docs/guides/evals) に投資する。エージェントを訓練し、タスクの遂行能力を向上させられます。\n \n ## コードによるオーケストレーション\n \n-LLM によるオーケストレーションは強力ですが、コードによるオーケストレーションは、速度・コスト・パフォーマンスの観点でより決定的かつ予測可能になります。ここでの一般的なパターンは次のとおりです。\n+LLM によるオーケストレーションは強力ですが、コードによるオーケストレーションは速度、コスト、パフォーマンスの面でより決定的かつ予測可能にできます。一般的なパターンは次のとおりです。\n \n-- [structured outputs](https://platform.openai.com/docs/guides/structured-outputs) を使って、コードで検査できる 適切な形式のデータ を生成します。たとえば、エージェントにタスクをいくつかの カテゴリー に分類させ、カテゴリー に基づいて次のエージェントを選ぶことができます。\n-- 複数のエージェントを、前の出力を次の入力に変換してつなぎます。ブログ記事の作成を、リサーチ、アウトライン作成、本文執筆、批評、改善といった一連のステップに分解できます。\n-- 評価とフィードバックを行うエージェントと、タスクを実行するエージェントを `while` ループで回し、評価者が所定の基準を満たしたと判断するまで実行します。\n-- 複数のエージェントを並列実行します。たとえば Python の基本コンポーネントである `asyncio.gather` を使います。依存関係のない複数タスクがある場合の高速化に有用です。\n+-   [structured outputs](https://platform.openai.com/docs/guides/structured-outputs) を使って、コードで検査できる 適切な形式のデータ を生成する。例えば、エージェントにタスクをいくつかのカテゴリーに分類させ、そのカテゴリーに基づいて次のエージェントを選ぶといった使い方です。\n+-   複数のエージェントを連結し、前段の出力を次段の入力に変換して渡す。ブログ記事執筆のようなタスクを、調査→アウトライン作成→本文執筆→批評→改善といった一連のステップに分解できます。\n+-   タスクを実行するエージェントと、評価してフィードバックを返すエージェントを `while` ループで回し、評価者が所定の基準を満たしたと判断するまで繰り返す。\n+-   複数のエージェントを並列実行する（例: Python の基本コンポーネントである `asyncio.gather` を使用）。互いに依存しない複数タスクがある場合、速度向上に有用です。\n \n-[`examples/agent_patterns`](https://github.com/openai/openai-agents-python/tree/main/examples/agent_patterns) に多数の code examples があります。\n\\ No newline at end of file\n+[`examples/agent_patterns`](https://github.com/openai/openai-agents-python/tree/main/examples/agent_patterns) には多数の code examples があります。\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Fmulti_agent.md",
        "sha": "1a0f26e439cca4960f2c5854bc54248779eb7159",
        "status": "modified"
      },
      {
        "additions": 13,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Fquickstart.md",
        "changes": 26,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fja%2Fquickstart.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 13,
        "filename": "docs/ja/quickstart.md",
        "patch": "@@ -6,7 +6,7 @@ search:\n \n ## プロジェクトと仮想環境の作成\n \n-この作業は一度だけで大丈夫です。\n+この作業は一度だけ必要です。\n \n ```bash\n mkdir my_project\n@@ -30,15 +30,15 @@ pip install openai-agents # or `uv add openai-agents`, etc\n \n ### OpenAI API キーの設定\n \n-お持ちでない場合は、[こちらの手順](https://platform.openai.com/docs/quickstart#create-and-export-an-api-key)に従って OpenAI API キーを作成してください。\n+まだ持っていない場合は、[こちらの手順](https://platform.openai.com/docs/quickstart#create-and-export-an-api-key)に従って OpenAI API キーを作成してください。\n \n ```bash\n export OPENAI_API_KEY=sk-...\n ```\n \n ## 最初のエージェントの作成\n \n-エージェントは instructions、名前、そして省略可能な設定（`model_config` など）で定義します。\n+エージェントは instructions、名前、任意の設定（`model_config` など）で定義します。\n \n ```python\n from agents import Agent\n@@ -49,9 +49,9 @@ agent = Agent(\n )\n ```\n \n-## さらにいくつかのエージェントを追加\n+## いくつかのエージェントを追加\n \n-追加のエージェントも同様に定義できます。`handoff_descriptions` はハンドオフのルーティングを判断するための追加コンテキストを提供します。\n+追加のエージェントも同様に定義できます。`handoff_descriptions` は、ハンドオフのルーティングを判断するための追加のコンテキストを提供します。\n \n ```python\n from agents import Agent\n@@ -71,7 +71,7 @@ math_tutor_agent = Agent(\n \n ## ハンドオフの定義\n \n-各エージェントで、タスクを前進させる方法を決定するために選択可能な、送信側ハンドオフ オプションの一覧を定義できます。\n+各エージェントで、タスクを前進させる方法を決定するために選択できる送信側ハンドオフ オプションの一覧を定義できます。\n \n ```python\n triage_agent = Agent(\n@@ -81,7 +81,7 @@ triage_agent = Agent(\n )\n ```\n \n-## エージェントのオーケストレーションを実行\n+## エージェントのオーケストレーションの実行\n \n ワークフローが実行され、トリアージ エージェントが 2 つの専門エージェント間で正しくルーティングすることを確認しましょう。\n \n@@ -95,7 +95,7 @@ async def main():\n \n ## ガードレールの追加\n \n-入力または出力に対して実行されるカスタム ガードレールを定義できます。\n+入力または出力に対して実行するカスタム ガードレールを定義できます。\n \n ```python\n from agents import GuardrailFunctionOutput, Agent, Runner\n@@ -121,9 +121,9 @@ async def homework_guardrail(ctx, agent, input_data):\n     )\n ```\n \n-## すべてを統合\n+## すべてを組み合わせる\n \n-すべてを組み合わせて、ハンドオフと入力ガードレールを使い、ワークフロー全体を実行しましょう。\n+すべてを組み合わせて、ハンドオフと入力ガードレールを使用し、ワークフロー全体を実行しましょう。\n \n ```python\n from agents import Agent, InputGuardrail, GuardrailFunctionOutput, Runner\n@@ -198,6 +198,6 @@ if __name__ == \"__main__\":\n \n より複雑なエージェント フローの構築方法を学びましょう。\n \n-- エージェントの設定について学ぶ: [エージェント](agents.md)\n-- エージェントの実行について学ぶ: [エージェントの実行](running_agents.md)\n-- ツールやガードレール、モデルについて学ぶ: [ツール](tools.md)、[ガードレール](guardrails.md)、[モデル](models/index.md)\n\\ No newline at end of file\n+- [エージェント](agents.md) の設定方法を学ぶ。\n+- [エージェントの実行](running_agents.md) について学ぶ。\n+- [ツール](tools.md)、[ガードレール](guardrails.md)、[モデル](models/index.md) について学ぶ。\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Fquickstart.md",
        "sha": "8aa11b070f853671e43de58df5b9a86d87d946be",
        "status": "modified"
      },
      {
        "additions": 44,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Frealtime%2Fguide.md",
        "changes": 88,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fja%2Frealtime%2Fguide.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 44,
        "filename": "docs/ja/realtime/guide.md",
        "patch": "@@ -4,65 +4,65 @@ search:\n ---\n # ガイド\n \n-このガイドでは、 OpenAI Agents SDK のリアルタイム機能を用いて、音声対応の AI エージェントを構築する方法を詳しく説明します。\n+このガイドでは、OpenAI Agents SDK の realtime 機能を用いて音声対応の AI エージェントを構築する方法を詳しく説明します。\n \n !!! warning \"ベータ機能\"\n-リアルタイム エージェントはベータ版です。実装の改良に伴い、互換性のない変更が発生する可能性があります。\n+Realtime エージェントはベータ版です。実装の改善に伴い、互換性のない変更が入る可能性があります。\n \n ## 概要\n \n-リアルタイム エージェントは、音声とテキストの入力をリアルタイムに処理し、リアルタイム音声で応答する会話フローを可能にします。 OpenAI の Realtime API と永続的な接続を維持し、低遅延で自然な音声会話や割り込みの優雅な処理を実現します。\n+Realtime エージェントは会話型のフローを可能にし、音声およびテキスト入力をリアルタイムに処理して、リアルタイム音声で応答します。OpenAI の Realtime API との永続的な接続を維持し、低レイテンシで自然な音声対話や割り込みへのスムーズな対応を実現します。\n \n ## アーキテクチャ\n \n-### 中核コンポーネント\n+### コアコンポーネント\n \n-リアルタイム システムはいくつかの主要コンポーネントで構成されます。\n+realtime システムは次の主要コンポーネントで構成されます:\n \n--   **RealtimeAgent**: instructions、tools、handoffs で構成された エージェント。\n+-   **RealtimeAgent**: instructions、tools、handoffs を設定したエージェントです。\n -   **RealtimeRunner**: 設定を管理します。`runner.run()` を呼び出してセッションを取得できます。\n--   **RealtimeSession**: 単一の対話セッション。通常、 ユーザー が会話を開始するたびに 1 つ作成し、会話が終了するまで維持します。\n--   **RealtimeModel**: 基盤となるモデル インターフェース（通常は OpenAI の WebSocket 実装）\n+-   **RealtimeSession**: 単一の対話セッションです。通常、ユーザーが会話を開始するたびに 1 つ作成し、会話が終わるまで保持します。\n+-   **RealtimeModel**: 基盤となるモデルのインターフェースです（通常は OpenAI の WebSocket 実装）。\n \n ### セッションフロー\n \n-一般的なリアルタイム セッションの流れは次のとおりです。\n+一般的な realtime セッションは次のフローに従います:\n \n-1. instructions、tools、handoffs を用いて **RealtimeAgent を作成** します。\n-2. エージェントと設定オプションで **RealtimeRunner をセットアップ** します。\n-3. `await runner.run()` を使用して **セッションを開始** します。これは RealtimeSession を返します。\n-4. `send_audio()` または `send_message()` を使って **音声またはテキスト メッセージを送信** します。\n-5. セッションを反復処理して **イベントをリッスン** します。イベントには音声出力、文字起こし、ツール呼び出し、ハンドオフ、エラーが含まれます。\n-6. ユーザー がエージェントの発話に重ねて話す **割り込みを処理** します。これにより現在の音声生成は自動的に停止します。\n+1. **RealtimeAgent を作成** し、instructions、tools、handoffs を設定します。\n+2. **RealtimeRunner をセットアップ** し、エージェントと設定オプションを指定します。\n+3. **セッションを開始** します。`await runner.run()` を使用すると RealtimeSession が返ります。\n+4. **音声またはテキストメッセージを送信** します。`send_audio()` または `send_message()` を使用します。\n+5. **イベントをリッスン** します。セッションを反復処理して、音声出力、書き起こし、ツール呼び出し、ハンドオフ、エラーなどのイベントを受け取ります。\n+6. **割り込みを処理** します。ユーザーがエージェントの発話に被せた場合、現在の音声生成は自動で停止します。\n \n-セッションは会話履歴を保持し、リアルタイム モデルとの永続的接続を管理します。\n+セッションは会話履歴を保持し、realtime モデルとの永続的な接続を管理します。\n \n-## エージェント構成\n+## エージェント設定\n \n-RealtimeAgent は通常の Agent クラスと同様に動作しますが、いくつかの重要な違いがあります。完全な API の詳細は、[`RealtimeAgent`][agents.realtime.agent.RealtimeAgent] の API リファレンスをご参照ください。\n+RealtimeAgent は通常の Agent クラスと同様に動作しますが、いくつか重要な違いがあります。完全な API の詳細については、[`RealtimeAgent`][agents.realtime.agent.RealtimeAgent] の API リファレンスをご覧ください。\n \n-通常の エージェント との主な違い:\n+通常のエージェントとの主な違い:\n \n--   モデルの選択はエージェント レベルではなくセッション レベルで設定します。\n--   structured outputs は非対応です（`outputType` は未対応）。\n--   音声はエージェントごとに設定できますが、最初のエージェントが発話した後は変更できません。\n--   その他の機能（tools、handoffs、instructions）は同様に動作します。\n+-   モデルの選択はエージェントではなくセッションレベルで設定します。\n+-   structured output のサポートはありません（`outputType` はサポートされません）。\n+-   ボイスはエージェントごとに設定できますが、最初のエージェントが発話した後は変更できません。\n+-   その他の機能（tools、handoffs、instructions）は同様に機能します。\n \n-## セッション構成\n+## セッション設定\n \n ### モデル設定\n \n-セッション構成では、基盤となるリアルタイム モデルの動作を制御できます。モデル名（`gpt-realtime` など）、音声の選択（alloy、echo、fable、onyx、nova、shimmer）、および対応するモダリティ（テキストおよび/または音声）を設定できます。音声フォーマットは入力と出力の両方に設定でき、デフォルトは PCM16 です。\n+セッション設定では、基盤となる realtime モデルの動作を制御できます。モデル名（`gpt-realtime` など）、ボイス選択（alloy、echo、fable、onyx、nova、shimmer）、サポートするモダリティ（テキストおよび/または音声）を設定できます。音声フォーマットは入力と出力の両方で設定でき、デフォルトは PCM16 です。\n \n ### 音声設定\n \n-音声設定は、セッションが音声の入出力をどのように扱うかを制御します。Whisper などのモデルを使った入力音声の文字起こし、言語設定、ドメイン固有用語の精度を高めるための文字起こしプロンプトを設定できます。ターン検出では、エージェントがいつ応答を開始・終了すべきかを制御し、音声活動検出のしきい値、無音時間、検出された発話の前後パディングなどを設定できます。\n+音声設定では、セッションが音声入力と出力をどのように扱うかを制御します。Whisper などのモデルを使った入力音声の書き起こし、言語設定、ドメイン固有用語の精度を高めるための書き起こしプロンプトを設定できます。ターン検出設定では、エージェントがいつ応答を開始/停止すべきかを制御し、音声活動検出のしきい値、無音時間、検出された発話前後のパディングなどを指定できます。\n \n ## ツールと関数\n \n ### ツールの追加\n \n-通常の エージェント と同様に、リアルタイム エージェントは会話中に実行される 関数ツール をサポートします。\n+通常のエージェントと同様に、realtime エージェントは会話中に実行される 関数ツール をサポートします:\n \n ```python\n from agents import function_tool\n@@ -90,7 +90,7 @@ agent = RealtimeAgent(\n \n ### ハンドオフの作成\n \n-ハンドオフにより、専門化された エージェント 間で会話を転送できます。\n+ハンドオフにより、専門化されたエージェント間で会話を転送できます。\n \n ```python\n from agents.realtime import realtime_handoff\n@@ -119,22 +119,22 @@ main_agent = RealtimeAgent(\n \n ## イベント処理\n \n-セッションは、セッション オブジェクトを反復処理することでリッスンできるイベントをストリーミングします。イベントには、音声出力チャンク、文字起こし結果、ツール実行の開始・終了、エージェントのハンドオフ、エラーが含まれます。特に処理すべき主なイベントは以下です。\n+セッションはイベントをストリームし、セッションオブジェクトを反復処理することでそれらをリッスンできます。イベントには、音声出力チャンク、書き起こし結果、ツール実行の開始/終了、エージェントのハンドオフ、エラーが含まれます。重要なイベントは次のとおりです:\n \n -   **audio**: エージェントの応答からの Raw 音声データ\n--   **audio_end**: エージェントの発話が完了\n--   **audio_interrupted**: ユーザー によるエージェントの割り込み\n+-   **audio_end**: エージェントの発話が終了\n+-   **audio_interrupted**: ユーザーがエージェントを割り込み\n -   **tool_start/tool_end**: ツール実行のライフサイクル\n -   **handoff**: エージェントのハンドオフが発生\n -   **error**: 処理中にエラーが発生\n \n-完全なイベントの詳細は、[`RealtimeSessionEvent`][agents.realtime.events.RealtimeSessionEvent] を参照してください。\n+イベントの詳細は [`RealtimeSessionEvent`][agents.realtime.events.RealtimeSessionEvent] を参照してください。\n \n ## ガードレール\n \n-リアルタイム エージェントでサポートされるのは出力 ガードレール のみです。これらの ガードレール はデバウンスされ、リアルタイム生成中の性能問題を避けるために（毎語ではなく）定期的に実行されます。デフォルトのデバウンス長は 100 文字ですが、設定可能です。\n+realtime エージェントでサポートされるのは出力 ガードレール のみです。これらの ガードレール はデバウンスされ、リアルタイム生成中のパフォーマンス問題を避けるために（毎語ではなく）定期的に実行されます。デフォルトのデバウンス長は 100 文字ですが、設定可能です。\n \n-ガードレール は `RealtimeAgent` に直接アタッチするか、セッションの `run_config` 経由で提供できます。両方のソースからの ガードレール は一緒に実行されます。\n+ガードレールは `RealtimeAgent` に直接アタッチするか、セッションの `run_config` で指定できます。両方の経路から提供された ガードレール は同時に実行されます。\n \n ```python\n from agents.guardrail import GuardrailFunctionOutput, OutputGuardrail\n@@ -152,19 +152,19 @@ agent = RealtimeAgent(\n )\n ```\n \n-ガードレール がトリガーされると、`guardrail_tripped` イベントを生成し、エージェントの現在の応答を中断できます。デバウンスの挙動により、安全性とリアルタイム性能要件のバランスが取られます。テキスト エージェント と異なり、リアルタイム エージェントはガードレール が作動しても Exception をスローしません。\n+ガードレール がトリガーされると、`guardrail_tripped` イベントが生成され、エージェントの現在の応答を中断できます。デバウンス動作により、安全性とリアルタイム性能要件のバランスを取ります。テキストエージェントと異なり、realtime エージェントは ガードレール がトリップしても例外を送出しません。\n \n ## 音声処理\n \n-[`session.send_audio(audio_bytes)`][agents.realtime.session.RealtimeSession.send_audio] を使って音声をセッションに送信するか、[`session.send_message()`][agents.realtime.session.RealtimeSession.send_message] を使ってテキストを送信します。\n+[`session.send_audio(audio_bytes)`][agents.realtime.session.RealtimeSession.send_audio] を使用して音声をセッションに送信するか、[`session.send_message()`][agents.realtime.session.RealtimeSession.send_message] を使用してテキストを送信します。\n \n-音声出力については、`audio` イベントをリッスンして、選択した音声ライブラリで音声データを再生してください。ユーザー がエージェントを割り込んだ際に即座に再生を停止し、キューにある音声をクリアするため、`audio_interrupted` イベントも必ずリッスンしてください。\n+音声出力については、`audio` イベントをリッスンし、任意のオーディオライブラリで再生します。ユーザーがエージェントを割り込んだ際に即座に再生を停止し、キュー済みの音声をクリアするため、`audio_interrupted` イベントも必ずリッスンしてください。\n \n ## SIP 連携\n \n-[Realtime Calls API](https://platform.openai.com/docs/guides/realtime-sip) 経由で着信する電話にリアルタイム エージェントをアタッチできます。SDK は、SIP 上でメディアをネゴシエートしつつ同じエージェント フローを再利用する [`OpenAIRealtimeSIPModel`][agents.realtime.openai_realtime.OpenAIRealtimeSIPModel] を提供します。\n+[Realtime Calls API](https://platform.openai.com/docs/guides/realtime-sip) 経由で着信する電話に realtime エージェントを接続できます。SDK は [`OpenAIRealtimeSIPModel`][agents.realtime.openai_realtime.OpenAIRealtimeSIPModel] を提供しており、SIP 経由でメディアをネゴシエートしつつ、同じエージェントフローを再利用します。\n \n-使用するには、モデル インスタンスを runner に渡し、セッション開始時に SIP の `call_id` を指定します。コール ID は着信を通知する webhook により配信されます。\n+使用するには、ランナーにモデルインスタンスを渡し、セッション開始時に SIP の `call_id` を指定します。コール ID は着信を通知する webhook によって渡されます。\n \n ```python\n from agents.realtime import RealtimeAgent, RealtimeRunner\n@@ -187,19 +187,19 @@ async with await runner.run(\n         ...\n ```\n \n-発信者が切断すると SIP セッションは終了し、リアルタイム接続は自動的にクローズされます。完全なテレフォニーのコード例は、[`examples/realtime/twilio_sip`](https://github.com/openai/openai-agents-python/tree/main/examples/realtime/twilio_sip) を参照してください。\n+発信者が電話を切ると、SIP セッションは終了し、realtime 接続は自動的に閉じられます。完全なテレフォニーのコード例は [`examples/realtime/twilio_sip`](https://github.com/openai/openai-agents-python/tree/main/examples/realtime/twilio_sip) を参照してください。\n \n-## モデルへの直接アクセス\n+## 直接モデルアクセス\n \n-基盤となるモデルにアクセスして、カスタム リスナーを追加したり、高度な操作を実行したりできます。\n+基盤となるモデルにアクセスして、カスタムリスナーを追加したり高度な操作を実行したりできます:\n \n ```python\n # Add a custom listener to the model\n session.model.add_listener(my_custom_listener)\n ```\n \n-これにより、接続をより低レベルで制御する必要がある高度なユースケースに向けて、[`RealtimeModel`][agents.realtime.model.RealtimeModel] インターフェースへ直接アクセスできます。\n+これにより、接続を低レベルで制御する必要がある高度なユースケース向けに、[`RealtimeModel`][agents.realtime.model.RealtimeModel] インターフェースへ直接アクセスできます。\n \n ## コード例\n \n-完全に動作するコード例は、[examples/realtime directory](https://github.com/openai/openai-agents-python/tree/main/examples/realtime) を参照してください。UI コンポーネントの有無それぞれのデモが含まれています。\n\\ No newline at end of file\n+動作する完全なコード例は、[examples/realtime ディレクトリ](https://github.com/openai/openai-agents-python/tree/main/examples/realtime) を参照してください。UI コンポーネントの有無それぞれのデモを含みます。\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Frealtime%2Fguide.md",
        "sha": "3a07af9f64eb80b2e55fedb36d992aa22aec7c7d",
        "status": "modified"
      },
      {
        "additions": 25,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Frealtime%2Fquickstart.md",
        "changes": 50,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fja%2Frealtime%2Fquickstart.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 25,
        "filename": "docs/ja/realtime/quickstart.md",
        "patch": "@@ -4,16 +4,16 @@ search:\n ---\n # クイックスタート\n \n-Realtime エージェント は、OpenAI の Realtime API を使用して AI エージェント との音声会話を可能にします。ここでは、最初の リアルタイム音声エージェント を作成する手順を説明します。\n+Realtime エージェントは、OpenAI の Realtime API を使って AI エージェントとの音声会話を可能にします。このガイドでは、最初のリアルタイム音声エージェントの作成手順を説明します。\n \n !!! warning \"ベータ機能\"\n-Realtime エージェント はベータ版です。実装の改善に伴い、破壊的な変更が入る可能性があります。\n+Realtime エージェントはベータ版です。実装の改善に伴い、互換性が壊れる変更が発生する可能性があります。\n \n ## 前提条件\n \n-- Python 3.9 以上\n-- OpenAI API キー\n-- OpenAI Agents SDK の基本的な知識\n+-   Python 3.9 以上\n+-   OpenAI API キー\n+-   OpenAI Agents SDK の基本的な知識\n \n ## インストール\n \n@@ -23,7 +23,7 @@ Realtime エージェント はベータ版です。実装の改善に伴い、\n pip install openai-agents\n ```\n \n-## 最初の Realtime エージェント の作成\n+## 最初の Realtime エージェントの作成\n \n ### 1. 必要なコンポーネントのインポート\n \n@@ -32,7 +32,7 @@ import asyncio\n from agents.realtime import RealtimeAgent, RealtimeRunner\n ```\n \n-### 2. Realtime エージェント の作成\n+### 2. Realtime エージェントの作成\n \n ```python\n agent = RealtimeAgent(\n@@ -111,7 +111,7 @@ def _truncate_str(s: str, max_length: int) -> str:\n \n ## 完全な例\n \n-動作する完全なサンプルコードはこちらです:\n+動作する完全な例はこちらです:\n \n ```python\n import asyncio\n@@ -192,40 +192,40 @@ if __name__ == \"__main__\":\n \n ### モデル設定\n \n-- `model_name`: 利用可能なリアルタイムモデルから選択 (例: `gpt-realtime`)\n-- `voice`: 音声の選択 (`alloy`, `echo`, `fable`, `onyx`, `nova`, `shimmer`)\n-- `modalities`: テキストまたは音声を有効化 (`[\"text\"]` または `[\"audio\"]`)\n+-   `model_name`: 利用可能なリアルタイムモデルから選択 (例: `gpt-realtime`)\n+-   `voice`: 音声を選択 (`alloy`, `echo`, `fable`, `onyx`, `nova`, `shimmer`)\n+-   `modalities`: テキストまたは音声を有効化 (`[\"text\"]` または `[\"audio\"]`)\n \n ### オーディオ設定\n \n-- `input_audio_format`: 入力音声の形式 (`pcm16`, `g711_ulaw`, `g711_alaw`)\n-- `output_audio_format`: 出力音声の形式\n-- `input_audio_transcription`: 文字起こしの設定\n+-   `input_audio_format`: 入力音声の形式 (`pcm16`, `g711_ulaw`, `g711_alaw`)\n+-   `output_audio_format`: 出力音声の形式\n+-   `input_audio_transcription`: 文字起こし設定\n \n ### ターン検出\n \n-- `type`: 検出方法 (`server_vad`, `semantic_vad`)\n-- `threshold`: 音声活動のしきい値 (0.0–1.0)\n-- `silence_duration_ms`: ターン終了を検出する無音時間\n-- `prefix_padding_ms`: 発話前のオーディオパディング\n+-   `type`: 検出方法 (`server_vad`, `semantic_vad`)\n+-   `threshold`: 音声活動のしきい値 (0.0–1.0)\n+-   `silence_duration_ms`: ターン終了を検出する無音時間\n+-   `prefix_padding_ms`: 発話前の音声パディング\n \n ## 次のステップ\n \n-- [Realtime エージェント について詳しく見る](guide.md)\n-- 動作するサンプルは [examples/realtime](https://github.com/openai/openai-agents-python/tree/main/examples/realtime) フォルダーを参照してください\n-- エージェント にツールを追加\n-- エージェント 間の ハンドオフ を実装\n-- 安全のための ガードレール を設定\n+-   [Realtime エージェントの詳細を見る](guide.md)\n+-   [examples/realtime](https://github.com/openai/openai-agents-python/tree/main/examples/realtime) フォルダーの動作する例を確認\n+-   エージェントにツールを追加\n+-   エージェント間のハンドオフを実装\n+-   安全のためにガードレールを設定\n \n ## 認証\n \n-OpenAI API キーが環境に設定されていることを確認してください:\n+環境に OpenAI API キーが設定されていることを確認してください:\n \n ```bash\n export OPENAI_API_KEY=\"your-api-key-here\"\n ```\n \n-または、セッション作成時に直接渡すこともできます:\n+または、セッション作成時に直接渡します:\n \n ```python\n session = await runner.run(model_config={\"api_key\": \"your-api-key\"})",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Frealtime%2Fquickstart.md",
        "sha": "f679e18485e43b458910f7cb445b80e1b1f72714",
        "status": "modified"
      },
      {
        "additions": 15,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Frelease.md",
        "changes": 30,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fja%2Frelease.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 15,
        "filename": "docs/ja/release.md",
        "patch": "@@ -4,17 +4,17 @@ search:\n ---\n # リリースプロセス/変更履歴\n \n-本プロジェクトは、`0.Y.Z` 形式のセマンティックバージョニングを一部変更して採用しています。先頭の `0` は、この SDK がまだ急速に進化していることを示します。各コンポーネントの更新は次のとおりです。\n+本プロジェクトは、`0.Y.Z` 形式のセマンティックバージョニングを一部変更して採用しています。先頭の `0` は SDK がまだ急速に進化していることを示します。各コンポーネントは次のように増分します。\n \n-## マイナー ( `Y` ) バージョン\n+## マイナー (`Y`) バージョン\n \n-ベータではない公開インターフェースに対する **破壊的変更** がある場合、マイナーバージョン `Y` を増やします。たとえば、`0.0.x` から `0.1.x` への更新には破壊的変更が含まれる可能性があります。\n+ベータではない公開インターフェースに対する **破壊的変更** がある場合、マイナーバージョン `Y` を上げます。たとえば、`0.0.x` から `0.1.x` への移行には破壊的変更が含まれる可能性があります。\n \n-破壊的変更を避けたい場合は、プロジェクトで `0.0.x` バージョンにピン留めすることをおすすめします。\n+破壊的変更を避けたい場合は、プロジェクトで `0.0.x` バージョンに固定することをおすすめします。\n \n-## パッチ ( `Z` ) バージョン\n+## パッチ (`Z`) バージョン\n \n-後方互換な変更については `Z` を増やします。\n+破壊的でない変更の場合に `Z` を増分します。\n \n - バグ修正\n - 新機能\n@@ -25,28 +25,28 @@ search:\n \n ### 0.6.0\n \n-このバージョンでは、既定のハンドオフ履歴が、生の ユーザー/アシスタント のやり取りを公開するのではなく、単一のアシスタントメッセージにまとめられ、下流の エージェント に簡潔で予測可能な要約を提供します。\n-- 既存の単一メッセージのハンドオフのトランスクリプトは、既定で `<CONVERSATION HISTORY>` ブロックの前に \"For context, here is the conversation so far between the user and the previous agent:\" から始まり、下流の エージェント が明確にラベル付けされた要約を取得できるようになりました\n+このバージョンでは、既定のハンドオフ履歴は、raw な ユーザー/アシスタントのターンを露出する代わりに、単一のアシスタントメッセージにまとめて下流の エージェント に簡潔で予測可能な要約を提供します。\n+- 既存の単一メッセージのハンドオフのトランスクリプトは、既定で `<CONVERSATION HISTORY>` ブロックの前に \"For context, here is the conversation so far between the user and the previous agent:\" から始まるようになり、下流の エージェント が明確にラベル付けされた要約を受け取れるようにします\n \n ### 0.5.0\n \n-このバージョンでは、目に見える破壊的変更は導入していませんが、新機能と内部の重要な更新がいくつか含まれます。\n+このバージョンには目に見える破壊的変更はありませんが、新機能と内部の重要な更新が含まれます。\n \n-- `RealtimeRunner` が [SIP protocol connections](https://platform.openai.com/docs/guides/realtime-sip) を扱えるようにサポートを追加\n-- Python 3.14 との互換性のために `Runner#run_sync` の内部ロジックを大幅に改訂\n+- `RealtimeRunner` が [SIP プロトコル接続](https://platform.openai.com/docs/guides/realtime-sip) を扱えるようサポートを追加\n+- Python 3.14 互換性のために `Runner#run_sync` の内部ロジックを大幅に改訂\n \n ### 0.4.0\n \n-このバージョンでは、[openai](https://pypi.org/project/openai/) パッケージの v1.x バージョンはサポートされなくなりました。この SDK とともに openai v2.x を使用してください。\n+このバージョンでは、[openai](https://pypi.org/project/openai/) パッケージの v1.x バージョンはサポート対象外になりました。本 SDK と併せて openai v2.x を使用してください。\n \n ### 0.3.0\n \n-このバージョンでは、Realtime API のサポートが gpt-realtime モデルおよびその API インターフェース (GA バージョン) に移行します。\n+このバージョンでは、Realtime API サポートが gpt-realtime モデルおよびその API インターフェース（ GA 版）に移行します。\n \n ### 0.2.0\n \n-このバージョンでは、これまで `Agent` を引数として受け取っていた箇所の一部が、代わりに `AgentBase` を引数として受け取るようになりました。例として、MCP サーバーの `list_tools()` 呼び出しがあります。これは型に関する変更のみであり、引き続き `Agent` オブジェクトを受け取ります。更新するには、`Agent` を `AgentBase` に置き換えて型エラーを修正してください。\n+このバージョンでは、これまで `Agent` を引数に取っていた一部の箇所が、代わりに `AgentBase` を引数に取るようになりました。たとえば、MCP サーバーでの `list_tools()` 呼び出しです。これは純粋に型に関する変更であり、引き続き `Agent` オブジェクトを受け取ります。更新の際は、`Agent` を `AgentBase` に置き換えて型エラーを修正するだけで問題ありません。\n \n ### 0.1.0\n \n-このバージョンでは、[`MCPServer.list_tools()`][agents.mcp.server.MCPServer] に 2 つの新しいパラメーター `run_context` と `agent` が追加されました。`MCPServer` を継承するすべてのクラスにこれらのパラメーターを追加する必要があります。\n\\ No newline at end of file\n+このバージョンでは、[`MCPServer.list_tools()`][agents.mcp.server.MCPServer] に新しいパラメーターが 2 つ追加されました: `run_context` と `agent`。`MCPServer` を継承するすべてのクラスにこれらのパラメーターを追加する必要があります。\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Frelease.md",
        "sha": "f994a5c07c298f98cf62005706fb3de9ba54779b",
        "status": "modified"
      },
      {
        "additions": 2,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Frepl.md",
        "changes": 4,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fja%2Frepl.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 2,
        "filename": "docs/ja/repl.md",
        "patch": "@@ -4,7 +4,7 @@ search:\n ---\n # REPL ユーティリティ\n \n-この SDK は、ターミナル上でエージェントの動作を素早くインタラクティブにテストできる `run_demo_loop` を提供します。\n+この SDK は、ターミナル上でエージェントの挙動を素早く対話的にテストできる `run_demo_loop` を提供します。\n \n ```python\n import asyncio\n@@ -18,6 +18,6 @@ if __name__ == \"__main__\":\n     asyncio.run(main())\n ```\n \n-`run_demo_loop` はループでユーザー入力を促し、ターン間で会話履歴を保持します。デフォルトでは、生成されるモデル出力をそのままストリーミングします。上記の例を実行すると、run_demo_loop はインタラクティブなチャットセッションを開始します。あなたの入力を継続的に求め、ターン間の会話全体の履歴を記憶し（そのためエージェントは何が議論されたかを把握できます）、生成されると同時にエージェントの応答をリアルタイムで自動的にストリーミングします。\n+`run_demo_loop` は、ループでユーザー入力を促し、ターン間で会話履歴を保持します。デフォルトでは、生成されたそばからモデルの出力をストリーミングします。上記の例を実行すると、`run_demo_loop` が対話型のチャットセッションを開始します。継続的に入力を求め、ターン間で全会話履歴を記憶するため（エージェントは何が話されたかを把握できます）、生成と同時にエージェントの応答をリアルタイムで自動的にストリーミングします。\n \n このチャットセッションを終了するには、`quit` または `exit` と入力して Enter を押すか、`Ctrl-D` キーボードショートカットを使用してください。\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Frepl.md",
        "sha": "483d3edbd59cc4679be3ff51356d0f9a2e084540",
        "status": "modified"
      },
      {
        "additions": 18,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Fresults.md",
        "changes": 36,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fja%2Fresults.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 18,
        "filename": "docs/ja/results.md",
        "patch": "@@ -2,55 +2,55 @@\n search:\n   exclude: true\n ---\n-# 実行結果\n+# 結果\n \n-`Runner.run` メソッドを呼び出すと、次のいずれかが得られます。\n+`Runner.run` メソッドを呼び出すと、次のいずれかが返されます。\n \n -   [`RunResult`][agents.result.RunResult]（`run` または `run_sync` を呼び出した場合）\n -   [`RunResultStreaming`][agents.result.RunResultStreaming]（`run_streamed` を呼び出した場合）\n \n-これらはいずれも [`RunResultBase`][agents.result.RunResultBase] を継承しており、ほとんどの有用な情報はここに含まれます。\n+どちらも [`RunResultBase`][agents.result.RunResultBase] を継承しており、多くの有用な情報はここに含まれます。\n \n ## 最終出力\n \n-[`final_output`][agents.result.RunResultBase.final_output] プロパティには、最後に実行されたエージェントの最終出力が含まれます。これは次のいずれかです。\n+[`final_output`][agents.result.RunResultBase.final_output] プロパティには、最後に実行されたエージェントの最終出力が含まれます。次のいずれかです。\n \n -   最後のエージェントに `output_type` が定義されていない場合は `str`\n--   エージェントに出力タイプが定義されている場合は `last_agent.output_type` 型のオブジェクト\n+-   エージェントに出力型が定義されている場合は `last_agent.output_type` 型のオブジェクト\n \n !!! note\n \n-    `final_output` の型は `Any` です。ハンドオフ があるため、これを静的に型付けすることはできません。ハンドオフ が起きると、どのエージェントでも最後のエージェントになり得るため、可能な出力タイプの集合を静的には把握できないからです。\n+    `final_output` の型は `Any` です。ハンドオフのため、静的型付けはできません。ハンドオフが発生する場合、どのエージェントが最後になるか分からないため、取り得る出力型の集合を静的には特定できません。\n \n ## 次ターンの入力\n \n-[`result.to_input_list()`][agents.result.RunResultBase.to_input_list] を使用すると、エージェントの実行中に生成されたアイテムを、あなたが提供した元の入力に連結した入力リストへと変換できます。これにより、あるエージェント実行の出力を別の実行に渡したり、ループで実行して毎回新しい ユーザー 入力を追加したりするのが容易になります。\n+[`result.to_input_list()`][agents.result.RunResultBase.to_input_list] を使うと、結果を入力リストに変換し、あなたが提供した元の入力に、エージェントの実行中に生成されたアイテムを連結できます。これにより、あるエージェント実行の出力を別の実行に渡したり、ループで実行して毎回新しい ユーザー 入力を追加したりするのが便利になります。\n \n ## 最後のエージェント\n \n-[`last_agent`][agents.result.RunResultBase.last_agent] プロパティには、最後に実行されたエージェントが含まれます。アプリケーションによっては、これは次回 ユーザー が入力する際に有用なことが多いです。たとえば、一次トリアージのエージェントが言語特化のエージェントにハンドオフ する構成の場合、最後のエージェントを保存して、次に ユーザー がエージェントにメッセージを送る際に再利用できます。\n+[`last_agent`][agents.result.RunResultBase.last_agent] プロパティには、最後に実行されたエージェントが含まれます。アプリケーションによっては、次回 ユーザー が入力する際にこれが役立つことがよくあります。例えば、フロントラインのトリアージ エージェントが言語別のエージェントにハンドオフする場合、最後のエージェントを保存しておき、次回 ユーザー がメッセージを送る際に再利用できます。\n \n ## 新規アイテム\n \n-[`new_items`][agents.result.RunResultBase.new_items] プロパティには、実行中に生成された新しいアイテムが含まれます。アイテムは [`RunItem`][agents.items.RunItem] です。Run item は、LLM によって生成された raw アイテムをラップします。\n+[`new_items`][agents.result.RunResultBase.new_items] プロパティには、実行中に生成された新規アイテムが含まれます。アイテムは [`RunItem`][agents.items.RunItem] です。Run item は、LLM が生成した生のアイテムをラップします。\n \n--   [`MessageOutputItem`][agents.items.MessageOutputItem] は LLM からのメッセージを示します。raw アイテムは生成されたメッセージです。\n--   [`HandoffCallItem`][agents.items.HandoffCallItem] は LLM がハンドオフ ツールを呼び出したことを示します。raw アイテムは LLM からのツール呼び出しアイテムです。\n--   [`HandoffOutputItem`][agents.items.HandoffOutputItem] は ハンドオフ が発生したことを示します。raw アイテムは ハンドオフ ツール呼び出しに対するツールのレスポンスです。アイテムからソース/ターゲットのエージェントにもアクセスできます。\n--   [`ToolCallItem`][agents.items.ToolCallItem] は LLM がツールを呼び出したことを示します。\n--   [`ToolCallOutputItem`][agents.items.ToolCallOutputItem] は ツールが呼び出されたことを示します。raw アイテムはツールのレスポンスです。アイテムからツール出力にもアクセスできます。\n--   [`ReasoningItem`][agents.items.ReasoningItem] は LLM からの推論アイテムを示します。raw アイテムは生成された推論です。\n+-   [`MessageOutputItem`][agents.items.MessageOutputItem] は LLM からのメッセージを示します。生のアイテムは生成されたメッセージです。\n+-   [`HandoffCallItem`][agents.items.HandoffCallItem] は、LLM がハンドオフ ツールを呼び出したことを示します。生のアイテムは LLM からのツール呼び出しアイテムです。\n+-   [`HandoffOutputItem`][agents.items.HandoffOutputItem] は、ハンドオフが発生したことを示します。生のアイテムはハンドオフ ツール呼び出しに対するツール応答です。アイテムから送信元 / 宛先のエージェントにもアクセスできます。\n+-   [`ToolCallItem`][agents.items.ToolCallItem] は、LLM がツールを呼び出したことを示します。\n+-   [`ToolCallOutputItem`][agents.items.ToolCallOutputItem] は、ツールが呼び出されたことを示します。生のアイテムはツールの応答です。アイテムからツール出力にもアクセスできます。\n+-   [`ReasoningItem`][agents.items.ReasoningItem] は、LLM からの推論アイテムを示します。生のアイテムは生成された推論です。\n \n ## その他の情報\n \n ### ガードレールの実行結果\n \n-[`input_guardrail_results`][agents.result.RunResultBase.input_guardrail_results] と [`output_guardrail_results`][agents.result.RunResultBase.output_guardrail_results] プロパティには、存在する場合、ガードレールの実行結果が含まれます。ガードレールの実行結果には、ログや保存を行いたい有用な情報が含まれることがあるため、これらを利用できるようにしています。\n+[`input_guardrail_results`][agents.result.RunResultBase.input_guardrail_results] と [`output_guardrail_results`][agents.result.RunResultBase.output_guardrail_results] プロパティには、該当する場合、ガードレールの実行結果が含まれます。ガードレールの実行結果には、ログ保存したい有用な情報が含まれることがあるため、参照できるようにしています。\n \n-### Raw 応答\n+### 生の応答\n \n [`raw_responses`][agents.result.RunResultBase.raw_responses] プロパティには、LLM によって生成された [`ModelResponse`][agents.items.ModelResponse] が含まれます。\n \n ### 元の入力\n \n-[`input`][agents.result.RunResultBase.input] プロパティには、`run` メソッドに提供した元の入力が含まれます。ほとんどの場合これは不要ですが、必要に応じて参照できるようになっています。\n\\ No newline at end of file\n+[`input`][agents.result.RunResultBase.input] プロパティには、`run` メソッドに渡した元の入力が含まれます。多くの場合これは不要ですが、必要に応じて参照できます。\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Fresults.md",
        "sha": "687738c846840858ea7598be639d840ecf17d00b",
        "status": "modified"
      },
      {
        "additions": 50,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Frunning_agents.md",
        "changes": 100,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fja%2Frunning_agents.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 50,
        "filename": "docs/ja/running_agents.md",
        "patch": "@@ -4,10 +4,10 @@ search:\n ---\n # エージェントの実行\n \n-[`Runner`][agents.run.Runner] クラス経由で エージェント を実行できます。方法は 3 つあります。\n+エージェントは [`Runner`][agents.run.Runner] クラスで実行できます。方法は 3 つあります。\n \n 1. [`Runner.run()`][agents.run.Runner.run]: 非同期で実行し、[`RunResult`][agents.result.RunResult] を返します。\n-2. [`Runner.run_sync()`][agents.run.Runner.run_sync]: 同期メソッドで、内部的に `.run()` を実行します。\n+2. [`Runner.run_sync()`][agents.run.Runner.run_sync]: 同期メソッドで、内部的には `.run()` を実行します।\n 3. [`Runner.run_streamed()`][agents.run.Runner.run_streamed]: 非同期で実行し、[`RunResultStreaming`][agents.result.RunResultStreaming] を返します。LLM を ストリーミング モードで呼び出し、受信したイベントを逐次 ストリーミング します。\n \n ```python\n@@ -23,59 +23,59 @@ async def main():\n     # Infinite loop's dance\n ```\n \n-詳細は [結果ガイド](results.md) を参照してください。\n+詳しくは [結果ガイド](results.md) をご覧ください。\n \n ## エージェントループ\n \n-`Runner` の run メソッドを使うとき、開始 エージェント と入力を渡します。入力は文字列（ユーザー メッセージとして扱われます）または入力アイテムのリスト（ OpenAI Responses API のアイテム）を渡せます。\n+`Runner` の run メソッドでは、開始エージェントと入力を渡します。入力は文字列（ユーザー メッセージとして扱われます）または入力アイテムのリスト（OpenAI Responses API のアイテム）を指定できます。\n \n-ランナーは次のループを実行します。\n+runner は次のループを実行します。\n \n-1. 現在の エージェント と現在の入力で LLM を呼び出します。\n+1. 現在のエージェントと現在の入力で LLM を呼び出します。\n 2. LLM が出力を生成します。\n-    1. LLM が `final_output` を返した場合、ループを終了し結果を返します。\n-    2. LLM が ハンドオフ を行った場合、現在の エージェント と入力を更新し、ループを再実行します。\n+    1. LLM が `final_output` を返した場合、ループを終了して結果を返します。\n+    2. LLM が ハンドオフ を行った場合、現在のエージェントと入力を更新し、ループを再実行します。\n     3. LLM が ツール呼び出し を生成した場合、それらを実行して結果を追加し、ループを再実行します。\n 3. 渡された `max_turns` を超えた場合、[`MaxTurnsExceeded`][agents.exceptions.MaxTurnsExceeded] 例外を送出します。\n \n !!! note\n \n-    LLM の出力が「最終出力 (final output)」と見なされる条件は、望ましい型のテキスト出力を生成し、ツール呼び出しが存在しないことです。\n+    LLM の出力が「最終出力」と見なされる条件は、目的の型のテキスト出力を生成し、ツール呼び出しがないことです。\n \n ## ストリーミング\n \n-ストリーミング を使うと、LLM の実行中に ストリーミング イベントを受け取れます。ストリームが完了すると、[`RunResultStreaming`][agents.result.RunResultStreaming] に実行の完全な情報（生成されたすべての新規出力を含む）が格納されます。ストリーミング イベントは `.stream_events()` で取得できます。詳細は [ストリーミング ガイド](streaming.md) を参照してください。\n+ストリーミング を使用すると、LLM の実行中に ストリーミング イベントを受け取れます。ストリームが完了すると、[`RunResultStreaming`][agents.result.RunResultStreaming] に、その実行で生成されたすべての新規出力を含む完全な情報が格納されます。ストリーミング イベントは `.stream_events()` を呼び出して取得できます。詳しくは [ストリーミング ガイド](streaming.md) をご覧ください。\n \n-## 実行設定\n+## 実行設定 (Run config)\n \n-`run_config` パラメーターで、エージェント実行のグローバル設定を構成できます。\n+`run_config` パラメーターでは、エージェント実行のグローバル設定を構成できます。\n \n--   [`model`][agents.run.RunConfig.model]: 各 Agent の `model` に関係なく、使用するグローバルな LLM モデルを設定します。\n--   [`model_provider`][agents.run.RunConfig.model_provider]: モデル名を解決するモデルプロバイダーで、既定は OpenAI です。\n--   [`model_settings`][agents.run.RunConfig.model_settings]: エージェント固有の設定を上書きします。たとえば、グローバルな `temperature` や `top_p` を設定できます。\n--   [`input_guardrails`][agents.run.RunConfig.input_guardrails], [`output_guardrails`][agents.run.RunConfig.output_guardrails]: すべての実行に含める入力/出力 ガードレール のリストです。\n--   [`handoff_input_filter`][agents.run.RunConfig.handoff_input_filter]: ハンドオフ に既にフィルターがない場合に適用されるグローバル入力フィルターです。入力フィルターを使うと、新しい エージェント に送る入力を編集できます。詳細は [`Handoff.input_filter`][agents.handoffs.Handoff.input_filter] のドキュメントを参照してください。\n--   [`nest_handoff_history`][agents.run.RunConfig.nest_handoff_history]: `True`（デフォルト）の場合、次の エージェント を呼び出す前に、それまでのやり取りを 1 つのアシスタント メッセージに折りたたみます。ヘルパーは内容を `<CONVERSATION HISTORY>` ブロック内に配置し、後続の ハンドオフ が発生するたびに新しいターンを追記します。生の (raw) 文字起こしをそのまま渡したい場合は `False` にするか、カスタムの ハンドオフ フィルターを指定してください。いずれの [`Runner` のメソッド](agents.run.Runner) でも、未指定時は自動的に `RunConfig` を作成するため、クイックスタートや code examples はこの既定を自動で利用し、明示的な [`Handoff.input_filter`][agents.handoffs.Handoff.input_filter] コールバックがある場合は引き続きそれが優先されます。個々の ハンドオフ は、[`Handoff.nest_handoff_history`][agents.handoffs.Handoff.nest_handoff_history] でこの設定を上書きできます。\n--   [`handoff_history_mapper`][agents.run.RunConfig.handoff_history_mapper]: 省略可能な呼び出し可能オブジェクトで、`nest_handoff_history` が `True` のときに正規化された文字起こし（履歴 + ハンドオフ アイテム）を受け取ります。次の エージェント に転送する入力アイテムのリストをそのまま返す必要があり、完全な ハンドオフ フィルターを書かずに組み込み要約を置き換えられます。\n+-   [`model`][agents.run.RunConfig.model]: 各 Agent の `model` 設定に関係なく、使用するグローバルな LLM モデルを設定します。\n+-   [`model_provider`][agents.run.RunConfig.model_provider]: モデル名を解決するためのモデルプロバイダー。デフォルトは OpenAI です。\n+-   [`model_settings`][agents.run.RunConfig.model_settings]: エージェント固有の設定を上書きします。例えば、グローバルな `temperature` や `top_p` を設定できます。\n+-   [`input_guardrails`][agents.run.RunConfig.input_guardrails], [`output_guardrails`][agents.run.RunConfig.output_guardrails]: すべての実行に含める入力または出力 ガードレール のリスト。\n+-   [`handoff_input_filter`][agents.run.RunConfig.handoff_input_filter]: ハンドオフ に既にフィルターがない場合に適用するグローバルな入力フィルター。入力フィルターは、新しいエージェントに送る入力を編集できます。詳細は [`Handoff.input_filter`][agents.handoffs.Handoff.input_filter] のドキュメントをご覧ください。\n+-   [`nest_handoff_history`][agents.run.RunConfig.nest_handoff_history]: `True`（デフォルト）の場合、runner は次のエージェントを呼び出す前に、これまでのやり取りを 1 つの assistant メッセージに折りたたみます。ヘルパーは内容を `<CONVERSATION HISTORY>` ブロック内に配置し、以降の ハンドオフ ごとに新しいターンを追記します。生の transcript をそのまま渡したい場合は `False` にするか、独自の ハンドオフ フィルターを指定してください。すべての [`Runner` methods](agents.run.Runner) は、未指定時に自動的に `RunConfig` を作成するため、クイックスタートや code examples はこのデフォルトを自動的に使用し、明示的な [`Handoff.input_filter`][agents.handoffs.Handoff.input_filter] コールバックは引き続き優先されます。個々の ハンドオフ は [`Handoff.nest_handoff_history`][agents.handoffs.Handoff.nest_handoff_history] でこの設定を上書きできます。\n+-   [`handoff_history_mapper`][agents.run.RunConfig.handoff_history_mapper]: `nest_handoff_history` が `True` のときに正規化された transcript（履歴 + ハンドオフ アイテム）を受け取り、次のエージェントに渡す入力アイテムのリストをそのまま返す任意の呼び出し可能オブジェクト。完全な ハンドオフ フィルターを書かずに、組み込みの要約を差し替えられます。\n -   [`tracing_disabled`][agents.run.RunConfig.tracing_disabled]: 実行全体の [トレーシング](tracing.md) を無効化します。\n--   [`trace_include_sensitive_data`][agents.run.RunConfig.trace_include_sensitive_data]: LLM やツール呼び出しの入出力など、機微なデータをトレースに含めるかどうかを設定します。\n--   [`workflow_name`][agents.run.RunConfig.workflow_name], [`trace_id`][agents.run.RunConfig.trace_id], [`group_id`][agents.run.RunConfig.group_id]: 実行のトレーシング ワークフロー名、トレース ID、トレース グループ ID を設定します。少なくとも `workflow_name` の設定を推奨します。グループ ID は任意で、複数の実行にまたがってトレースを関連付けできます。\n--   [`trace_metadata`][agents.run.RunConfig.trace_metadata]: すべてのトレースに含めるメタデータです。\n+-   [`trace_include_sensitive_data`][agents.run.RunConfig.trace_include_sensitive_data]: LLM やツール呼び出しの入出力など、機微なデータをトレースに含めるかを設定します。\n+-   [`workflow_name`][agents.run.RunConfig.workflow_name], [`trace_id`][agents.run.RunConfig.trace_id], [`group_id`][agents.run.RunConfig.group_id]: 実行のトレーシング ワークフロー名、トレース ID、トレース グループ ID を設定します。少なくとも `workflow_name` の設定を推奨します。グループ ID は任意で、複数の実行に跨るトレースをリンクできます。\n+-   [`trace_metadata`][agents.run.RunConfig.trace_metadata]: すべてのトレースに含めるメタデータ。\n \n-デフォルトでは、ある エージェント が別の エージェント に ハンドオフ する際、SDK はそれまでのターンを単一のアシスタント要約メッセージ内にネストします。これにより、繰り返しのアシスタント メッセージが減り、新しい エージェント が迅速にスキャンできる単一ブロック内に完全な文字起こしが維持されます。従来の動作に戻したい場合は、`RunConfig(nest_handoff_history=False)` を渡すか、会話を必要どおりにそのまま転送する `handoff_input_filter`（または `handoff_history_mapper`）を指定してください。特定の ハンドオフ でオプトアウト（またはオプトイン）することもでき、その場合は `handoff(..., nest_handoff_history=False)` または `True` を設定します。カスタム マッパーを書かずに生成される要約に使うラッパーテキストを変更するには、[`set_conversation_history_wrappers`][agents.handoffs.set_conversation_history_wrappers] を呼び出してください（既定に戻すには [`reset_conversation_history_wrappers`][agents.handoffs.reset_conversation_history_wrappers]）。\n+デフォルトでは、SDK はあるエージェントが別のエージェントに ハンドオフ する際、以前のターンを 1 つの assistant 要約メッセージ内にネストします。これにより assistant メッセージの重複が減り、全文 transcript が 1 つのブロック内に収まり、新しいエージェントが高速にスキャンできます。レガシー動作に戻したい場合は、`RunConfig(nest_handoff_history=False)` を渡すか、会話を必要なとおりに転送する `handoff_input_filter`（または `handoff_history_mapper`）を指定してください。特定の ハンドオフ でのみオプトアウト（またはイン）するには、`handoff(..., nest_handoff_history=False)` または `True` を設定します。カスタム マッパーを書かずに生成される要約に使われるラッパー文言を変更するには、[`set_conversation_history_wrappers`][agents.handoffs.set_conversation_history_wrappers] を呼び出してください（デフォルトに戻すには [`reset_conversation_history_wrappers`][agents.handoffs.reset_conversation_history_wrappers]）。\n \n-## 会話/チャットスレッド\n+## 会話 / チャットスレッド\n \n-いずれかの run メソッドを呼び出すと、1 つ以上の エージェント（したがって 1 回以上の LLM 呼び出し）が動作する可能性がありますが、チャット会話の 1 回の論理ターンを表します。例:\n+任意の run メソッドの呼び出しは、1 つ以上のエージェントの実行（つまり 1 回以上の LLM 呼び出し）になる場合がありますが、チャット会話における 1 つの論理的なターンを表します。例:\n \n-1. ユーザー のターン: ユーザー がテキストを入力\n-2. ランナーの実行: 最初の エージェント が LLM を呼び出し、ツールを実行し、2 番目の エージェント に ハンドオフ、2 番目の エージェント がさらにツールを実行し、最終的に出力を生成\n+1. ユーザーのターン: ユーザーがテキストを入力\n+2. Runner の実行: 最初のエージェントが LLM を呼び出し、ツールを実行し、2 番目のエージェントに ハンドオフ、2 番目のエージェントがさらにツールを実行し、その後に出力を生成。\n \n-エージェントの実行終了時に、ユーザー に何を表示するかを選べます。たとえば、エージェント によって生成されたすべての新規アイテムを表示する、または最終出力のみを表示するといった形です。いずれにせよ、ユーザー がフォローアップの質問をするかもしれません。その場合は、再度 run メソッドを呼び出せます。\n+エージェントの実行終了時に、ユーザーへ何を見せるかを選べます。たとえば、エージェントが生成したすべての新しいアイテムを見せる、または最終出力のみを見せる、などです。どちらの場合でも、ユーザーが追質問をするかもしれません。その場合は再度 run メソッドを呼び出します。\n \n-### 手動の会話管理\n+### 手動による会話管理\n \n-次のターンの入力を得るために、[`RunResultBase.to_input_list()`][agents.result.RunResultBase.to_input_list] メソッドを使って会話履歴を手動で管理できます。\n+次のターンの入力を取得するために、[`RunResultBase.to_input_list()`][agents.result.RunResultBase.to_input_list] メソッドを使って、会話履歴を手動で管理できます。\n \n ```python\n async def main():\n@@ -97,7 +97,7 @@ async def main():\n \n ### Sessions による自動会話管理\n \n-より簡単に行うには、[Sessions](sessions/index.md) を使って、`.to_input_list()` を手動で呼び出さずに会話履歴を自動処理できます。\n+より簡単な方法として、[Sessions](sessions/index.md) を使うと、`.to_input_list()` を手動で呼び出さずに会話履歴を自動で処理できます。\n \n ```python\n from agents import Agent, Runner, SQLiteSession\n@@ -121,24 +121,24 @@ async def main():\n         # California\n ```\n \n-Sessions は自動的に次を行います。\n+Sessions は自動で以下を行います。\n \n--   各実行の前に会話履歴を取得\n--   各実行の後に新しいメッセージを保存\n--   異なるセッション ID ごとに個別の会話を維持\n+-   各実行前に会話履歴を取得\n+-   各実行後に新しいメッセージを保存\n+-   セッション ID ごとに別々の会話を維持\n \n-詳細は [Sessions のドキュメント](sessions/index.md) を参照してください。\n+詳細は [Sessions のドキュメント](sessions/index.md) をご覧ください。\n \n \n ### サーバー管理の会話\n \n-`to_input_list()` や `Sessions` でローカルに扱う代わりに、 OpenAI の conversation state 機能にサーバー側で会話状態を管理させることもできます。これにより、過去のメッセージをすべて手動で再送しなくても会話履歴を保存できます。詳細は [OpenAI Conversation state guide](https://platform.openai.com/docs/guides/conversation-state?api-mode=responses) を参照してください。\n+ローカルで `to_input_list()` や `Sessions` を使って管理する代わりに、OpenAI の conversation state 機能により サーバー 側で会話状態を管理することもできます。これにより、過去のメッセージをすべて手動で再送信せずに会話履歴を保持できます。詳しくは [OpenAI Conversation state ガイド](https://platform.openai.com/docs/guides/conversation-state?api-mode=responses) をご覧ください。\n \n-OpenAI はターン間の状態を追跡する 2 つの方法を提供します。\n+OpenAI はターン間で状態を追跡するための 2 つの方法を提供しています。\n \n #### 1. `conversation_id` を使用\n \n-最初に OpenAI Conversations API で会話を作成し、その ID を以後のすべての呼び出しで再利用します。\n+まず OpenAI Conversations API で会話を作成し、その ID を以後のすべての呼び出しで再利用します。\n \n ```python\n from agents import Agent, Runner\n@@ -161,7 +161,7 @@ async def main():\n \n #### 2. `previous_response_id` を使用\n \n-別の選択肢は **レスポンスのチェーン**（response chaining）で、各ターンが前のターンのレスポンス ID に明示的にリンクします。\n+もう 1 つの選択肢は、各ターンが前のターンのレスポンス ID に明示的にリンクする **response chaining** です。\n \n ```python\n from agents import Agent, Runner\n@@ -186,18 +186,18 @@ async def main():\n         print(f\"Assistant: {result.final_output}\")\n ```\n \n-## 長時間実行エージェントと人間参加 (human-in-the-loop)\n+## 長時間実行エージェントと human-in-the-loop\n \n-Agents SDK の [Temporal](https://temporal.io/) 連携を使うと、人間参加 (human-in-the-loop) を含む永続的な長時間実行ワークフローを動かせます。長時間実行タスクを完了するために Temporal と Agents SDK が連携して動くデモは[この動画](https://www.youtube.com/watch?v=fFBZqzT4DD8)で確認でき、[ドキュメントはこちら](https://github.com/temporalio/sdk-python/tree/main/temporalio/contrib/openai_agents)です。\n+Agents SDK の [Temporal](https://temporal.io/) 連携を使って、human-in-the-loop タスクを含む永続的で長時間実行のワークフローを動かせます。Temporal と Agents SDK が連携して長時間タスクを完了するデモは [この動画](https://www.youtube.com/watch?v=fFBZqzT4DD8) をご覧ください。ドキュメントは [こちら](https://github.com/temporalio/sdk-python/tree/main/temporalio/contrib/openai_agents) です。\n \n ## 例外\n \n-SDK は特定の状況で例外を送出します。完全な一覧は [`agents.exceptions`][] にあります。概要は次のとおりです。\n+SDK は特定のケースで例外を送出します。完全な一覧は [`agents.exceptions`][] にあります。概要:\n \n--   [`AgentsException`][agents.exceptions.AgentsException]: SDK 内で送出されるすべての例外の基底クラスです。その他の特定例外はこの型から派生します。\n--   [`MaxTurnsExceeded`][agents.exceptions.MaxTurnsExceeded]: エージェントの実行が `Runner.run`、`Runner.run_sync`、`Runner.run_streamed` メソッドに渡した `max_turns` 制限を超えたときに送出されます。指定されたインタラクション ターン数内にタスクを完了できなかったことを示します。\n--   [`ModelBehaviorError`][agents.exceptions.ModelBehaviorError]: 基盤のモデル（ LLM ）が予期しない、または無効な出力を生成した場合に発生します。以下を含みます。\n-    -   不正な JSON: 特定の `output_type` が定義されている場合に、ツール呼び出しや直接出力で不正な JSON 構造を返したとき。\n-    -   予期しないツール関連の失敗: モデルが期待どおりの方法でツールを使用できなかったとき\n--   [`UserError`][agents.exceptions.UserError]: SDK を使用するあなた（この SDK を使ってコードを書く人）が誤った使い方をした場合に送出されます。多くは不適切なコード実装、無効な設定、または SDK の API の誤用が原因です。\n--   [`InputGuardrailTripwireTriggered`][agents.exceptions.InputGuardrailTripwireTriggered], [`OutputGuardrailTripwireTriggered`][agents.exceptions.OutputGuardrailTripwireTriggered]: それぞれ入力 ガードレール または出力 ガードレール の条件が満たされたときに送出されます。入力 ガードレール は処理前に受信メッセージを検査し、出力 ガードレール は配信前にエージェントの最終応答を検査します。\n\\ No newline at end of file\n+-   [`AgentsException`][agents.exceptions.AgentsException]: SDK 内で送出されるすべての例外の基底クラスです。他の特定例外はすべてこの型から派生します。\n+-   [`MaxTurnsExceeded`][agents.exceptions.MaxTurnsExceeded]: エージェントの実行が `Runner.run`、`Runner.run_sync`、または `Runner.run_streamed` に渡された `max_turns` 制限を超えたときに送出されます。指定された対話ターン数内にタスクを完了できなかったことを示します。\n+-   [`ModelBehaviorError`][agents.exceptions.ModelBehaviorError]: 基盤となるモデル（LLM）が予期しない、または無効な出力を生成した場合に発生します。例:\n+    -   不正な JSON: 特定の `output_type` が定義されている場合に、ツール呼び出しや直接出力の JSON 構造が不正なとき。\n+    -   予期しないツール関連の失敗: モデルが期待どおりにツールを使用できないとき。\n+-   [`UserError`][agents.exceptions.UserError]: SDK を使用する（コードを書く）あなたがエラーを起こした場合に送出されます。これは通常、不適切なコード実装、無効な設定、SDK の API の誤用が原因です。\n+-   [`InputGuardrailTripwireTriggered`][agents.exceptions.InputGuardrailTripwireTriggered], [`OutputGuardrailTripwireTriggered`][agents.exceptions.OutputGuardrailTripwireTriggered]: それぞれ入力 ガードレール または出力 ガードレール の条件が満たされた場合に送出されます。入力 ガードレール は処理前に受信メッセージを確認し、出力 ガードレール はエージェントの最終応答を配信前に確認します。\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Frunning_agents.md",
        "sha": "294e9c5028de27903f3ae6479c6542b9e0c8ab94",
        "status": "modified"
      },
      {
        "additions": 19,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Fsessions%2Fadvanced_sqlite_session.md",
        "changes": 38,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fja%2Fsessions%2Fadvanced_sqlite_session.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 19,
        "filename": "docs/ja/sessions/advanced_sqlite_session.md",
        "patch": "@@ -2,17 +2,17 @@\n search:\n   exclude: true\n ---\n-# 高度な SQLite セッション\n+# Advanced SQLite セッション\n \n-`AdvancedSQLiteSession` は、会話の分岐、詳細な使用状況分析、構造化された会話クエリなど、高度な会話管理機能を提供する基本の `SQLiteSession` の強化版です。\n+`AdvancedSQLiteSession` は、基本の `SQLiteSession` を拡張した強力な会話管理機能を提供するセッションで、会話のブランチ、詳細な使用状況分析、構造化された会話クエリなどを利用できます。\n \n ## 機能\n \n--  **会話の分岐** : 任意の ユーザー メッセージから代替の会話パスを作成\n--  **使用状況の追跡** : 各ターンごとの詳細なトークン使用分析と完全な JSON 内訳\n--  **構造化クエリ** : ターン単位の会話取得、ツール使用統計など\n--  **ブランチ管理** : 独立したブランチ切り替えと管理\n--  **メッセージ構造メタデータ** : メッセージ種別、ツール使用、会話フローの追跡\n+- **会話のブランチ**: 任意の ユーザー メッセージから代替の会話パスを作成\n+- **使用状況のトラッキング**: 各ターンごとの詳細なトークン使用分析と完全な JSON 内訳\n+- **構造化クエリ**: ターン単位の会話取得、ツール使用統計など\n+- **ブランチ管理**: 独立したブランチの切り替えと管理\n+- **メッセージ構造メタデータ**: メッセージ種別、ツール使用、会話フローの追跡\n \n ## クイックスタート\n \n@@ -85,13 +85,13 @@ session = AdvancedSQLiteSession(\n ### パラメーター\n \n - `session_id` (str): 会話セッションの一意の識別子\n-- `db_path` (str | Path): SQLite データベースファイルへのパス。メモリ内保存にはデフォルトで `:memory:` を使用します\n-- `create_tables` (bool): 高度なテーブルを自動作成するかどうか。デフォルトは `False`\n-- `logger` (logging.Logger | None): セッション用のカスタムロガー。デフォルトはモジュールのロガー\n+- `db_path` (str | Path): SQLite データベースファイルへのパス。インメモリ保存の場合は `:memory:` がデフォルト\n+- `create_tables` (bool): 拡張テーブルを自動作成するかどうか。デフォルトは `False`\n+- `logger` (logging.Logger | None): セッション用のカスタムロガー。デフォルトはモジュールロガー\n \n-## 使用状況の追跡\n+## 使用状況のトラッキング\n \n-AdvancedSQLiteSession は、会話の各ターンごとのトークン使用データを保存することで、詳細な使用状況分析を提供します。これは、各 エージェント 実行後に `store_run_usage` メソッドが呼び出されることに完全に依存します。\n+AdvancedSQLiteSession は、各会話ターンごとのトークン使用データを保存して詳細な使用状況分析を提供します。**これは各 エージェント 実行後に `store_run_usage` メソッドが呼び出されることに完全に依存します。**\n \n ### 使用データの保存\n \n@@ -135,7 +135,7 @@ for turn_data in turn_usage:\n turn_2_usage = await session.get_turn_usage(user_turn_number=2)\n ```\n \n-## 会話の分岐\n+## 会話のブランチ\n \n AdvancedSQLiteSession の主要機能の 1 つは、任意の ユーザー メッセージから会話ブランチを作成し、代替の会話パスを探索できることです。\n \n@@ -245,17 +245,17 @@ for turn in matching_turns:\n \n ### メッセージ構造\n \n-セッションは次のメッセージ構造を自動的に追跡します。\n+セッションは次のようなメッセージ構造を自動的に追跡します。\n \n-- メッセージ種別 (user, assistant, tool_call など)\n+- メッセージ種別（user、assistant、tool_call など）\n - ツール呼び出しのツール名\n - ターン番号とシーケンス番号\n-- ブランチの関連付け\n+- ブランチとの関連付け\n - タイムスタンプ\n \n ## データベーススキーマ\n \n-AdvancedSQLiteSession は、基本の SQLite スキーマを拡張し、追加で 2 つのテーブルを提供します。\n+AdvancedSQLiteSession は、基本の SQLite スキーマを拡張し、さらに 2 つのテーブルを追加します。\n \n ### message_structure テーブル\n \n@@ -296,9 +296,9 @@ CREATE TABLE turn_usage (\n );\n ```\n \n-## 完全な例\n+## 完全な code examples\n \n-すべての機能を包括的に示した [完全な例](https://github.com/openai/openai-agents-python/tree/main/examples/memory/advanced_sqlite_session_example.py) をご覧ください。\n+すべての機能を包括的に示す [完全なサンプル](https://github.com/openai/openai-agents-python/tree/main/examples/memory/advanced_sqlite_session_example.py) をご覧ください。\n \n \n ## API リファレンス",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Fsessions%2Fadvanced_sqlite_session.md",
        "sha": "125b401f3a88a26a7b0c093e8c8c1b88cbdeb479",
        "status": "modified"
      },
      {
        "additions": 26,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Fsessions%2Fencrypted_session.md",
        "changes": 52,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fja%2Fsessions%2Fencrypted_session.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 26,
        "filename": "docs/ja/sessions/encrypted_session.md",
        "patch": "@@ -4,18 +4,18 @@ search:\n ---\n # 暗号化セッション\n \n-`EncryptedSession` は、任意のセッション実装に対して透過的な暗号化を提供し、古い会話データを自動的に期限切れにして安全にします。\n+`EncryptedSession` は任意のセッション実装に透過的な暗号化を提供し、会話データを保護しつつ、古い項目を自動的に期限切れにします。\n \n-## 特長\n+## 機能\n \n-- **透過的な暗号化**: 任意のセッションを  Fernet  暗号化でラップします\n-- **セッションごとのキー**:  HKDF  による鍵導出でセッションごとに一意の暗号化を実現します\n-- **自動期限切れ**:  TTL  の有効期限が切れた古い項目は静かにスキップされます\n-- **ドロップイン置き換え**: 既存のあらゆるセッション実装で動作します\n+- **透過的な暗号化**: 任意のセッションを Fernet でラップして暗号化します\n+- **セッションごとの鍵**: HKDF による鍵導出でセッションごとに一意の暗号鍵を使用します\n+- **自動有効期限**: TTL が切れた古い項目は静かにスキップされます\n+- **置き換え可能**: 既存の任意のセッション実装で動作します\n \n ## インストール\n \n-暗号化セッションには `encrypt` extra が必要です:\n+暗号化セッションを使用するには `encrypt` エクストラが必要です:\n \n ```bash\n pip install openai-agents[encrypt]\n@@ -55,9 +55,9 @@ if __name__ == \"__main__\":\n \n ## 設定\n \n-### 暗号化キー\n+### 暗号鍵\n \n-暗号化キーは  Fernet  キーまたは任意の文字列を使用できます:\n+暗号鍵は Fernet キーまたは任意の文字列を使用できます:\n \n ```python\n from agents.extensions.memory import EncryptedSession\n@@ -79,9 +79,9 @@ session = EncryptedSession(\n )\n ```\n \n-### TTL ( Time To Live )\n+### TTL (Time To Live)\n \n-暗号化された項目が有効な期間を設定します:\n+暗号化された項目の有効期間を設定します:\n \n ```python\n # Items expire after 1 hour\n@@ -103,7 +103,7 @@ session = EncryptedSession(\n \n ## さまざまなセッションタイプでの使用\n \n-###  SQLite  セッションでの使用\n+### SQLite セッションでの使用\n \n ```python\n from agents import SQLiteSession\n@@ -119,7 +119,7 @@ session = EncryptedSession(\n )\n ```\n \n-###  SQLAlchemy  セッションでの使用\n+### SQLAlchemy セッションでの使用\n \n ```python\n from agents.extensions.memory import EncryptedSession, SQLAlchemySession\n@@ -140,30 +140,30 @@ session = EncryptedSession(\n \n !!! warning \"高度なセッション機能\"\n \n-    `EncryptedSession` を `AdvancedSQLiteSession` などの高度なセッション実装と組み合わせて使用する場合、次の点に注意してください。\n+    `EncryptedSession` を `AdvancedSQLiteSession` のような高度なセッション実装と併用する場合、次の点に注意してください:\n \n-    - `find_turns_by_content()` のようなメソッドは、メッセージ内容が暗号化されているため効果的に機能しません\n-    - 内容に基づく検索は暗号化データに対して行われるため、効果が限定されます\n+    - メッセージ内容が暗号化されるため、`find_turns_by_content()` のようなメソッドは効果的に機能しません\n+    - 内容に基づく検索は暗号化データ上で行われるため、効果が制限されます\n \n \n \n-## キー導出\n+## 鍵導出\n \n-EncryptedSession は  HKDF  ( HMAC-based Key Derivation Function ) を使用して、セッションごとに一意の暗号化キーを導出します。\n+EncryptedSession は HKDF (HMAC ベースの Key Derivation Function) を使用して、セッションごとに一意の暗号鍵を導出します:\n \n-- **マスターキー**: 提供された暗号化キー\n+- **マスター鍵**: 提供された暗号鍵\n - **セッションソルト**: セッション ID\n - **Info 文字列**: `\"agents.session-store.hkdf.v1\"`\n-- **出力**: 32 バイトの  Fernet  キー\n+- **出力**: 32-byte の Fernet キー\n \n-これにより次が保証されます。\n-- 各セッションには一意の暗号化キーがあります\n-- マスターキーがなければ鍵を導出できません\n+これにより、次の点が保証されます:\n+- 各セッションには一意の暗号鍵があります\n+- マスター鍵なしに鍵を導出することはできません\n - セッション間でデータを復号することはできません\n \n-## 自動期限切れ\n+## 自動有効期限\n \n-項目が  TTL  を超えた場合、取得時に自動的にスキップされます:\n+項目が TTL を超えた場合、取得時に自動的にスキップされます:\n \n ```python\n # Items older than TTL are silently ignored\n@@ -175,5 +175,5 @@ result = await Runner.run(agent, \"Continue conversation\", session=session)\n \n ## API リファレンス\n \n-- [`EncryptedSession`][agents.extensions.memory.encrypt_session.EncryptedSession] - 主要クラス\n+- [`EncryptedSession`][agents.extensions.memory.encrypt_session.EncryptedSession] - メインクラス\n - [`Session`][agents.memory.session.Session] - ベースセッションプロトコル\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Fsessions%2Fencrypted_session.md",
        "sha": "ce700bf6cdf752d3f93145a136bfecdbe7225b17",
        "status": "modified"
      },
      {
        "additions": 32,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Fsessions%2Findex.md",
        "changes": 64,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fja%2Fsessions%2Findex.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 32,
        "filename": "docs/ja/sessions/index.md",
        "patch": "@@ -4,9 +4,9 @@ search:\n ---\n # セッション\n \n-Agents SDK は、複数のエージェント実行にまたがって会話履歴を自動的に維持する組み込みのセッションメモリを提供し、ターン間で `.to_input_list()` を手動で扱う必要をなくします。\n+Agents SDK は、複数回の エージェント 実行にわたって会話履歴を自動的に保持する組み込みセッションメモリを提供し、ターン間で手動で `.to_input_list()` を扱う必要をなくします。\n \n-セッションは特定のセッションの会話履歴を保存し、明示的な手動のメモリ管理なしにエージェントがコンテキストを維持できるようにします。これは、エージェントに過去のやり取りを覚えさせたいチャットアプリケーションやマルチターンの会話を構築する際に特に有用です。\n+Sessions は特定のセッションの会話履歴を保存し、明示的な手動メモリ管理なしで エージェント がコンテキストを維持できるようにします。これは、チャットアプリケーションや、以前のやり取りをエージェントに記憶させたいマルチターンの会話を構築する際に特に有用です。\n \n ## クイックスタート\n \n@@ -49,19 +49,19 @@ print(result.final_output)  # \"Approximately 39 million\"\n \n ## 仕組み\n \n-セッションメモリが有効な場合:\n+セッションメモリを有効にすると:\n \n-1. **各実行の前**: ランナーはセッションの会話履歴を自動的に取得し、入力アイテムの先頭に追加します。\n-2. **各実行の後**: 実行中に生成されたすべての新しいアイテム（ユーザー入力、アシスタントの応答、ツール呼び出しなど）は自動的にセッションに保存されます。\n-3. **コンテキストの保持**: 同じセッションでの後続の実行には完全な会話履歴が含まれ、エージェントはコンテキストを維持できます。\n+1. **各実行前**: ランナーはそのセッションの会話履歴を自動的に取得し、入力アイテムの先頭に付加します。\n+2. **各実行後**: 実行中に生成されたすべての新しいアイテム (ユーザー入力、アシスタントの応答、ツール呼び出しなど) は自動的にセッションに保存されます。\n+3. **コンテキストの保持**: 同じセッションでの以降の実行には完全な会話履歴が含まれ、エージェント がコンテキストを維持できます。\n \n-これにより、`.to_input_list()` を手動で呼び出し、実行間で会話状態を管理する必要がなくなります。\n+これにより、ターン間で `.to_input_list()` を手動で呼び出したり、会話状態を管理したりする必要がなくなります。\n \n ## メモリ操作\n \n ### 基本操作\n \n-セッションは会話履歴を管理するためのいくつかの操作をサポートします:\n+Sessions は会話履歴を管理するための複数の操作をサポートします:\n \n ```python\n from agents import SQLiteSession\n@@ -86,7 +86,7 @@ print(last_item)  # {\"role\": \"assistant\", \"content\": \"Hi there!\"}\n await session.clear_session()\n ```\n \n-### 修正のための pop_item の使用\n+### 修正のための pop_item の利用\n \n `pop_item` メソッドは、会話内の最後のアイテムを取り消したり修正したりしたい場合に特に便利です:\n \n@@ -119,7 +119,7 @@ print(f\"Agent: {result.final_output}\")\n \n ## セッションの種類\n \n-SDK はさまざまなユースケースに対応する複数のセッション実装を提供します:\n+SDK は、用途に応じて複数のセッション実装を提供します:\n \n ### OpenAI Conversations API セッション\n \n@@ -159,7 +159,7 @@ print(result.final_output)  # \"California\"\n \n ### SQLite セッション\n \n-デフォルトの軽量な SQLite ベースのセッション実装です:\n+SQLite を用いたデフォルトの軽量セッション実装:\n \n ```python\n from agents import SQLiteSession\n@@ -180,7 +180,7 @@ result = await Runner.run(\n \n ### SQLAlchemy セッション\n \n-任意の SQLAlchemy 対応データベースを使用できる本番運用向けのセッションです:\n+任意の SQLAlchemy がサポートするデータベースを利用できる本番運用向けセッション:\n \n ```python\n from agents.extensions.memory import SQLAlchemySession\n@@ -204,7 +204,7 @@ session = SQLAlchemySession(\"user_123\", engine=engine, create_tables=True)\n \n ### 高度な SQLite セッション\n \n-会話の分岐、使用状況分析、構造化クエリを備えた拡張 SQLite セッションです:\n+会話の分岐、使用状況分析、構造化クエリを備えた強化版 SQLite セッション:\n \n ```python\n from agents.extensions.memory import AdvancedSQLiteSession\n@@ -228,7 +228,7 @@ await session.create_branch_from_turn(2)  # Branch from turn 2\n \n ### 暗号化セッション\n \n-任意のセッション実装に対する透過的な暗号化ラッパーです:\n+任意のセッション実装に対する透過的な暗号化ラッパー:\n \n ```python\n from agents.extensions.memory import EncryptedSession, SQLAlchemySession\n@@ -255,27 +255,27 @@ result = await Runner.run(agent, \"Hello\", session=session)\n \n ### その他のセッションタイプ\n \n-いくつかの組み込みオプションがあります。`examples/memory/` および `extensions/memory/` 配下のソースコードを参照してください。\n+他にもいくつかの組み込みオプションがあります。`examples/memory/` と `extensions/memory/` 配下のソースコードを参照してください。\n \n ## セッション管理\n \n ### セッション ID の命名\n \n-会話を整理しやすくする意味のあるセッション ID を使用します:\n+会話を整理しやすい意味のあるセッション ID を使用します:\n \n-- User ベース: `\"user_12345\"`\n-- スレッドベース: `\"thread_abc123\"`\n-- コンテキストベース: `\"support_ticket_456\"`\n+- ユーザー ベース: `\"user_12345\"`\n+- スレッド ベース: `\"thread_abc123\"`\n+- コンテキスト ベース: `\"support_ticket_456\"`\n \n ### メモリの永続化\n \n-- 一時的な会話にはインメモリ SQLite（`SQLiteSession(\"session_id\")`）を使用します\n-- 永続的な会話にはファイルベース SQLite（`SQLiteSession(\"session_id\", \"path/to/db.sqlite\")`）を使用します\n-- 既存の SQLAlchemy がサポートするデータベースを用いた本番システムには SQLAlchemy ベースのセッション（`SQLAlchemySession(\"session_id\", engine=engine, create_tables=True)`）を使用します\n-- クラウドネイティブな本番デプロイで、組み込みのテレメトリー、トレーシング、データ分離付きで 30+ のデータベースバックエンドをサポートする場合は Dapr ステートストア セッション（`DaprSession.from_address(\"session_id\", state_store_name=\"statestore\", dapr_address=\"localhost:50001\")`）を使用します\n-- 履歴を OpenAI Conversations API に保存したい場合は OpenAI がホストするストレージ（`OpenAIConversationsSession()`）を使用します\n-- 任意のセッションを透過的な暗号化と TTL ベースの有効期限でラップするには暗号化セッション（`EncryptedSession(session_id, underlying_session, encryption_key)`）を使用します\n-- さらに高度なユースケース向けに、他の本番システム（Redis、Django など）用のカスタムセッションバックエンドの実装を検討してください\n+- 一時的な会話にはインメモリ SQLite (`SQLiteSession(\"session_id\")`) を使用\n+- 永続的な会話にはファイルベースの SQLite (`SQLiteSession(\"session_id\", \"path/to/db.sqlite\")`) を使用\n+- 既存の SQLAlchemy サポートデータベースを用いる本番環境には SQLAlchemy ベースのセッション (`SQLAlchemySession(\"session_id\", engine=engine, create_tables=True)`) を使用\n+- クラウドネイティブな本番デプロイで、組み込みのテレメトリー、トレーシング、データ分離を備えた 30+ のデータベースバックエンドをサポートする場合は Dapr ステートストアセッション (`DaprSession.from_address(\"session_id\", state_store_name=\"statestore\", dapr_address=\"localhost:50001\")`) を使用\n+- 履歴を OpenAI Conversations API に保存したい場合は OpenAI ホスト型ストレージ (`OpenAIConversationsSession()`) を使用\n+- 透過的な暗号化と TTL ベースの有効期限で任意のセッションをラップするには暗号化セッション (`EncryptedSession(session_id, underlying_session, encryption_key)`) を使用\n+- さらに高度なユースケース向けに、他の本番システム (Redis、Django など) 向けのカスタムセッションバックエンドの実装も検討\n \n ### 複数セッション\n \n@@ -321,9 +321,9 @@ result2 = await Runner.run(\n )\n ```\n \n-## 完全なコード例\n+## 完全な例\n \n-セッションメモリが機能する様子を示す完全な例です:\n+セッションメモリが動作する完全な例を示します:\n \n ```python\n import asyncio\n@@ -430,24 +430,24 @@ result = await Runner.run(\n )\n ```\n \n-## コミュニティによるセッション実装\n+## コミュニティ製セッション実装\n \n コミュニティによって追加のセッション実装が開発されています:\n \n | パッケージ | 説明 |\n |---------|-------------|\n-| [openai-django-sessions](https://pypi.org/project/openai-django-sessions/) | 任意の Django がサポートするデータベース（PostgreSQL、MySQL、SQLite など）向けの Django ORM ベースのセッション |\n+| [openai-django-sessions](https://pypi.org/project/openai-django-sessions/) | 任意の Django サポートデータベース (PostgreSQL、MySQL、SQLite など) に対応する Django ORM ベースのセッション |\n \n セッション実装を作成された場合は、ぜひドキュメントの PR を送ってここに追加してください。\n \n ## API リファレンス\n \n-詳細な API ドキュメントは次を参照してください:\n+詳細な API ドキュメントは以下を参照してください:\n \n - [`Session`][agents.memory.session.Session] - プロトコルインターフェース\n - [`OpenAIConversationsSession`][agents.memory.OpenAIConversationsSession] - OpenAI Conversations API 実装\n - [`SQLiteSession`][agents.memory.sqlite_session.SQLiteSession] - 基本的な SQLite 実装\n - [`SQLAlchemySession`][agents.extensions.memory.sqlalchemy_session.SQLAlchemySession] - SQLAlchemy ベースの実装\n - [`DaprSession`][agents.extensions.memory.dapr_session.DaprSession] - Dapr ステートストア実装\n-- [`AdvancedSQLiteSession`][agents.extensions.memory.advanced_sqlite_session.AdvancedSQLiteSession] - 分岐と分析を備えた拡張 SQLite\n+- [`AdvancedSQLiteSession`][agents.extensions.memory.advanced_sqlite_session.AdvancedSQLiteSession] - 分岐と分析を備えた強化版 SQLite\n - [`EncryptedSession`][agents.extensions.memory.encrypt_session.EncryptedSession] - 任意のセッション向け暗号化ラッパー\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Fsessions%2Findex.md",
        "sha": "751b61207e70d07ff1c6193bb079ada4f73ea348",
        "status": "modified"
      },
      {
        "additions": 5,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Fsessions%2Fsqlalchemy_session.md",
        "changes": 10,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fja%2Fsessions%2Fsqlalchemy_session.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 5,
        "filename": "docs/ja/sessions/sqlalchemy_session.md",
        "patch": "@@ -4,11 +4,11 @@ search:\n ---\n # SQLAlchemy セッション\n \n-`SQLAlchemySession` は SQLAlchemy を使用して本番運用に適したセッション実装を提供し、SQLAlchemy がサポートする任意のデータベース（ PostgreSQL、MySQL、SQLite など）をセッションストレージに使用できます。\n+`SQLAlchemySession` は SQLAlchemy を使用して本番運用向けのセッション実装を提供し、セッションストレージとして SQLAlchemy がサポートする任意のデータベース ( PostgreSQL、MySQL、SQLite など ) を使用できます。\n \n ## インストール\n \n-SQLAlchemy セッションには `sqlalchemy` エクストラが必要です:\n+SQLAlchemy セッションには `sqlalchemy` の extra が必要です:\n \n ```bash\n pip install openai-agents[sqlalchemy]\n@@ -44,7 +44,7 @@ if __name__ == \"__main__\":\n \n ### 既存のエンジンの使用\n \n-既存の SQLAlchemy エンジンを持つアプリケーション向け:\n+既に SQLAlchemy エンジンがあるアプリケーション向け:\n \n ```python\n import asyncio\n@@ -76,5 +76,5 @@ if __name__ == \"__main__\":\n \n ## API リファレンス\n \n-- [`SQLAlchemySession`][agents.extensions.memory.sqlalchemy_session.SQLAlchemySession] - 主要クラス\n-- [`Session`][agents.memory.session.Session] - セッションの基本プロトコル\n\\ No newline at end of file\n+- [`SQLAlchemySession`][agents.extensions.memory.sqlalchemy_session.SQLAlchemySession] - メインクラス\n+- [`Session`][agents.memory.session.Session] - ベースセッションプロトコル\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Fsessions%2Fsqlalchemy_session.md",
        "sha": "1a144b998845c46af4c7869ea95e8112f8fba240",
        "status": "modified"
      },
      {
        "additions": 7,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Fstreaming.md",
        "changes": 14,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fja%2Fstreaming.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 7,
        "filename": "docs/ja/streaming.md",
        "patch": "@@ -4,15 +4,15 @@ search:\n ---\n # ストリーミング\n \n-ストリーミングを使うと、進行中のエージェント の実行更新を購読できます。これは、エンド ユーザー に進捗や部分的なレスポンスを表示するのに役立ちます。\n+ストリーミングにより、エージェントの実行が進むにつれて更新を購読できます。これはエンドユーザーに進捗や部分的な応答を表示するのに役立ちます。\n \n-ストリーミングするには、[`Runner.run_streamed()`][agents.run.Runner.run_streamed] を呼び出します。これにより [`RunResultStreaming`][agents.result.RunResultStreaming] が得られます。`result.stream_events()` を呼ぶと、以下で説明する [`StreamEvent`][agents.stream_events.StreamEvent] オブジェクトの非同期ストリームが得られます。\n+ストリーミングするには、[`Runner.run_streamed()`][agents.run.Runner.run_streamed] を呼び出します。これにより [`RunResultStreaming`][agents.result.RunResultStreaming] が得られます。`result.stream_events()` を呼ぶと、以下で説明する [`StreamEvent`][agents.stream_events.StreamEvent] オブジェクトの非同期ストリームを受け取れます。\n \n-## raw レスポンスイベント\n+## raw response イベント\n \n-[`RawResponsesStreamEvent`][agents.stream_events.RawResponsesStreamEvent] は、LLM から直接渡される raw なイベントです。形式は OpenAI Responses API で、各イベントはタイプ（`response.created`、`response.output_text.delta` など）とデータを持ちます。生成され次第、ユーザー へレスポンスメッセージをストリーミングしたい場合に有用です。\n+[`RawResponsesStreamEvent`][agents.stream_events.RawResponsesStreamEvent] は、LLM から直接渡される raw なイベントです。OpenAI Responses API の形式であり、各イベントにはタイプ（`response.created`、`response.output_text.delta` など）とデータがあります。これらのイベントは、生成され次第、ユーザーにレスポンスメッセージをストリーミングしたい場合に有用です。\n \n-例えば、次は LLM が生成するテキストをトークンごとに出力します。\n+例えば、これは LLM が生成するテキストをトークンごとに出力します。\n \n ```python\n import asyncio\n@@ -37,9 +37,9 @@ if __name__ == \"__main__\":\n \n ## Run item イベントと エージェント イベント\n \n-[`RunItemStreamEvent`][agents.stream_events.RunItemStreamEvent] は、より高レベルのイベントです。アイテムが完全に生成されたタイミングを知らせます。これにより、各トークンではなく「メッセージが生成された」「ツールが実行された」といったレベルで進捗を通知できます。同様に、[`AgentUpdatedStreamEvent`][agents.stream_events.AgentUpdatedStreamEvent] は、現在のエージェント が変化したとき（例: ハンドオフ の結果として）に更新を提供します。\n+[`RunItemStreamEvent`][agents.stream_events.RunItemStreamEvent] は、より高レベルのイベントです。アイテムが完全に生成されたタイミングを知らせます。これにより、トークン単位ではなく、「メッセージが生成された」「ツールが実行された」などのレベルで進捗更新を配信できます。同様に、[`AgentUpdatedStreamEvent`][agents.stream_events.AgentUpdatedStreamEvent] は、現在のエージェントが変更されたとき（ハンドオフの結果など）に更新を提供します。\n \n-例えば、次は raw イベントを無視して ユーザー へ更新をストリーミングします。\n+例えば、これは raw イベントを無視し、ユーザーへ更新をストリーミングします。\n \n ```python\n import asyncio",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Fstreaming.md",
        "sha": "ee2a006cf189dce7b48da7fe5430c098cf6bdfd4",
        "status": "modified"
      },
      {
        "additions": 54,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Ftools.md",
        "changes": 108,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fja%2Ftools.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 54,
        "filename": "docs/ja/tools.md",
        "patch": "@@ -4,20 +4,20 @@ search:\n ---\n # ツール\n \n-ツールは エージェント がアクションを実行できるようにします。例えば、データの取得、コードの実行、外部 API の呼び出し、さらにはコンピュータの使用などです。Agents SDK には 3 つのクラスのツールがあります。\n+ツールは エージェント がアクションを実行できるようにします。たとえば、データの取得、コードの実行、外部 API の呼び出し、さらにはコンピュータの操作などです。Agents SDK には 3 つのツールクラスがあります。\n \n-- Hosted tools: これらは AI モデルと同じ LLM サーバー上で動作します。OpenAI は retrieval、Web 検索、コンピュータ操作 を Hosted tools として提供します。\n-- Function calling: 任意の Python 関数をツールとして使用できます。\n-- Agents as tools: エージェント をツールとして使用でき、ハンドオフ せずに別の エージェント を呼び出せます。\n+- Hosted tools: これは AI モデルと同じ LLM サーバー上で動作します。OpenAI はリトリーバル (retrieval)、Web 検索、コンピュータ操作をホスト型ツールとして提供します。\n+- Function calling: 任意の Python 関数をツールとして利用できます。\n+- Agents as tools: エージェントをツールとして利用でき、ハンドオフせずに他の エージェント を呼び出せます。\n \n ## Hosted tools\n \n-OpenAI は [`OpenAIResponsesModel`][agents.models.openai_responses.OpenAIResponsesModel] を使用する際に、いくつかの組み込みツールを提供します。\n+OpenAI は [`OpenAIResponsesModel`][agents.models.openai_responses.OpenAIResponsesModel] 利用時にいくつかの組み込みツールを提供します。\n \n-- [`WebSearchTool`][agents.tool.WebSearchTool] は エージェント が Web を検索できるようにします。\n-- [`FileSearchTool`][agents.tool.FileSearchTool] は OpenAI ベクトルストア から情報を取得できます。\n-- [`ComputerTool`][agents.tool.ComputerTool] は コンピュータ操作 の自動化を可能にします。\n-- [`CodeInterpreterTool`][agents.tool.CodeInterpreterTool] は LLM がサンドボックス環境でコードを実行できるようにします。\n+- [`WebSearchTool`][agents.tool.WebSearchTool] は エージェント に Web を検索させます。\n+- [`FileSearchTool`][agents.tool.FileSearchTool] は OpenAI の ベクトルストア から情報を取得します。\n+- [`ComputerTool`][agents.tool.ComputerTool] はコンピュータ操作タスクを自動化します。\n+- [`CodeInterpreterTool`][agents.tool.CodeInterpreterTool] はサンドボックス環境で LLM がコードを実行できるようにします。\n - [`HostedMCPTool`][agents.tool.HostedMCPTool] はリモートの MCP サーバーのツールをモデルに公開します。\n - [`ImageGenerationTool`][agents.tool.ImageGenerationTool] はプロンプトから画像を生成します。\n - [`LocalShellTool`][agents.tool.LocalShellTool] はローカルマシンでシェルコマンドを実行します。\n@@ -43,14 +43,14 @@ async def main():\n \n ## 関数ツール\n \n-任意の Python 関数をツールとして使用できます。Agents SDK がツールを自動的にセットアップします。\n+任意の Python 関数をツールとして利用できます。Agents SDK がツールの設定を自動で行います。\n \n-- ツール名は Python 関数名になります（任意で名前を指定可能）\n-- ツールの説明は関数の docstring から取得されます（任意で説明を指定可能）\n-- 関数入力のスキーマは関数の引数から自動的に作成されます\n-- 各入力の説明は、無効化しない限り関数の docstring から取得されます\n+- ツール名は Python 関数名になります（任意の名前を指定することも可能）\n+- ツールの説明は関数の docstring から取得します（任意の説明を指定することも可能）\n+- 関数入力のスキーマは関数の引数から自動生成されます\n+- 各入力の説明は（無効化しない限り）関数の docstring から取得します\n \n-Python の `inspect` モジュールで関数シグネチャを抽出し、[`griffe`](https://mkdocstrings.github.io/griffe/) で docstring を解析し、スキーマ作成には `pydantic` を使用します。\n+Python の `inspect` モジュールで関数シグネチャを抽出し、docstring の解析には [`griffe`](https://mkdocstrings.github.io/griffe/) を、スキーマ生成には `pydantic` を使用しています。\n \n ```python\n import json\n@@ -102,12 +102,12 @@ for tool in agent.tools:\n \n ```\n \n-1. 関数の引数として任意の Python 型を使用でき、関数は sync/async いずれでもかまいません。\n-2. docstring があれば、説明や引数の説明の取得に使用します。\n-3. 関数は任意で `context`（先頭の引数である必要があります）を受け取れます。ツール名、説明、docstring スタイルなどの上書きも設定できます。\n-4. デコレートされた関数をツールのリストに渡せます。\n+1. 関数の引数には任意の Python 型を使用でき、同期でも非同期でも構いません。\n+2. docstring がある場合、説明と引数説明の取得に利用します。\n+3. 関数は任意で `context`（最初の引数である必要があります）を受け取れます。ツール名、説明、docstring スタイルなどのオーバーライドも設定できます。\n+4. デコレートした関数をツールのリストに渡せます。\n \n-??? note \"出力を表示するには展開してください\"\n+??? note \"出力を表示\"\n \n     ```\n     fetch_weather\n@@ -179,20 +179,20 @@ for tool in agent.tools:\n \n ### 関数ツールから画像やファイルを返す\n \n-テキスト出力に加えて、関数ツールの出力として 1 つまたは複数の画像やファイルを返すことができます。次のいずれかを返せます。\n+テキスト出力に加えて、関数ツールの出力として 1 つまたは複数の画像やファイルを返せます。次のいずれかを返してください。\n \n - 画像: [`ToolOutputImage`][agents.tool.ToolOutputImage]（または TypedDict 版の [`ToolOutputImageDict`][agents.tool.ToolOutputImageDict]）\n - ファイル: [`ToolOutputFileContent`][agents.tool.ToolOutputFileContent]（または TypedDict 版の [`ToolOutputFileContentDict`][agents.tool.ToolOutputFileContentDict]）\n-- テキスト: 文字列または文字列化可能なオブジェクト、もしくは [`ToolOutputText`][agents.tool.ToolOutputText]（または TypedDict 版の [`ToolOutputTextDict`][agents.tool.ToolOutputTextDict]）\n+- テキスト: 文字列または文字列化可能なオブジェクト、あるいは [`ToolOutputText`][agents.tool.ToolOutputText]（または TypedDict 版の [`ToolOutputTextDict`][agents.tool.ToolOutputTextDict]）\n \n ### カスタム関数ツール\n \n-Python 関数をツールとして使いたくない場合もあります。必要に応じて、[`FunctionTool`][agents.tool.FunctionTool] を直接作成できます。次を指定する必要があります。\n+Python 関数をツールとして使いたくない場合もあります。必要に応じて [`FunctionTool`][agents.tool.FunctionTool] を直接作成できます。次を指定する必要があります。\n \n - `name`\n - `description`\n-- 引数の JSON スキーマである `params_json_schema`\n-- [`ToolContext`][agents.tool_context.ToolContext] と引数の JSON 文字列を受け取り、ツールの出力を文字列で返す非同期関数 `on_invoke_tool`\n+- 引数用の JSON スキーマである `params_json_schema`\n+- [`ToolContext`][agents.tool_context.ToolContext] と JSON 文字列の引数を受け取り、ツール出力を文字列で返す非同期関数 `on_invoke_tool`\n \n ```python\n from typing import Any\n@@ -227,16 +227,16 @@ tool = FunctionTool(\n \n ### 引数と docstring の自動解析\n \n-前述のとおり、ツール用のスキーマを抽出するために関数シグネチャを自動解析し、ツールおよび個々の引数の説明を抽出するために docstring を解析します。補足事項:\n+前述のとおり、ツールのスキーマを抽出するために関数シグネチャを自動解析し、ツールおよび各引数の説明を抽出するために docstring を解析します。補足:\n \n-1. シグネチャ解析は `inspect` モジュールで行います。型アノテーションを使って引数の型を理解し、全体のスキーマを表す Pydantic モデルを動的に構築します。Python の基本型、Pydantic モデル、TypedDict など、ほとんどの型をサポートします。\n-2. docstring の解析には `griffe` を使用します。サポートされる docstring 形式は `google`、`sphinx`、`numpy` です。docstring 形式は自動検出を試みますがベストエフォートであり、`function_tool` 呼び出し時に明示的に設定できます。`use_docstring_info` を `False` に設定すると docstring 解析を無効化できます。\n+1. シグネチャ解析は `inspect` モジュールで行います。型アノテーションから引数の型を理解し、全体スキーマを表す Pydantic モデルを動的に構築します。Python の基本型、Pydantic モデル、TypedDict など、ほとんどの型をサポートします。\n+2. docstring の解析には `griffe` を使用します。サポートする docstring 形式は `google`、`sphinx`、`numpy` です。形式は自動検出を試みますがベストエフォートのため、`function_tool` 呼び出し時に明示指定できます。`use_docstring_info` を `False` に設定して docstring 解析を無効化することも可能です。\n \n スキーマ抽出のコードは [`agents.function_schema`][] にあります。\n \n ## エージェントをツールとして\n \n-ワークフローによっては、ハンドオフ せずに、中央の エージェント が専門特化した エージェント 群のオーケストレーションを行いたい場合があります。エージェント をツールとしてモデル化することでこれが可能です。\n+あるワークフローでは、ハンドオフせずに中央の エージェント が専門 エージェント 群をオーケストレーションしたい場合があります。エージェントをツールとしてモデル化することで実現できます。\n \n ```python\n from agents import Agent, Runner\n@@ -277,7 +277,7 @@ async def main():\n \n ### ツール化したエージェントのカスタマイズ\n \n-`agent.as_tool` 関数は、エージェント を手軽にツール化するための簡便メソッドです。ただし、すべての設定をサポートしているわけではありません。例えば、`max_turns` は設定できません。高度なユースケースでは、ツール実装内で `Runner.run` を直接使用してください。\n+`agent.as_tool` 関数は エージェント を簡単にツール化するためのユーティリティです。ただしすべての設定をサポートするわけではありません（たとえば `max_turns` は設定できません）。高度なユースケースでは、ツール実装内で直接 `Runner.run` を使用してください。\n \n ```python\n @function_tool\n@@ -298,13 +298,13 @@ async def run_my_agent() -> str:\n \n ### カスタム出力抽出\n \n-場合によっては、中央の エージェント に返す前に ツール化したエージェント の出力を加工したいことがあります。例えば次のような場合に有用です。\n+場合によっては、中央 エージェント に返す前にツール化した エージェント の出力を加工したいことがあります。次のような場合に有用です。\n \n-- サブエージェントのチャット履歴から特定の情報（例: JSON ペイロード）を抽出する。\n-- エージェント の最終回答を変換または再整形する（例: Markdown をプレーンテキストや CSV に変換）。\n-- 出力を検証し、応答が欠落または不正な場合にフォールバック値を提供する。\n+- サブエージェントのチャット履歴から特定情報（例: JSON ペイロード）を抽出したい。\n+- エージェントの最終回答を変換・再整形したい（例: Markdown をプレーンテキストや CSV に変換）。\n+- 出力を検証したり、応答が欠落・不正な場合にフォールバック値を提供したい。\n \n-これは、`as_tool` メソッドに `custom_output_extractor` 引数を渡すことで実現できます。\n+`as_tool` メソッドに `custom_output_extractor` 引数を渡すことで実現できます。\n \n ```python\n async def extract_json_payload(run_result: RunResult) -> str:\n@@ -323,9 +323,9 @@ json_tool = data_agent.as_tool(\n )\n ```\n \n-### ネストしたエージェント実行のストリーミング\n+### 入れ子になったエージェント実行のストリーミング\n \n-ネストした エージェント が発行する ストリーミング イベントを受け取りつつ、ストリーム完了後にその最終出力を返すには、`as_tool` に `on_stream` コールバックを渡します。\n+`as_tool` に `on_stream` コールバックを渡すと、ストリーム完了後に最終出力を返しつつ、入れ子の エージェント が発行する ストリーミング イベントを購読できます。\n \n ```python\n from agents import AgentToolStreamEvent\n@@ -343,17 +343,17 @@ billing_agent_tool = billing_agent.as_tool(\n )\n ```\n \n-想定される動作:\n+想定される挙動:\n \n-- イベント種別は `StreamEvent[\"type\"]` を反映します: `raw_response_event`、`run_item_stream_event`、`agent_updated_stream_event`。\n-- `on_stream` を提供すると、ネストした エージェント は自動的にストリーミングモードで実行され、最終出力を返す前にストリームを排出します。\n-- ハンドラーは同期/非同期いずれでも可。各イベントは到着順に配信されます。\n-- ツール呼び出しがモデルのツールコール経由の場合は `tool_call_id` が存在します。直接呼び出しでは `None` の場合があります。\n+- イベント種別は `StreamEvent[\"type\"]` を踏襲します: `raw_response_event`、`run_item_stream_event`、`agent_updated_stream_event`。\n+- `on_stream` を指定すると、入れ子の エージェント は自動的にストリーミング モードで実行され、最終出力を返す前にストリームを読み切ります。\n+- ハンドラーは同期・非同期いずれでも構いません。各イベントは到着順に配送されます。\n+- ツールがモデルのツール呼び出し経由で起動された場合は `tool_call_id` が存在します。直接呼び出しの場合は `None` のことがあります。\n - 完全な実行可能サンプルは `examples/agent_patterns/agents_as_tools_streaming.py` を参照してください。\n \n-### 条件付きツール有効化\n+### 条件付きのツール有効化\n \n-実行時に `is_enabled` パラメーターを使用して、エージェント のツールを条件付きで有効化/無効化できます。これにより、コンテキスト、ユーザー の嗜好、実行時条件に基づいて、LLM に提供するツールを動的に絞り込めます。\n+実行時に `is_enabled` パラメーターで エージェント ツールを条件付きで有効・無効にできます。これにより、コンテキスト、ユーザー の設定、実行時条件に基づき、LLM に利用可能なツールを動的に絞り込めます。\n \n ```python\n import asyncio\n@@ -410,24 +410,24 @@ asyncio.run(main())\n \n `is_enabled` パラメーターは次を受け付けます。\n \n-- **真偽値**: `True`（常に有効）または `False`（常に無効）\n-- **関数**: `(context, agent)` を受け取り真偽値を返す関数\n-- **非同期関数**: 複雑な条件ロジック用の async 関数\n+-  **ブール値**: `True`（常に有効）または `False`（常に無効）\n+-  **呼び出し可能関数**: `(context, agent)` を受け取り真偽値を返す関数\n+-  **非同期関数**: 複雑な条件ロジック向けの async 関数\n \n-無効化されたツールは実行時に LLM から完全に隠されるため、次の用途に有用です。\n+無効化されたツールは実行時に LLM から完全に隠されます。以下の用途に有用です。\n \n - ユーザー 権限に基づく機能ゲーティング\n-- 環境固有（dev と prod）のツール可用性\n+- 環境別のツール可用性（開発 vs 本番）\n - ツール構成の A/B テスト\n - 実行時状態に基づく動的ツールフィルタリング\n \n ## 関数ツールでのエラー処理\n \n-`@function_tool` で関数ツールを作成する際、`failure_error_function` を渡せます。これは、ツール呼び出しがクラッシュした場合に LLM へエラーレスポンスを提供する関数です。\n+`@function_tool` で関数ツールを作成する際、`failure_error_function` を渡せます。これはツール呼び出しがクラッシュした場合に LLM へ返すエラーレスポンスを提供する関数です。\n \n-- 既定では（つまり何も渡さない場合）、エラーが発生したことを LLM に知らせる `default_tool_error_function` を実行します。\n-- 独自のエラー関数を渡した場合はそれが実行され、そのレスポンスが LLM に送られます。\n-- 明示的に `None` を渡した場合、ツール呼び出しエラーは再送出され、呼び出し側で処理する必要があります。モデルが不正な JSON を生成した場合は `ModelBehaviorError`、コードがクラッシュした場合は `UserError` などになり得ます。\n+-  既定（何も渡さない場合）は、エラーが発生したことを LLM に伝える `default_tool_error_function` が実行されます。\n+-  独自のエラー関数を渡すと、それが実行され、そのレスポンスが LLM に送信されます。\n+-  明示的に `None` を渡した場合、ツール呼び出しエラーは呼び出し元に再送出され、呼び出し側で処理します。モデルが不正な JSON を生成した場合の `ModelBehaviorError`、コードがクラッシュした場合の `UserError` などが該当します。\n \n ```python\n from agents import function_tool, RunContextWrapper\n@@ -450,4 +450,4 @@ def get_user_profile(user_id: str) -> str:\n \n ```\n \n-`FunctionTool` オブジェクトを手動で作成する場合は、`on_invoke_tool` 関数内でエラーを処理する必要があります。\n\\ No newline at end of file\n+`FunctionTool` オブジェクトを手動で作成している場合は、`on_invoke_tool` 関数内でエラー処理を行う必要があります。\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Ftools.md",
        "sha": "734f49c1952a417ee594952fe7e167739d2ce396",
        "status": "modified"
      },
      {
        "additions": 50,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Ftracing.md",
        "changes": 88,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fja%2Ftracing.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 38,
        "filename": "docs/ja/tracing.md",
        "patch": "@@ -4,52 +4,52 @@ search:\n ---\n # トレーシング\n \n-Agents SDK には組み込みのトレーシングが含まれており、エージェント実行中に発生するイベントの包括的な記録（ LLM 生成、ツール呼び出し、ハンドオフ、ガードレール、カスタムイベントなど）を収集します。 [Traces ダッシュボード](https://platform.openai.com/traces) を使用して、開発中および本番環境でワークフローをデバッグ、可視化、監視できます。\n+Agents SDK にはトレーシングが組み込まれており、エージェントの実行中に発生するイベントの包括的な記録（ LLM 生成、ツール呼び出し、ハンドオフ、ガードレール、さらに発生したカスタムイベント）を収集します。 [Traces ダッシュボード](https://platform.openai.com/traces) を使用して、開発中および本番環境でワークフローをデバッグ、可視化、監視できます。\n \n !!!note\n \n-    トレーシングはデフォルトで有効です。トレーシングを無効にする方法は 2 つあります。\n+    トレーシングはデフォルトで有効です。トレーシングを無効にする方法は 2 つあります:\n \n     1. 環境変数 `OPENAI_AGENTS_DISABLE_TRACING=1` を設定して、トレーシングをグローバルに無効化できます\n-    2. 単一の実行については、[`agents.run.RunConfig.tracing_disabled`][] を `True` に設定して無効化できます\n+    2. 1 回の実行に対しては、[`agents.run.RunConfig.tracing_disabled`][] を `True` に設定して無効化できます\n \n-***OpenAI の API を使用し Zero Data Retention（ ZDR ）ポリシーの下で運用している組織では、トレーシングは利用できません。***\n+***OpenAI の API を使用し Zero Data Retention (ZDR) ポリシーで運用している組織では、トレーシングは利用できません。***\n \n ## トレースとスパン\n \n--   **トレース（Traces）** は「ワークフロー」の単一のエンドツーエンド操作を表します。複数のスパンで構成されます。トレースには次のプロパティがあります。\n+-   **トレース** は「ワークフロー」の単一のエンドツーエンド操作を表します。スパンで構成されます。トレースには次のプロパティがあります:\n     -   `workflow_name`: 論理的なワークフローまたはアプリです。例: \"Code generation\" や \"Customer service\"\n-    -   `trace_id`: トレースの一意の ID。指定しない場合は自動生成されます。形式は `trace_<32_alphanumeric>` である必要があります。\n-    -   `group_id`: 任意のグループ ID。同じ会話からの複数のトレースを関連付けるために使用します。たとえばチャットスレッドの ID などです。\n+    -   `trace_id`: トレースの一意の ID。渡さない場合は自動生成されます。形式は `trace_<32_alphanumeric>` である必要があります。\n+    -   `group_id`: 任意のグループ ID。同じ会話からの複数のトレースをリンクするために使用します。例えば、チャットスレッド ID を使うことができます。\n     -   `disabled`: True の場合、このトレースは記録されません。\n     -   `metadata`: トレースの任意のメタデータ。\n--   **スパン（Spans）** は開始時刻と終了時刻を持つ操作を表します。スパンには次が含まれます。\n+-   **スパン** は開始時刻と終了時刻を持つ操作を表します。スパンには次があります:\n     -   `started_at` と `ended_at` のタイムスタンプ\n     -   所属するトレースを表す `trace_id`\n-    -   親スパン（存在する場合）を指す `parent_id`\n-    -   スパンに関する情報である `span_data`。たとえば、`AgentSpanData` はエージェントに関する情報、`GenerationSpanData` は LLM 生成に関する情報などを含みます。\n+    -   親スパンを指す `parent_id`（存在する場合）\n+    -   スパンに関する情報である `span_data`。例えば、`AgentSpanData` はエージェントに関する情報を、`GenerationSpanData` は LLM 生成に関する情報を含みます。\n \n ## デフォルトのトレーシング\n \n-デフォルトでは、 SDK は次をトレースします。\n+デフォルトでは、 SDK は次をトレースします:\n \n--   `Runner.{run, run_sync, run_streamed}()` 全体が `trace()` でラップされます\n+-   全体の `Runner.{run, run_sync, run_streamed}()` は `trace()` でラップされます。\n -   エージェントが実行されるたびに `agent_span()` でラップされます\n -   LLM 生成は `generation_span()` でラップされます\n--   関数ツールの呼び出しはそれぞれ `function_span()` でラップされます\n+-   関数ツール呼び出しはそれぞれ `function_span()` でラップされます\n -   ガードレールは `guardrail_span()` でラップされます\n -   ハンドオフは `handoff_span()` でラップされます\n -   音声入力（音声認識）は `transcription_span()` でラップされます\n -   音声出力（音声合成）は `speech_span()` でラップされます\n--   関連する音声スパンは `speech_group_span()` の下に親子付けされる場合があります\n+-   関連する音声スパンは `speech_group_span()` の配下に配置される場合があります\n \n-デフォルトでは、トレース名は \"Agent workflow\" です。`trace` を使用する場合はこの名前を設定できますし、[`RunConfig`][agents.run.RunConfig] で名前やその他のプロパティを構成することもできます。\n+デフォルトでは、トレース名は \"Agent workflow\" です。`trace` を使用する場合にこの名前を設定でき、または [`RunConfig`][agents.run.RunConfig] で名前やその他のプロパティを設定できます。\n \n-加えて、[カスタムトレースプロセッサー](#custom-tracing-processors) を設定して、トレースを別の宛先に送信できます（置き換えとして、または第 2 の宛先として）。\n+さらに、[カスタムトレースプロセッサー](#custom-tracing-processors) を設定して、トレースを他の宛先に送信できます（置き換えとして、またはセカンダリの宛先として）。\n \n-## 上位レベルのトレース\n+## 高レベルのトレース\n \n-`run()` を複数回呼び出す場合、それらを 1 つのトレースにまとめたいことがあります。これはコード全体を `trace()` でラップすることで実現できます。\n+`run()` への複数回の呼び出しを 1 つのトレースにまとめたい場合があります。これには、コード全体を `trace()` でラップします。\n \n ```python\n from agents import Agent, Runner, trace\n@@ -64,46 +64,46 @@ async def main():\n         print(f\"Rating: {second_result.final_output}\")\n ```\n \n-1. `Runner.run` への 2 回の呼び出しが `with trace()` でラップされているため、個々の実行は 2 つのトレースを作成するのではなく、全体のトレースの一部になります。\n+1. `Runner.run` への 2 回の呼び出しが `with trace()` でラップされているため、各実行は 2 つのトレースを作成するのではなく、全体のトレースの一部になります。\n \n ## トレースの作成\n \n-[`trace()`][agents.tracing.trace] 関数を使用してトレースを作成できます。トレースは開始と終了が必要です。方法は 2 つあります。\n+[`trace()`][agents.tracing.trace] 関数を使用してトレースを作成できます。トレースは開始と終了が必要です。次の 2 通りの方法があります:\n \n-1. 推奨: トレースをコンテキストマネージャとして使用します（例: `with trace(...) as my_trace`）。これにより適切なタイミングで自動的にトレースの開始と終了が行われます。\n-2. [`trace.start()`][agents.tracing.Trace.start] と [`trace.finish()`][agents.tracing.Trace.finish] を手動で呼び出すこともできます。\n+1. 推奨: トレースをコンテキストマネージャとして使用します（例: `with trace(...) as my_trace`）。これにより適切なタイミングで自動的に開始・終了します。\n+2. 手動で [`trace.start()`][agents.tracing.Trace.start] と [`trace.finish()`][agents.tracing.Trace.finish] を呼び出すこともできます。\n \n-現在のトレースは Python の [`contextvar`](https://docs.python.org/3/library/contextvars.html) を通じて追跡されます。これは自動的に並行処理で機能することを意味します。トレースを手動で開始/終了する場合は、現在のトレースを更新するために `start()`/`finish()` に `mark_as_current` と `reset_current` を渡す必要があります。\n+現在のトレースは Python の [`contextvar`](https://docs.python.org/3/library/contextvars.html) で追跡されます。これは自動的に並行処理で機能することを意味します。トレースを手動で開始/終了する場合、現在のトレースを更新するために `start()`/`finish()` に `mark_as_current` と `reset_current` を渡す必要があります。\n \n ## スパンの作成\n \n-各種の [`*_span()`][agents.tracing.create] メソッドを使用してスパンを作成できます。一般的には、スパンを手動で作成する必要はありません。カスタムのスパン情報を追跡するための [`custom_span()`][agents.tracing.custom_span] 関数が利用可能です。\n+さまざまな [`*_span()`][agents.tracing.create] メソッドを使用してスパンを作成できます。一般に、スパンを手動で作成する必要はありません。カスタムスパン情報を追跡するための [`custom_span()`][agents.tracing.custom_span] 関数が利用可能です。\n \n-スパンは自動的に現在のトレースに属し、さらに Python の [`contextvar`](https://docs.python.org/3/library/contextvars.html) を通じて追跡される最も近い現在のスパンの下にネストされます。\n+スパンは自動的に現在のトレースの一部となり、 Python の [`contextvar`](https://docs.python.org/3/library/contextvars.html) で追跡される最も近い現在のスパンの配下にネストされます。\n \n ## 機微なデータ\n \n-一部のスパンは機微なデータを取得する可能性があります。\n+特定のスパンは機微なデータを取得する可能性があります。\n \n-`generation_span()` は LLM 生成の入出力を保存し、`function_span()` は関数呼び出しの入出力を保存します。これらに機微なデータが含まれる可能性があるため、[`RunConfig.trace_include_sensitive_data`][agents.run.RunConfig.trace_include_sensitive_data] によってこれらのデータの取得を無効化できます。\n+`generation_span()` は LLM 生成の入力/出力を保存し、`function_span()` は関数呼び出しの入力/出力を保存します。これらには機微なデータが含まれる可能性があるため、[`RunConfig.trace_include_sensitive_data`][agents.run.RunConfig.trace_include_sensitive_data] を使用してそのデータの取得を無効化できます。\n \n-同様に、音声スパンにはデフォルトで入出力の音声に対する base64 エンコードの PCM データが含まれます。[`VoicePipelineConfig.trace_include_sensitive_audio_data`][agents.voice.pipeline_config.VoicePipelineConfig.trace_include_sensitive_audio_data] を設定して、この音声データの取得を無効化できます。\n+同様に、音声スパンにはデフォルトで入力および出力音声の base64 エンコードされた PCM データが含まれます。[`VoicePipelineConfig.trace_include_sensitive_audio_data`][agents.voice.pipeline_config.VoicePipelineConfig.trace_include_sensitive_audio_data] を設定して、この音声データの取得を無効化できます。\n \n ## カスタムトレーシングプロセッサー\n \n-トレーシングの大まかなアーキテクチャは次のとおりです。\n+トレーシングの高レベルなアーキテクチャは次のとおりです:\n \n--   初期化時にグローバルな [`TraceProvider`][agents.tracing.setup.TraceProvider] を作成します。これはトレースの作成を担当します。\n--   `TraceProvider` を [`BatchTraceProcessor`][agents.tracing.processors.BatchTraceProcessor] で構成し、これがトレース/スパンをバッチで [`BackendSpanExporter`][agents.tracing.processors.BackendSpanExporter] に送信します。`BackendSpanExporter` はスパンとトレースを OpenAI バックエンドにバッチでエクスポートします。\n+-   初期化時に、トレース作成を担当するグローバルな [`TraceProvider`][agents.tracing.setup.TraceProvider] を作成します。\n+-   `TraceProvider` に [`BatchTraceProcessor`][agents.tracing.processors.BatchTraceProcessor] を設定し、[`BackendSpanExporter`][agents.tracing.processors.BackendSpanExporter] にスパン/トレースをバッチ送信します。`BackendSpanExporter` はスパンとトレースをバッチで OpenAI バックエンドにエクスポートします。\n \n-このデフォルト設定をカスタマイズして、別のバックエンドへの送信や追加のバックエンドへの送信、エクスポーターの動作変更を行うには、次の 2 つの方法があります。\n+デフォルトのセットアップをカスタマイズして、別のバックエンドや追加のバックエンドにトレースを送信したり、エクスポーターの動作を変更したりするには、次の 2 つの方法があります:\n \n-1. [`add_trace_processor()`][agents.tracing.add_trace_processor] は、トレースとスパンが準備でき次第受け取る、追加のトレースプロセッサーを追加できます。これにより、 OpenAI のバックエンドへの送信に加えて独自の処理を行えます。\n-2. [`set_trace_processors()`][agents.tracing.set_trace_processors] は、デフォルトのプロセッサーを独自のトレースプロセッサーに置き換えられます。つまり、 OpenAI バックエンドにトレースを送信する `TracingProcessor` を含めない限り、トレースは OpenAI バックエンドに送信されません。\n+1. [`add_trace_processor()`][agents.tracing.add_trace_processor] は、トレースやスパンが準備できたときに受け取る **追加の** トレースプロセッサーを追加できます。これにより、 OpenAI のバックエンドにトレースを送信することに加えて、独自の処理を実行できます。\n+2. [`set_trace_processors()`][agents.tracing.set_trace_processors] は、デフォルトのプロセッサーを独自のトレースプロセッサーに **置き換え** られます。つまり、 OpenAI バックエンドにトレースを送信する `TracingProcessor` を含めない限り、トレースは OpenAI バックエンドに送信されません。\n \n-## OpenAI 以外のモデルでのトレーシング\n+## 非 OpenAI モデルでのトレーシング\n \n-OpenAI の API キーを OpenAI 以外のモデルで使用して、トレーシングを無効化することなく OpenAI Traces ダッシュボードで無料のトレーシングを有効にできます。\n+トレーシングを無効化することなく、 OpenAI の Traces ダッシュボードで無料のトレーシングを有効にするために、非 OpenAI モデルでも OpenAI API キーを使用できます。\n \n ```python\n import os\n@@ -124,8 +124,20 @@ agent = Agent(\n )\n ```\n \n-## 注記\n-- Openai Traces ダッシュボードで無料のトレースを表示します。\n+単一の実行に対してのみ異なるトレーシングキーが必要な場合は、グローバルなエクスポーターを変更する代わりに `RunConfig` 経由で渡してください。\n+\n+```python\n+from agents import Runner, RunConfig\n+\n+await Runner.run(\n+    agent,\n+    input=\"Hello\",\n+    run_config=RunConfig(tracing={\"api_key\": \"sk-tracing-123\"}),\n+)\n+```\n+\n+## 注意事項\n+- OpenAI Traces ダッシュボードで無料のトレースを表示できます。\n \n ## 外部トレーシングプロセッサー一覧\n ",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Ftracing.md",
        "sha": "505a9cb663ec9302326b199dbb0bb8ecf074f3ac",
        "status": "modified"
      },
      {
        "additions": 23,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Fusage.md",
        "changes": 46,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fja%2Fusage.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 23,
        "filename": "docs/ja/usage.md",
        "patch": "@@ -2,24 +2,24 @@\n search:\n   exclude: true\n ---\n-# 使用状況\n+# 使用量\n \n-Agents SDK は、すべての実行に対してトークン使用状況を自動で追跡します。実行コンテキストから参照でき、コスト監視、上限制御、分析記録に利用できます。\n+Agents SDK は、すべての実行ごとにトークン使用量を自動追跡します。実行コンテキストから参照でき、コスト監視、制限の適用、分析の記録に利用できます。\n \n ## 追跡対象\n \n-- **requests**: 実行された LLM API 呼び出し回数\n-- **input_tokens**: 送信された入力トークン合計\n-- **output_tokens**: 受信した出力トークン合計\n-- **total_tokens**: 入力 + 出力\n-- **request_usage_entries**: リクエストごとの使用状況内訳一覧\n+- **requests**: 実行された LLM API 呼び出しの数\n+- **input_tokens**: 送信された入力トークンの合計\n+- **output_tokens**: 受信した出力トークンの合計\n+- **total_tokens**: input + output\n+- **request_usage_entries**: リクエストごとの使用量内訳のリスト\n - **details**:\n   - `input_tokens_details.cached_tokens`\n   - `output_tokens_details.reasoning_tokens`\n \n-## 実行からの使用状況の取得\n+## 実行からの使用量の取得\n \n-`Runner.run(...)` の後、`result.context_wrapper.usage` から使用状況にアクセスします。\n+`Runner.run(...)` の後、`result.context_wrapper.usage` から使用量にアクセスします。\n \n ```python\n result = await Runner.run(agent, \"What's the weather in Tokyo?\")\n@@ -31,11 +31,11 @@ print(\"Output tokens:\", usage.output_tokens)\n print(\"Total tokens:\", usage.total_tokens)\n ```\n \n-使用状況は、実行中のすべてのモデル呼び出し（ツール呼び出しやハンドオフを含む）にわたって集計されます。\n+実行中のすべてのモデル呼び出し（ツール呼び出しやハンドオフを含む）にわたって使用量が集計されます。\n \n-### LiteLLM モデルでの使用状況の有効化\n+### LiteLLM モデルでの使用量有効化\n \n-LiteLLM プロバイダーは既定では使用状況メトリクスを報告しません。[`LitellmModel`](models/litellm.md) を使用する場合、エージェントに `ModelSettings(include_usage=True)` を渡すと、LiteLLM のレスポンスが `result.context_wrapper.usage` に反映されます。\n+LiteLLM プロバイダーは既定では使用量メトリクスを報告しません。[`LitellmModel`](models/litellm.md) を使用する場合、`ModelSettings(include_usage=True)` をエージェントに渡すと、LiteLLM のレスポンスが `result.context_wrapper.usage` に反映されます。\n \n ```python\n from agents import Agent, ModelSettings, Runner\n@@ -51,9 +51,9 @@ result = await Runner.run(agent, \"What's the weather in Tokyo?\")\n print(result.context_wrapper.usage.total_tokens)\n ```\n \n-## リクエスト単位の使用状況トラッキング\n+## リクエスト単位の使用量トラッキング\n \n-SDK は `request_usage_entries` に各 API リクエストの使用状況を自動追跡します。詳細なコスト計算やコンテキストウィンドウ消費の監視に便利です。\n+SDK は `request_usage_entries` に各 API リクエストの使用量を自動追跡します。詳細なコスト計算やコンテキストウィンドウ消費の監視に有用です。\n \n ```python\n result = await Runner.run(agent, \"What's the weather in Tokyo?\")\n@@ -62,9 +62,9 @@ for i, request in enumerate(result.context_wrapper.usage.request_usage_entries):\n     print(f\"Request {i + 1}: {request.input_tokens} in, {request.output_tokens} out\")\n ```\n \n-## セッションでの使用状況の取得\n+## セッションでの使用量の取得\n \n-`Session`（例: `SQLiteSession`）を使用する場合、`Runner.run(...)` の各呼び出しはその実行に固有の使用状況を返します。セッションはコンテキストのための会話履歴を保持しますが、各実行の使用状況は独立しています。\n+`Session`（例: `SQLiteSession`）を使用する場合、`Runner.run(...)` への各呼び出しは、その実行に特有の使用量を返します。セッションは文脈用の会話履歴を維持しますが、各実行の使用量は独立しています。\n \n ```python\n session = SQLiteSession(\"my_conversation\")\n@@ -76,11 +76,11 @@ second = await Runner.run(agent, \"Can you elaborate?\", session=session)\n print(second.context_wrapper.usage.total_tokens)  # Usage for second run\n ```\n \n-セッションは実行間で会話コンテキストを保持しますが、各 `Runner.run()` 呼び出しで返される使用状況メトリクスは、その実行に限られます。セッションでは、前のメッセージが各実行の入力として再投入される場合があり、その結果として後続ターンの入力トークン数に影響します。\n+セッションは実行間で会話コンテキストを保持しますが、各 `Runner.run()` 呼び出しで返される使用量メトリクスは、そのときの実行結果のみを表します。セッションでは、前のメッセージが各実行の入力として再投入されることがあり、その結果、後続ターンの入力トークン数に影響します。\n \n-## フックでの使用状況の利用\n+## フックでの使用量の利用\n \n-`RunHooks` を使用している場合、各フックに渡される `context` オブジェクトには `usage` が含まれます。これにより、重要なライフサイクルのタイミングで使用状況を記録できます。\n+`RunHooks` を使用している場合、各フックに渡される `context` オブジェクトは `usage` を含みます。これにより、重要なライフサイクル時点で使用量を記録できます。\n \n ```python\n class MyHooks(RunHooks):\n@@ -93,7 +93,7 @@ class MyHooks(RunHooks):\n \n 詳細な API ドキュメントは以下を参照してください。\n \n-- [`Usage`][agents.usage.Usage] - 使用状況トラッキングのデータ構造\n-- [`RequestUsage`][agents.usage.RequestUsage] - リクエストごとの使用状況の詳細\n-- [`RunContextWrapper`][agents.run.RunContextWrapper] - 実行コンテキストから使用状況にアクセス\n-- [`RunHooks`][agents.run.RunHooks] - 使用状況トラッキングのライフサイクルにフック\n\\ No newline at end of file\n+-   [`Usage`][agents.usage.Usage] - 使用量トラッキングのデータ構造\n+-   [`RequestUsage`][agents.usage.RequestUsage] - リクエスト単位の使用量詳細\n+-   [`RunContextWrapper`][agents.run.RunContextWrapper] - 実行コンテキストからの使用量アクセス\n+-   [`RunHooks`][agents.run.RunHooks] - 使用量トラッキングのライフサイクルにフックする\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Fusage.md",
        "sha": "7ca32c6f4f289b2843b4bba6f93f1bc70ebb0a0d",
        "status": "modified"
      },
      {
        "additions": 20,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Fvisualization.md",
        "changes": 39,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fja%2Fvisualization.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 19,
        "filename": "docs/ja/visualization.md",
        "patch": "@@ -2,26 +2,26 @@\n search:\n   exclude: true\n ---\n-# エージェントの可視化\n+# エージェント可視化\n \n-エージェントの可視化では、 **Graphviz** を使用してエージェントとその関係の構造化されたグラフィカル表現を生成できます。これは、アプリケーション内でエージェント、ツール、ハンドオフがどのように相互作用するかを理解するのに役立ちます。\n+エージェントの可視化では、 **Graphviz** を使用してエージェントとその関係の構造化されたグラフィカル表現を生成できます。これは、アプリケーション内でエージェント、ツール、ハンドオフがどのように連携するかを理解するのに役立ちます。\n \n ## インストール\n \n-オプションの `viz` 依存関係グループをインストールします:\n+任意の `viz` 依存関係グループをインストールします:\n \n ```bash\n pip install \"openai-agents[viz]\"\n ```\n \n-## グラフの生成\n+## グラフ生成\n \n-`draw_graph` 関数を使用してエージェントの可視化を生成できます。この関数は次の構成を持つ有向グラフを作成します:\n+`draw_graph` 関数を使用してエージェントの可視化を生成できます。この関数は有向グラフを作成し、以下のように表現します:\n \n - **エージェント** は黄色のボックスで表されます。\n - **MCP サーバー** は灰色のボックスで表されます。\n - **ツール** は緑色の楕円で表されます。\n-- **ハンドオフ** はあるエージェントから別のエージェントへの有向エッジです。\n+- **ハンドオフ** は、あるエージェントから別のエージェントへの有向エッジで表されます。\n \n ### 使用例\n \n@@ -67,30 +67,31 @@ triage_agent = Agent(\n draw_graph(triage_agent)\n ```\n \n-![エージェント グラフ](../assets/images/graph.png)\n+![エージェントグラフ](../assets/images/graph.png)\n+\n+これは、 **トリアージ エージェント** とそのサブエージェントおよびツールへの接続を視覚的に表すグラフを生成します。\n \n-これにより、 **トリアージ エージェント** と、そのサブエージェントやツールへの接続の構造を視覚的に表すグラフが生成されます。\n \n ## 可視化の理解\n \n-生成されるグラフには次が含まれます:\n+生成されるグラフには以下が含まれます:\n \n-- 入口を示す **開始ノード** (`__start__`)\n-- 黄色で塗られた **長方形** として表されるエージェント\n-- 緑色で塗られた **楕円** として表されるツール\n-- 灰色で塗られた **長方形** として表される MCP サーバー\n+- エントリーポイントを示す **開始ノード** (`__start__`)\n+- 黄色で塗りつぶされた **長方形** のエージェント\n+- 緑で塗りつぶされた **楕円** のツール\n+- 灰色で塗りつぶされた **長方形** の MCP サーバー\n - 相互作用を示す有向エッジ:\n-  - エージェント間のハンドオフには **実線の矢印**\n-  - ツール呼び出しには **点線の矢印**\n-  - MCP サーバー呼び出しには **破線の矢印**\n-- 実行の終了箇所を示す **終了ノード** (`__end__`)\n+  - エージェント間のハンドオフは **実線の矢印**\n+  - ツールの呼び出しは **点線の矢印**\n+  - MCP サーバーの呼び出しは **破線の矢印**\n+- 実行の終了地点を示す **終了ノード** (`__end__`)\n \n-**注:** MCP サーバーは最近の `agents` パッケージのバージョンでレンダリングされます（ **v0.2.8** で確認済み）。可視化に MCP のボックスが表示されない場合は、最新版にアップグレードしてください。\n+**注意:** MCP サーバーは、最近の `agents` パッケージのバージョンでレンダリングされます（ **v0.2.8** で確認済み）。可視化に MCP のボックスが表示されない場合は、最新リリースにアップグレードしてください。\n \n ## グラフのカスタマイズ\n \n ### グラフの表示\n-デフォルトでは、`draw_graph` はグラフをインライン表示します。グラフを別ウィンドウで表示するには、次のようにします:\n+デフォルトでは、`draw_graph` はグラフをインライン表示します。別ウィンドウで表示するには、次のように記述します:\n \n ```python\n draw_graph(triage_agent).view()",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Fvisualization.md",
        "sha": "8e81449451c967e9694d990e27b3d2169f2b3e0f",
        "status": "modified"
      },
      {
        "additions": 14,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Fvoice%2Fpipeline.md",
        "changes": 28,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fja%2Fvoice%2Fpipeline.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 14,
        "filename": "docs/ja/voice/pipeline.md",
        "patch": "@@ -4,7 +4,7 @@ search:\n ---\n # パイプラインとワークフロー\n \n-[`VoicePipeline`][agents.voice.pipeline.VoicePipeline] は、エージェント型ワークフローを音声アプリに簡単に変換できるクラスです。実行するワークフローを渡すと、パイプラインが入力音声の文字起こし、音声の終了検出、適切なタイミングでのワークフロー呼び出し、そしてワークフロー出力の音声化までを処理します。\n+[`VoicePipeline`][agents.voice.pipeline.VoicePipeline] は、エージェント型のワークフローを音声アプリにするのを容易にするクラスです。実行するワークフローを渡すと、入力音声の書き起こし、音声の終了検出、適切なタイミングでのワークフロー呼び出し、そしてワークフロー出力を音声へ戻すまでをパイプラインが処理します。\n \n ```mermaid\n graph LR\n@@ -34,29 +34,29 @@ graph LR\n \n ## パイプラインの設定\n \n-パイプラインを作成するとき、次の項目を設定できます。\n+パイプラインを作成する際には、次の項目を設定できます。\n \n-1. 新しい音声が文字起こしされるたびに実行されるコードである [`workflow`][agents.voice.workflow.VoiceWorkflowBase]\n+1. [`workflow`][agents.voice.workflow.VoiceWorkflowBase]: 新しい音声が書き起こされるたびに実行されるコードです。\n 2. 使用する [`speech-to-text`][agents.voice.model.STTModel] と [`text-to-speech`][agents.voice.model.TTSModel] のモデル\n-3. 次のような項目を設定できる [`config`][agents.voice.pipeline_config.VoicePipelineConfig]\n-    - モデル名をモデルにマッピングできるモデルプロバイダー\n-    - トレーシング（トレーシングの無効化、音声ファイルのアップロード可否、ワークフロー名、トレース ID など）\n-    - TTS と STT モデルの設定（プロンプト、言語、使用するデータ型 など）\n+3. [`config`][agents.voice.pipeline_config.VoicePipelineConfig]: 次のような設定が可能です。\n+    - モデルプロバイダー。モデル名をモデルにマッピングできます\n+    - トレーシング。トレーシングの無効化、音声ファイルのアップロード有無、ワークフロー名、トレース ID など\n+    - TTS と STT のモデル設定。プロンプト、言語、使用するデータ型など\n \n ## パイプラインの実行\n \n パイプラインは [`run()`][agents.voice.pipeline.VoicePipeline.run] メソッドで実行でき、音声入力を次の 2 つの形式で渡せます。\n \n-1. [`AudioInput`][agents.voice.input.AudioInput] は、完全な音声の文字起こしがあり、その結果だけを生成したい場合に使用します。これは、話者が話し終えたタイミングを検出する必要がないケース、たとえば事前録音の音声や、ユーザーが話し終えたことが明確なプッシュトゥトークのアプリで有用です。\n-2. [`StreamedAudioInput`][agents.voice.input.StreamedAudioInput] は、ユーザーが話し終えたタイミングを検出する必要がある場合に使用します。検出された音声チャンクを逐次プッシュでき、音声パイプラインは「アクティビティ検出」と呼ばれるプロセスにより、適切なタイミングでエージェントのワークフローを自動的に実行します。\n+1. [`AudioInput`][agents.voice.input.AudioInput]: 完全な音声を書き起こしたテキストがあり、その結果だけを生成したい場合に使用します。話者が話し終えるタイミングを検出する必要がないケースに有用です。たとえば、事前録音の音声がある場合や、ユーザーが話し終えるタイミングが明確なプッシュトゥトーク型のアプリなどです。\n+2. [`StreamedAudioInput`][agents.voice.input.StreamedAudioInput]: ユーザーが話し終えたかどうかを検出する必要がある場合に使用します。検出された音声チャンクを順次プッシュでき、音声パイプラインは「アクティビティ検出」と呼ばれるプロセスにより適切なタイミングで自動的にエージェントのワークフローを実行します。\n \n ## 結果\n \n-音声パイプライン実行の結果は [`StreamedAudioResult`][agents.voice.result.StreamedAudioResult] です。これは、発生したイベントをストリーミングできるオブジェクトです。いくつかの種類の [`VoiceStreamEvent`][agents.voice.events.VoiceStreamEvent] があり、以下が含まれます。\n+音声パイプラインの実行結果は [`StreamedAudioResult`][agents.voice.result.StreamedAudioResult] です。これは、発生するイベントをストリーミングできるオブジェクトです。いくつかの種類の [`VoiceStreamEvent`][agents.voice.events.VoiceStreamEvent] があり、次を含みます。\n \n-1. 音声チャンクを含む [`VoiceStreamEventAudio`][agents.voice.events.VoiceStreamEventAudio]\n-2. ターンの開始や終了といったライフサイクルイベントを通知する [`VoiceStreamEventLifecycle`][agents.voice.events.VoiceStreamEventLifecycle]\n-3. エラーイベントである [`VoiceStreamEventError`][agents.voice.events.VoiceStreamEventError]\n+1. [`VoiceStreamEventAudio`][agents.voice.events.VoiceStreamEventAudio]: 音声チャンクを含みます。\n+2. [`VoiceStreamEventLifecycle`][agents.voice.events.VoiceStreamEventLifecycle]: ターンの開始や終了などのライフサイクルイベントを通知します。\n+3. [`VoiceStreamEventError`][agents.voice.events.VoiceStreamEventError]: エラーイベントです。\n \n ```python\n \n@@ -76,4 +76,4 @@ async for event in result.stream():\n \n ### 割り込み\n \n-Agents SDK は現在、[`StreamedAudioInput`][agents.voice.input.StreamedAudioInput] に対する組み込みの割り込みサポートを提供していません。代わりに、検出された各ターンごとに、ワークフローの個別の実行がトリガーされます。アプリケーション内で割り込みを処理したい場合は、[`VoiceStreamEventLifecycle`][agents.voice.events.VoiceStreamEventLifecycle] イベントを監視してください。`turn_started` は新しいターンが文字起こしされ処理が開始されたことを示します。`turn_ended` は該当ターンのすべての音声がディスパッチされた後にトリガーされます。これらのイベントを使って、モデルがターンを開始したときに話者のマイクをミュートし、そのターンに関連する音声をすべてフラッシュした後にマイクをアンミュートするといった制御が可能です。\n\\ No newline at end of file\n+Agents SDK は現時点で [`StreamedAudioInput`][agents.voice.input.StreamedAudioInput] に対する組み込みの割り込み処理をサポートしていません。代わりに、検出された各ターンごとに、ワークフローの個別の実行がトリガーされます。アプリケーション内で割り込みに対応したい場合は、[`VoiceStreamEventLifecycle`][agents.voice.events.VoiceStreamEventLifecycle] イベントをリッスンしてください。`turn_started` は新しいターンが書き起こされ処理が開始されたことを示します。`turn_ended` は該当ターンの音声がすべて送出された後にトリガーされます。これらのイベントを使って、モデルがターンを開始した際に話者のマイクをミュートし、ターンに関連する音声をすべてフラッシュした後にミュートを解除するといった制御が可能です。\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Fvoice%2Fpipeline.md",
        "sha": "b5c9ce797a56dc8ff625c766a59416123691ef3f",
        "status": "modified"
      },
      {
        "additions": 9,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Fvoice%2Fquickstart.md",
        "changes": 18,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fja%2Fvoice%2Fquickstart.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 9,
        "filename": "docs/ja/voice/quickstart.md",
        "patch": "@@ -4,21 +4,21 @@ search:\n ---\n # クイックスタート\n \n-## 事前準備\n+## 前提条件\n \n-OpenAI Agents SDK のベースの[クイックスタート手順](../quickstart.md)に従い、仮想環境を設定してください。次に、 SDK から音声のオプション依存関係をインストールします:\n+Agents SDK の基本の[クイックスタート手順](../quickstart.md)に従い、仮想環境をセットアップしていることを確認してください。次に、SDK から音声のオプション依存関係をインストールします:\n \n ```bash\n pip install 'openai-agents[voice]'\n ```\n \n ## 概念\n \n-主に知っておくべき概念は、[`VoicePipeline`][agents.voice.pipeline.VoicePipeline] です。これは 3 段階のプロセスです:\n+主な概念は [`VoicePipeline`][agents.voice.pipeline.VoicePipeline] で、3 ステップのプロセスです:\n \n-1. 音声認識モデルで音声をテキストに変換します。\n-2. 通常はエージェント的なワークフローであるあなたのコードを実行し、結果を生成します。\n-3. 音声合成モデルで結果のテキストを音声に戻します。\n+1. 音声をテキストに変換するために音声認識（speech-to-text）モデルを実行します。\n+2. 通常はエージェント主導のワークフローであるコードを実行して、結果を生成します。\n+3. 結果のテキストを音声に戻すために音声合成（text-to-speech）モデルを実行します。\n \n ```mermaid\n graph LR\n@@ -48,7 +48,7 @@ graph LR\n \n ## エージェント\n \n-まず、いくつかのエージェントを設定します。これは、この SDK でエージェントを作成したことがある方には馴染みがあるはずです。ここでは、2 つのエージェント、ハンドオフ、そして 1 つのツールを用意します。\n+まず、いくつかのエージェントを設定します。これは、この SDK でエージェントを作成したことがあれば馴染みがあるはずです。複数のエージェント、ハンドオフ、そしてツールを用意します。\n \n ```python\n import asyncio\n@@ -92,7 +92,7 @@ agent = Agent(\n \n ## 音声パイプライン\n \n-ワークフローとして [`SingleAgentVoiceWorkflow`][agents.voice.workflow.SingleAgentVoiceWorkflow] を使い、シンプルな音声パイプラインを設定します。\n+[`SingleAgentVoiceWorkflow`][agents.voice.workflow.SingleAgentVoiceWorkflow] をワークフローとして使用し、シンプルな音声パイプラインを設定します。\n \n ```python\n from agents.voice import SingleAgentVoiceWorkflow, VoicePipeline\n@@ -195,4 +195,4 @@ if __name__ == \"__main__\":\n     asyncio.run(main())\n ```\n \n-この例を実行すると、エージェントがあなたに話しかけます。自分でエージェントに話しかけられるデモは、[examples/voice/static](https://github.com/openai/openai-agents-python/tree/main/examples/voice/static) をご覧ください。\n\\ No newline at end of file\n+この例を実行すると、エージェントがあなたに話しかけます。自分でエージェントに話しかけられるデモは、[examples/voice/static](https://github.com/openai/openai-agents-python/tree/main/examples/voice/static) を参照してください。\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Fvoice%2Fquickstart.md",
        "sha": "78b1612251d05d4a65608d82aa95b1bbc9483b3f",
        "status": "modified"
      },
      {
        "additions": 9,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Fvoice%2Ftracing.md",
        "changes": 18,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fja%2Fvoice%2Ftracing.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 9,
        "filename": "docs/ja/voice/tracing.md",
        "patch": "@@ -4,15 +4,15 @@ search:\n ---\n # トレーシング\n \n-[エージェントのトレーシング](../tracing.md) と同様に、音声パイプラインも自動的にトレーシングされます。\n+[エージェントのトレーシング](../tracing.md) と同様に、音声パイプラインも自動でトレーシングされます。\n \n-基本的なトレーシング情報は上記のドキュメントをご確認ください。さらに、[`VoicePipelineConfig`][agents.voice.pipeline_config.VoicePipelineConfig] を通じてパイプラインのトレーシングを設定できます。\n+基本的なトレーシング情報は上記のドキュメントをご参照ください。加えて、[`VoicePipelineConfig`][agents.voice.pipeline_config.VoicePipelineConfig] を通じてパイプラインのトレーシングを設定できます。\n \n-主なトレーシング関連フィールドは次のとおりです:\n+トレーシング関連の主なフィールドは次のとおりです:\n \n-- [`tracing_disabled`][agents.voice.pipeline_config.VoicePipelineConfig.tracing_disabled]: トレーシングを無効化するかどうかを制御します。既定ではトレーシングは有効です。\n-- [`trace_include_sensitive_data`][agents.voice.pipeline_config.VoicePipelineConfig.trace_include_sensitive_data]: 音声の書き起こしのような機微情報をトレースに含めるかどうかを制御します。これは音声パイプライン専用で、ワークフロー内部で行われる処理には適用されません。\n-- [`trace_include_sensitive_audio_data`][agents.voice.pipeline_config.VoicePipelineConfig.trace_include_sensitive_audio_data]: 音声データをトレースに含めるかどうかを制御します。\n-- [`workflow_name`][agents.voice.pipeline_config.VoicePipelineConfig.workflow_name]: トレース ワークフローの名前です。\n-- [`group_id`][agents.voice.pipeline_config.VoicePipelineConfig.group_id]: 複数のトレースを関連付けるためのトレースの `group_id` です。\n-- [`trace_metadata`][agents.voice.pipeline_config.VoicePipelineConfig.tracing_disabled]: トレースに含める追加のメタデータです。\n\\ No newline at end of file\n+-   [`tracing_disabled`][agents.voice.pipeline_config.VoicePipelineConfig.tracing_disabled]: トレーシングを無効化するかどうかを制御します。既定では有効です。\n+-   [`trace_include_sensitive_data`][agents.voice.pipeline_config.VoicePipelineConfig.trace_include_sensitive_data]: 音声書き起こしなど、機微な可能性のあるデータをトレースに含めるかどうかを制御します。これは音声パイプラインに固有で、ワークフロー内部で行われる処理には適用されません。\n+-   [`trace_include_sensitive_audio_data`][agents.voice.pipeline_config.VoicePipelineConfig.trace_include_sensitive_audio_data]: トレースに音声データを含めるかどうかを制御します。\n+-   [`workflow_name`][agents.voice.pipeline_config.VoicePipelineConfig.workflow_name]: トレースのワークフロー名です。\n+-   [`group_id`][agents.voice.pipeline_config.VoicePipelineConfig.group_id]: 複数のトレースを関連付けるためのトレースの `group_id` です。\n+-   [`trace_metadata`][agents.voice.pipeline_config.VoicePipelineConfig.tracing_disabled]: トレースに含める追加のメタデータです。\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fja%2Fvoice%2Ftracing.md",
        "sha": "434c9e1beb8738302e2caa56ee44e0c768ab49d6",
        "status": "modified"
      },
      {
        "additions": 27,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Fagents.md",
        "changes": 54,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fko%2Fagents.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 27,
        "filename": "docs/ko/agents.md",
        "patch": "@@ -4,14 +4,14 @@ search:\n ---\n # 에이전트\n \n-에이전트는 앱의 핵심 기본 구성 요소입니다. 에이전트는 instructions 와 도구로 구성된 대형 언어 모델(LLM)입니다.\n+에이전트는 앱의 핵심 구성 요소입니다. 에이전트는 instructions 와 tools 로 구성된 대규모 언어 모델 (LLM) 입니다.\n \n ## 기본 구성\n \n-에이전트에서 가장 일반적으로 설정하는 속성은 다음과 같습니다:\n+가장 일반적으로 구성하는 에이전트 속성은 다음과 같습니다:\n \n - `name`: 에이전트를 식별하는 필수 문자열\n-- `instructions`: 개발자 메시지 또는 시스템 프롬프트라고도 함\n+- `instructions`: developer message 또는 시스템 프롬프트라고도 함\n - `model`: 사용할 LLM 및 temperature, top_p 등 모델 튜닝 매개변수를 설정하는 선택적 `model_settings`\n - `tools`: 에이전트가 작업을 수행하기 위해 사용할 수 있는 도구\n \n@@ -33,7 +33,7 @@ agent = Agent(\n \n ## 컨텍스트\n \n-에이전트는 `context` 타입에 대해 제네릭입니다. 컨텍스트는 의존성 주입 도구로, `Runner.run()`에 전달하기 위해 생성하는 객체이며 모든 에이전트, 도구, 핸드오프 등에 전달되어 에이전트 실행을 위한 의존성과 상태를 담는 저장소 역할을 합니다. 컨텍스트로는 어떤 Python 객체든 제공할 수 있습니다.\n+에이전트는 `context` 타입에 대해 제네릭합니다. 컨텍스트는 의존성 주입 도구로, 여러분이 생성하여 `Runner.run()` 에 전달하는 객체이며 모든 에이전트, 도구, 핸드오프 등에 전달되어 에이전트 실행을 위한 의존성과 상태 모음 역할을 합니다. 컨텍스트로는 임의의 Python 객체를 제공할 수 있습니다.\n \n ```python\n @dataclass\n@@ -52,7 +52,7 @@ agent = Agent[UserContext](\n \n ## 출력 타입\n \n-기본적으로 에이전트는 일반 텍스트(즉, `str`) 출력을 생성합니다. 에이전트가 특정 타입의 출력을 생성하도록 하려면 `output_type` 매개변수를 사용할 수 있습니다. 일반적인 선택은 [Pydantic](https://docs.pydantic.dev/) 객체를 사용하는 것이지만, Pydantic [TypeAdapter](https://docs.pydantic.dev/latest/api/type_adapter/)로 래핑할 수 있는 모든 타입(데이터클래스, 리스트, TypedDict 등)을 지원합니다.\n+기본적으로 에이전트는 일반 텍스트(즉, `str`) 출력을 생성합니다. 에이전트가 특정 타입의 출력을 생성하도록 하려면 `output_type` 매개변수를 사용할 수 있습니다. 일반적인 선택은 [Pydantic](https://docs.pydantic.dev/) 객체를 사용하는 것이지만, Pydantic [TypeAdapter](https://docs.pydantic.dev/latest/api/type_adapter/) 로 감쌀 수 있는 모든 타입을 지원합니다. 예: dataclass, 리스트, TypedDict 등\n \n ```python\n from pydantic import BaseModel\n@@ -73,20 +73,20 @@ agent = Agent(\n \n !!! note\n \n-    `output_type`을 전달하면, 일반 텍스트 응답 대신 [structured outputs](https://platform.openai.com/docs/guides/structured-outputs)를 사용하도록 모델에 지시합니다.\n+    `output_type` 을 전달하면 모델이 일반 텍스트 응답 대신 [structured outputs](https://platform.openai.com/docs/guides/structured-outputs) 를 사용하도록 지시합니다.\n \n ## 멀티 에이전트 시스템 설계 패턴\n \n-멀티 에이전트 시스템을 설계하는 방법은 다양하지만, 일반적으로 폭넓게 적용 가능한 두 가지 패턴이 있습니다:\n+멀티 에이전트 시스템을 설계하는 방법은 다양하지만, 일반적으로 널리 적용 가능한 두 가지 패턴을 자주 봅니다:\n \n-1. 매니저(에이전트를 도구로 사용): 중앙 매니저/오케스트레이터가 특화된 하위 에이전트를 도구처럼 호출하며 대화를 제어함\n-2. 핸드오프: 동등한 에이전트들 간에 제어권을 특화된 에이전트로 넘겨 해당 에이전트가 대화를 이어받음. 이는 분산형임\n+1. 매니저(에이전트를 도구로 사용): 중앙 매니저/오케스트레이터가 특화된 하위 에이전트를 도구로 호출하고 대화의 제어권을 유지\n+2. 핸드오프: 동등한 에이전트들이 제어권을 특화된 에이전트에게 넘기며, 그 에이전트가 대화를 인수함. 이는 탈중앙화됨\n \n-자세한 내용은 [에이전트 구축 실용 가이드](https://cdn.openai.com/business-guides-and-resources/a-practical-guide-to-building-agents.pdf)를 참고하세요.\n+자세한 내용은 [에이전트 구축 실용 가이드](https://cdn.openai.com/business-guides-and-resources/a-practical-guide-to-building-agents.pdf) 를 참고하세요.\n \n ### 매니저(에이전트를 도구로 사용)\n \n-`customer_facing_agent`는 모든 사용자 상호작용을 처리하고 도구로 노출된 특화 하위 에이전트를 호출합니다. 자세한 내용은 [tools](tools.md#agents-as-tools) 문서를 참고하세요.\n+`customer_facing_agent` 가 모든 사용자 상호작용을 처리하고 도구로 노출된 특화된 하위 에이전트를 호출합니다. 자세한 내용은 [도구](tools.md#agents-as-tools) 문서를 참조하세요.\n \n ```python\n from agents import Agent\n@@ -115,7 +115,7 @@ customer_facing_agent = Agent(\n \n ### 핸드오프\n \n-핸드오프는 에이전트가 위임할 수 있는 하위 에이전트입니다. 핸드오프가 발생하면, 위임받은 에이전트가 대화 내역을 전달받고 대화를 이어받습니다. 이 패턴은 단일 작업에 뛰어난 모듈형 특화 에이전트를 가능하게 합니다. 자세한 내용은 [handoffs](handoffs.md) 문서를 참고하세요.\n+핸드오프는 에이전트가 위임할 수 있는 하위 에이전트입니다. 핸드오프가 발생하면 위임받은 에이전트가 대화 기록을 전달받아 대화를 인수합니다. 이 패턴은 단일 작업에 최적화된 모듈형 특화 에이전트를 가능하게 합니다. 자세한 내용은 [핸드오프](handoffs.md) 문서를 참조하세요.\n \n ```python\n from agents import Agent\n@@ -136,7 +136,7 @@ triage_agent = Agent(\n \n ## 동적 instructions\n \n-대부분의 경우 에이전트를 생성할 때 instructions 를 제공할 수 있습니다. 하지만 함수로 동적 instructions 를 제공할 수도 있습니다. 이 함수는 에이전트와 컨텍스트를 입력으로 받아 프롬프트를 반환해야 합니다. 일반 함수와 `async` 함수 모두 허용됩니다.\n+대부분의 경우 에이전트를 생성할 때 instructions 를 제공할 수 있습니다. 그러나 함수로 동적 instructions 를 제공할 수도 있습니다. 이 함수는 에이전트와 컨텍스트를 받고, 프롬프트를 반환해야 합니다. 동기 및 `async` 함수 모두 허용됩니다.\n \n ```python\n def dynamic_instructions(\n@@ -151,17 +151,17 @@ agent = Agent[UserContext](\n )\n ```\n \n-## 라이프사이클 이벤트(후크)\n+## 수명 주기 이벤트(hooks)\n \n-때로는 에이전트의 라이프사이클을 관찰하고 싶을 수 있습니다. 예를 들어, 특정 이벤트가 발생할 때 이벤트를 로깅하거나 데이터를 미리 가져오고 싶을 수 있습니다. `hooks` 속성으로 에이전트 라이프사이클에 후킹할 수 있습니다. [`AgentHooks`][agents.lifecycle.AgentHooks] 클래스를 상속하고, 필요한 메서드를 오버라이드하세요.\n+때로는 에이전트의 수명 주기를 관찰하고 싶을 수 있습니다. 예를 들어 특정 이벤트가 발생할 때 이벤트를 로깅하거나 데이터를 사전 페치하고 싶을 수 있습니다. `hooks` 속성으로 에이전트 수명 주기에 훅을 걸 수 있습니다. [`AgentHooks`][agents.lifecycle.AgentHooks] 클래스를 상속하고, 필요한 메서드를 오버라이드하세요.\n \n ## 가드레일\n \n-가드레일은 에이전트가 실행되는 동안 사용자 입력에 대한 검사/검증을 병렬로 수행하고, 에이전트 출력이 생성된 후에도 검사를 수행할 수 있게 해줍니다. 예를 들어, 사용자 입력과 에이전트 출력을 관련성 기준으로 필터링할 수 있습니다. 자세한 내용은 [guardrails](guardrails.md) 문서를 참고하세요.\n+가드레일은 에이전트가 실행되는 동안 사용자 입력에 대한 검사/검증을 병렬로 수행하고, 에이전트 출력이 생성된 후에도 수행할 수 있게 해줍니다. 예를 들어, 사용자 입력과 에이전트 출력을 관련성 기준으로 선별할 수 있습니다. 자세한 내용은 [guardrails](guardrails.md) 문서를 참조하세요.\n \n ## 에이전트 복제/복사\n \n-에이전트의 `clone()` 메서드를 사용하면 에이전트를 복제하고, 선택적으로 원하는 속성을 변경할 수 있습니다.\n+에이전트에서 `clone()` 메서드를 사용하면 에이전트를 복제하고, 원하는 속성을 선택적으로 변경할 수 있습니다.\n \n ```python\n pirate_agent = Agent(\n@@ -178,12 +178,12 @@ robot_agent = pirate_agent.clone(\n \n ## 도구 사용 강제\n \n-도구 목록을 제공해도 LLM 이 항상 도구를 사용하는 것은 아닙니다. [`ModelSettings.tool_choice`][agents.model_settings.ModelSettings.tool_choice]를 설정하여 도구 사용을 강제할 수 있습니다. 유효한 값은 다음과 같습니다:\n+도구 목록을 제공한다고 해서 LLM 이 항상 도구를 사용하는 것은 아닙니다. [`ModelSettings.tool_choice`][agents.model_settings.ModelSettings.tool_choice] 를 설정하여 도구 사용을 강제할 수 있습니다. 유효한 값은 다음과 같습니다:\n \n-1. `auto`: LLM 이 도구 사용 여부를 결정함\n-2. `required`: LLM 이 반드시 도구를 사용해야 함(어떤 도구를 사용할지는 지능적으로 결정)\n-3. `none`: LLM 이 도구를 사용하지 _않도록_ 요구함\n-4. 특정 문자열 설정, 예: `my_tool` — 해당 특정 도구를 사용하도록 LLM 에 요구함\n+1. `auto`: LLM 이 도구 사용 여부를 스스로 결정\n+2. `required`: LLM 이 반드시 도구를 사용하도록 요구(단, 어떤 도구를 사용할지는 지능적으로 결정)\n+3. `none`: LLM 이 도구를 _사용하지 않도록_ 요구\n+4. 특정 문자열 설정(예: `my_tool`): LLM 이 해당 특정 도구를 사용하도록 요구\n \n ```python\n from agents import Agent, Runner, function_tool, ModelSettings\n@@ -203,9 +203,9 @@ agent = Agent(\n \n ## 도구 사용 동작\n \n-`Agent` 구성의 `tool_use_behavior` 매개변수는 도구 출력이 어떻게 처리되는지를 제어합니다:\n+`Agent` 구성의 `tool_use_behavior` 매개변수는 도구 출력이 처리되는 방식을 제어합니다:\n \n-- `\"run_llm_again\"`: 기본값. 도구를 실행한 뒤, LLM 이 결과를 처리하여 최종 응답을 생성\n+- `\"run_llm_again\"`: 기본값. 도구가 실행되고, LLM 이 결과를 처리하여 최종 응답을 생성\n - `\"stop_on_first_tool\"`: 첫 번째 도구 호출의 출력을 추가 LLM 처리 없이 최종 응답으로 사용\n \n ```python\n@@ -224,7 +224,7 @@ agent = Agent(\n )\n ```\n \n-- `StopAtTools(stop_at_tool_names=[...])`: 지정된 도구 중 하나가 호출되면 중지하고, 그 출력을 최종 응답으로 사용\n+- `StopAtTools(stop_at_tool_names=[...])`: 지정된 도구 중 하나가 호출되면 중지하고, 해당 도구의 출력을 최종 응답으로 사용\n \n ```python\n from agents import Agent, Runner, function_tool\n@@ -248,7 +248,7 @@ agent = Agent(\n )\n ```\n \n-- `ToolsToFinalOutputFunction`: 도구 결과를 처리하고 중지할지 LLM 을 계속 사용할지 결정하는 사용자 정의 함수\n+- `ToolsToFinalOutputFunction`: 도구 결과를 처리하고 중지할지 LLM 을 계속할지 결정하는 사용자 지정 함수\n \n ```python\n from agents import Agent, Runner, function_tool, FunctionToolResult, RunContextWrapper\n@@ -286,4 +286,4 @@ agent = Agent(\n \n !!! note\n \n-    무한 루프를 방지하기 위해, 프레임워크는 도구 호출 후 `tool_choice`를 자동으로 \"auto\"로 재설정합니다. 이 동작은 [`agent.reset_tool_choice`][agents.agent.Agent.reset_tool_choice]로 구성할 수 있습니다. 무한 루프는 도구 결과가 LLM 에게 다시 전달되고, `tool_choice` 때문에 LLM 이 또 다른 도구 호출을 생성하는 과정이 반복되기 때문에 발생합니다.\n\\ No newline at end of file\n+    무한 루프를 방지하기 위해, 프레임워크는 도구 호출 후 자동으로 `tool_choice` 를 \"auto\" 로 재설정합니다. 이 동작은 [`agent.reset_tool_choice`][agents.agent.Agent.reset_tool_choice] 를 통해 구성할 수 있습니다. 무한 루프의 원인은 도구 결과가 LLM 으로 전달되고, 그에 따라 `tool_choice` 때문에 LLM 이 또 다른 도구 호출을 생성하는 과정이 무한히 반복되기 때문입니다.\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Fagents.md",
        "sha": "71234ce719b647c28b24c6805246490a33df289e",
        "status": "modified"
      },
      {
        "additions": 21,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Fconfig.md",
        "changes": 30,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fko%2Fconfig.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 9,
        "filename": "docs/ko/config.md",
        "patch": "@@ -6,15 +6,15 @@ search:\n \n ## API 키와 클라이언트\n \n-기본적으로 SDK는 임포트되는 즉시 LLM 요청과 트레이싱을 위해 `OPENAI_API_KEY` 환경 변수를 찾습니다. 앱이 시작되기 전에 해당 환경 변수를 설정할 수 없다면, [set_default_openai_key()][agents.set_default_openai_key] 함수를 사용하여 키를 설정할 수 있습니다.\n+기본적으로 SDK는 가져오자마자 LLM 요청과 트레이싱을 위해 `OPENAI_API_KEY` 환경 변수를 찾습니다. 앱 시작 전에 해당 환경 변수를 설정할 수 없다면 [set_default_openai_key()][agents.set_default_openai_key] 함수를 사용해 키를 설정할 수 있습니다.\n \n ```python\n from agents import set_default_openai_key\n \n set_default_openai_key(\"sk-...\")\n ```\n \n-또는 사용할 OpenAI 클라이언트를 구성할 수도 있습니다. 기본적으로 SDK는 환경 변수의 API 키 또는 위에서 설정한 기본 키를 사용하여 `AsyncOpenAI` 인스턴스를 생성합니다. [set_default_openai_client()][agents.set_default_openai_client] 함수를 사용하여 이를 변경할 수 있습니다.\n+또는 사용할 OpenAI 클라이언트를 구성할 수도 있습니다. 기본적으로 SDK는 환경 변수 또는 위에서 설정한 기본 키로 `AsyncOpenAI` 인스턴스를 생성합니다. [set_default_openai_client()][agents.set_default_openai_client] 함수를 사용해 이를 변경할 수 있습니다.\n \n ```python\n from openai import AsyncOpenAI\n@@ -24,7 +24,7 @@ custom_client = AsyncOpenAI(base_url=\"...\", api_key=\"...\")\n set_default_openai_client(custom_client)\n ```\n \n-마지막으로, 사용되는 OpenAI API를 사용자 지정할 수도 있습니다. 기본적으로 OpenAI Responses API를 사용합니다. [set_default_openai_api()][agents.set_default_openai_api] 함수를 사용하여 Chat Completions API를 사용하도록 재정의할 수 있습니다.\n+마지막으로, 사용되는 OpenAI API 를 커스터마이즈할 수도 있습니다. 기본적으로 OpenAI Responses API 를 사용합니다. [set_default_openai_api()][agents.set_default_openai_api] 함수를 사용해 Chat Completions API 를 사용하도록 재정의할 수 있습니다.\n \n ```python\n from agents import set_default_openai_api\n@@ -34,15 +34,27 @@ set_default_openai_api(\"chat_completions\")\n \n ## 트레이싱\n \n-트레이싱은 기본적으로 활성화되어 있습니다. 기본적으로 위 섹션의 OpenAI API 키(즉, 환경 변수 또는 설정한 기본 키)를 사용합니다. [`set_tracing_export_api_key`][agents.set_tracing_export_api_key] 함수를 사용하여 트레이싱에 사용할 API 키를 별도로 설정할 수 있습니다.\n+트레이싱은 기본적으로 활성화되어 있습니다. 기본적으로 위 섹션의 OpenAI API 키(즉, 환경 변수 또는 설정한 기본 키)를 사용합니다. 트레이싱에 사용할 API 키를 명시적으로 설정하려면 [`set_tracing_export_api_key`][agents.set_tracing_export_api_key] 함수를 사용하세요.\n \n ```python\n from agents import set_tracing_export_api_key\n \n set_tracing_export_api_key(\"sk-...\")\n ```\n \n-[`set_tracing_disabled()`][agents.set_tracing_disabled] 함수를 사용하여 트레이싱을 완전히 비활성화할 수도 있습니다.\n+글로벌 익스포터를 변경하지 않고도 실행별로 트레이싱 API 키를 설정할 수 있습니다.\n+\n+```python\n+from agents import Runner, RunConfig\n+\n+await Runner.run(\n+    agent,\n+    input=\"Hello\",\n+    run_config=RunConfig(tracing={\"api_key\": \"sk-tracing-123\"}),\n+)\n+```\n+\n+[`set_tracing_disabled()`][agents.set_tracing_disabled] 함수를 사용해 트레이싱을 완전히 비활성화할 수도 있습니다.\n \n ```python\n from agents import set_tracing_disabled\n@@ -52,7 +64,7 @@ set_tracing_disabled(True)\n \n ## 디버그 로깅\n \n-SDK에는 핸들러가 설정되지 않은 두 개의 Python 로거가 있습니다. 기본적으로 이는 경고와 오류가 `stdout`으로 전송되지만, 다른 로그는 억제됨을 의미합니다.\n+SDK 에는 핸들러가 설정되지 않은 두 개의 Python 로거가 있습니다. 기본적으로 이는 경고와 오류가 `stdout` 로 전송되고, 다른 로그는 억제됨을 의미합니다.\n \n 자세한 로깅을 활성화하려면 [`enable_verbose_stdout_logging()`][agents.enable_verbose_stdout_logging] 함수를 사용하세요.\n \n@@ -62,7 +74,7 @@ from agents import enable_verbose_stdout_logging\n enable_verbose_stdout_logging()\n ```\n \n-또는 핸들러, 필터, 포매터 등을 추가하여 로그를 사용자 지정할 수 있습니다. 자세한 내용은 [Python logging guide](https://docs.python.org/3/howto/logging.html)를 참고하세요.\n+또는 핸들러, 필터, 포매터 등을 추가해 로그를 커스터마이즈할 수 있습니다. 자세한 내용은 [Python 로깅 가이드](https://docs.python.org/3/howto/logging.html)를 참고하세요.\n \n ```python\n import logging\n@@ -83,15 +95,15 @@ logger.addHandler(logging.StreamHandler())\n \n ### 로그의 민감한 데이터\n \n-특정 로그에는 민감한 데이터(예: 사용자 데이터)가 포함될 수 있습니다. 이러한 데이터가 로그에 남지 않도록 하려면 다음 환경 변수를 설정하세요.\n+일부 로그에는 민감한 데이터(예: 사용자 데이터)가 포함될 수 있습니다. 이 데이터가 로깅되지 않도록 하려면 다음 환경 변수를 설정하세요.\n \n LLM 입력과 출력을 로깅하지 않으려면:\n \n ```bash\n export OPENAI_AGENTS_DONT_LOG_MODEL_DATA=1\n ```\n \n-도구 입력과 출력을 로깅하지 않으려면:\n+tool 입력과 출력을 로깅하지 않으려면:\n \n ```bash\n export OPENAI_AGENTS_DONT_LOG_TOOL_DATA=1",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Fconfig.md",
        "sha": "c4ca7affe73eec7a9656f593839c3094f8343d4e",
        "status": "modified"
      },
      {
        "additions": 26,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Fcontext.md",
        "changes": 52,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fko%2Fcontext.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 26,
        "filename": "docs/ko/context.md",
        "patch": "@@ -4,30 +4,30 @@ search:\n ---\n # 컨텍스트 관리\n \n-컨텍스트는 의미가 과부하된 용어입니다. 신경 써야 할 컨텍스트에는 두 가지 주요 클래스가 있습니다:\n+컨텍스트는 다의어입니다. 고려해야 할 두 가지 주요 컨텍스트 범주가 있습니다:\n \n-1. 코드에서 로컬로 사용 가능한 컨텍스트: 이는 도구 함수가 실행될 때, `on_handoff` 같은 콜백 동안, 라이프사이클 훅 등에서 필요할 수 있는 데이터와 의존성입니다\n-2. LLM에서 사용 가능한 컨텍스트: 이는 LLM이 응답을 생성할 때 볼 수 있는 데이터입니다\n+1. 코드에서 로컬로 사용 가능한 컨텍스트: 도구 함수가 실행될 때, `on_handoff` 같은 콜백 동안, 라이프사이클 훅 등에서 필요할 수 있는 데이터와 의존성\n+2. LLM 에서 사용 가능한 컨텍스트: LLM 이 응답을 생성할 때 볼 수 있는 데이터\n \n ## 로컬 컨텍스트\n \n 이는 [`RunContextWrapper`][agents.run_context.RunContextWrapper] 클래스와 그 안의 [`context`][agents.run_context.RunContextWrapper.context] 속성으로 표현됩니다. 동작 방식은 다음과 같습니다:\n \n-1. 원하는 파이썬 객체를 만듭니다. 일반적인 패턴은 dataclass 또는 Pydantic 객체를 사용하는 것입니다\n-2. 그 객체를 다양한 실행 메서드에 전달합니다(예: `Runner.run(..., **context=whatever**)`)\n-3. 모든 도구 호출, 라이프사이클 훅 등에는 래퍼 객체 `RunContextWrapper[T]`가 전달됩니다. 여기서 `T`는 `wrapper.context`를 통해 접근할 수 있는 컨텍스트 객체 타입을 나타냅니다\n+1. 원하는 어떤 Python 객체든 생성합니다. 일반적으로 dataclass 또는 Pydantic 객체를 사용합니다.\n+2. 해당 객체를 다양한 실행 메서드에 전달합니다(예: `Runner.run(..., **context=whatever**)`).\n+3. 모든 도구 호출, 라이프사이클 훅 등에는 래퍼 객체 `RunContextWrapper[T]` 가 전달되며, 여기서 `T` 는 컨텍스트 객체 타입을 나타내고 `wrapper.context` 를 통해 접근할 수 있습니다.\n \n-**가장 중요한 점**: 특정 에이전트 실행에 대해 모든 에이전트, 도구 함수, 라이프사이클 등은 동일한 _타입_의 컨텍스트를 사용해야 합니다.\n+가장 **중요한** 점: 특정 에이전트 실행에 대한 모든 에이전트, 도구 함수, 라이프사이클 등은 동일한 _타입_ 의 컨텍스트를 사용해야 합니다.\n \n 컨텍스트는 다음과 같은 용도로 사용할 수 있습니다:\n \n--   실행을 위한 컨텍스트 데이터(예: 사용자 이름/uid 또는 사용자에 대한 기타 정보)\n+-   실행에 대한 컨텍스트 데이터(예: 사용자 이름/UID 같은 값 또는 사용자에 관한 기타 정보)\n -   의존성(예: 로거 객체, 데이터 페처 등)\n -   헬퍼 함수\n \n !!! danger \"참고\"\n \n-    컨텍스트 객체는 LLM에 **전송되지 않습니다**. 순수하게 로컬 객체이며, 읽고, 쓰고, 그 메서드를 호출할 수 있습니다.\n+    컨텍스트 객체는 LLM 에게 **전송되지 않습니다**. 읽고 쓰고 메서드를 호출할 수 있는 순수한 로컬 객체입니다.\n \n ```python\n import asyncio\n@@ -66,18 +66,18 @@ if __name__ == \"__main__\":\n     asyncio.run(main())\n ```\n \n-1. 이것이 컨텍스트 객체입니다. 여기서는 dataclass를 사용했지만, 어떤 타입이든 사용할 수 있습니다\n-2. 이것은 도구입니다. `RunContextWrapper[UserInfo]`를 받는 것을 볼 수 있습니다. 도구 구현은 컨텍스트에서 읽습니다\n-3. 에이전트를 제네릭 `UserInfo`로 표시하여, 타입 체커가 오류를 잡을 수 있게 합니다(예: 다른 컨텍스트 타입을 받는 도구를 전달하려고 할 때)\n-4. 컨텍스트는 `run` 함수에 전달됩니다\n-5. 에이전트는 도구를 올바르게 호출하고 나이를 가져옵니다\n+1. 이것이 컨텍스트 객체입니다. 여기서는 dataclass 를 사용했지만, 어떤 타입이든 사용할 수 있습니다.\n+2. 이것은 도구입니다. `RunContextWrapper[UserInfo]` 를 받는 것을 볼 수 있습니다. 도구 구현은 컨텍스트에서 읽습니다.\n+3. 타입 체커가 오류를 잡을 수 있도록(예: 다른 컨텍스트 타입을 받는 도구를 전달하려 할 경우) 에이전트를 제네릭 `UserInfo` 로 표시합니다.\n+4. 컨텍스트는 `run` 함수에 전달됩니다.\n+5. 에이전트는 도구를 올바르게 호출하고 나이를 가져옵니다.\n \n ---\n \n ### 고급: `ToolContext`\n \n-경우에 따라, 실행 중인 도구에 대한 추가 메타데이터 — 예를 들어 이름, 호출 ID, 원문 인수 문자열 — 에 접근하고 싶을 수 있습니다.  \n-이를 위해 `RunContextWrapper`를 확장한 [`ToolContext`][agents.tool_context.ToolContext] 클래스를 사용할 수 있습니다.\n+일부 경우에는 실행 중인 도구의 이름, 호출 ID, 원문 인자 문자열 같은 추가 메타데이터에 접근하고 싶을 수 있습니다.  \n+이를 위해 `RunContextWrapper` 를 확장한 [`ToolContext`][agents.tool_context.ToolContext] 클래스를 사용할 수 있습니다.\n \n ```python\n from typing import Annotated\n@@ -105,23 +105,23 @@ agent = Agent(\n )\n ```\n \n-`ToolContext`는 `RunContextWrapper`와 동일한 `.context` 속성을 제공하며,  \n-현재 도구 호출에 특화된 추가 필드를 제공합니다:\n+`ToolContext` 는 `RunContextWrapper` 와 동일한 `.context` 속성을 제공하며,  \n+현재 도구 호출에 특화된 추가 필드가 있습니다:\n \n - `tool_name` – 호출되는 도구의 이름  \n - `tool_call_id` – 이 도구 호출의 고유 식별자  \n-- `tool_arguments` – 도구에 전달된 원문 인수 문자열  \n+- `tool_arguments` – 도구에 전달된 원문 인자 문자열  \n \n-실행 중 도구 수준의 메타데이터가 필요할 때 `ToolContext`를 사용하세요.  \n-에이전트와 도구 간 일반적인 컨텍스트 공유에는 `RunContextWrapper`로 충분합니다.\n+실행 중 도구 수준의 메타데이터가 필요할 때 `ToolContext` 를 사용하세요.  \n+에이전트와 도구 간 일반적인 컨텍스트 공유에는 `RunContextWrapper` 로 충분합니다.\n \n ---\n \n ## 에이전트/LLM 컨텍스트\n \n-LLM이 호출되면, LLM이 볼 수 있는 데이터는 대화 이력뿐입니다. 즉, LLM에 새 데이터를 제공하려면 해당 이력에서 사용 가능하도록 해야 합니다. 이를 위한 몇 가지 방법이 있습니다:\n+LLM 이 호출될 때, LLM 이 볼 수 있는 **유일한** 데이터는 대화 기록뿐입니다. 따라서 LLM 이 새 데이터를 볼 수 있게 하려면, 그 기록에 포함되도록 제공해야 합니다. 방법은 다음과 같습니다:\n \n-1. 에이전트 `instructions`에 추가할 수 있습니다. 이는 \"시스템 프롬프트\" 또는 \"개발자 메시지\"로도 알려져 있습니다. 시스템 프롬프트는 정적 문자열일 수도 있고, 컨텍스트를 받아 문자열을 출력하는 동적 함수일 수도 있습니다. 이는 항상 유용한 정보(예: 사용자 이름 또는 현재 날짜)에 흔히 사용되는 전술입니다\n-2. `Runner.run` 함수를 호출할 때 `input`에 추가합니다. 이는 `instructions` 전술과 유사하지만, [지휘 체계](https://cdn.openai.com/spec/model-spec-2024-05-08.html#follow-the-chain-of-command)에서 더 낮은 메시지를 가질 수 있게 합니다\n-3. 함수 도구를 통해 노출합니다. 이는 _온디맨드_ 컨텍스트에 유용합니다 — LLM이 언제 데이터가 필요한지 결정하고, 해당 데이터를 가져오기 위해 도구를 호출할 수 있습니다\n-4. retrieval 또는 웹 검색을 사용합니다. 이는 파일이나 데이터베이스에서 관련 데이터를 가져오거나(retrieval), 웹에서 가져올 수 있는(웹 검색) 특수 도구입니다. 이는 관련 컨텍스트 데이터에 응답을 \"그라운딩\"하는 데 유용합니다\n\\ No newline at end of file\n+1. 에이전트 `instructions` 에 추가할 수 있습니다. 이는 \"시스템 프롬프트(system prompt)\" 또는 \"개발자 메시지\"로도 알려져 있습니다. 시스템 프롬프트는 정적 문자열일 수도 있고, 컨텍스트를 받아 문자열을 출력하는 동적 함수일 수도 있습니다. 사용자 이름이나 현재 날짜처럼 항상 유용한 정보에 일반적으로 사용하는 방법입니다.\n+2. `Runner.run` 함수를 호출할 때 `input` 에 추가합니다. 이는 `instructions` 방식과 유사하지만, [지휘 계통](https://cdn.openai.com/spec/model-spec-2024-05-08.html#follow-the-chain-of-command)에서 더 낮은 메시지를 사용할 수 있게 합니다.\n+3. 함수 도구를 통해 노출합니다. 이는 온디맨드 컨텍스트에 유용합니다. LLM 이 필요한 시점을 스스로 결정하고 도구를 호출해 데이터를 가져올 수 있습니다.\n+4. 검색(retrieval) 또는 웹 검색을 사용합니다. 이는 파일이나 데이터베이스에서 관련 데이터를 가져오거나(검색), 웹에서 가져올 수 있는(웹 검색) 특수 도구입니다. 관련 컨텍스트 데이터로 응답을 \"그라운딩\"하는 데 유용합니다.\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Fcontext.md",
        "sha": "6e701969b4c923d7b387c5a38517d8bb6cce2153",
        "status": "modified"
      },
      {
        "additions": 36,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Fexamples.md",
        "changes": 72,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fko%2Fexamples.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 36,
        "filename": "docs/ko/examples.md",
        "patch": "@@ -4,12 +4,12 @@ search:\n ---\n # 코드 예제\n \n-[repo](https://github.com/openai/openai-agents-python/tree/main/examples)의 examples 섹션에서 SDK의 다양한 샘플 구현을 확인하세요. code examples는 서로 다른 패턴과 기능을 보여주는 여러 카테고리로 구성되어 있습니다.\n+[리포지토리](https://github.com/openai/openai-agents-python/tree/main/examples)의 코드 예제 섹션에서 SDK의 다양한 샘플 구현을 확인하세요. 예제들은 다양한 패턴과 기능을 보여주는 여러 카테고리로 구성되어 있습니다.\n \n ## 카테고리\n \n--   **[agent_patterns](https://github.com/openai/openai-agents-python/tree/main/examples/agent_patterns):**\n-    이 카테고리의 예제는 다음과 같은 일반적인 에이전트 설계 패턴을 보여줍니다\n+-   **[에이전트 패턴](https://github.com/openai/openai-agents-python/tree/main/examples/agent_patterns):**\n+    이 카테고리의 예제들은 다음과 같은 일반적인 에이전트 설계 패턴을 보여줍니다\n \n     -   결정적 워크플로\n     -   도구로서의 에이전트\n@@ -20,42 +20,42 @@ search:\n     -   라우팅\n     -   스트리밍 가드레일\n \n--   **[basic](https://github.com/openai/openai-agents-python/tree/main/examples/basic):**\n-    이 code examples는 SDK의 기초 기능을 보여줍니다\n+-   **[기본](https://github.com/openai/openai-agents-python/tree/main/examples/basic):**\n+    이 예제들은 다음과 같은 SDK의 기초 기능을 보여줍니다\n \n-    -   Hello World 코드 예제(기본 모델, GPT-5, 오픈 가중치 모델)\n+    -   Hello World 코드 예제(기본 모델, GPT-5, 오픈 웨이트 모델)\n     -   에이전트 라이프사이클 관리\n     -   동적 시스템 프롬프트\n-    -   스트리밍 출력(텍스트, 아이템, 함수 호출 args)\n+    -   스트리밍 출력(텍스트, 아이템, 함수 호출 인자)\n     -   프롬프트 템플릿\n     -   파일 처리(로컬 및 원격, 이미지와 PDF)\n     -   사용량 추적\n     -   비엄격 출력 타입\n     -   이전 응답 ID 사용\n \n--   **[customer_service](https://github.com/openai/openai-agents-python/tree/main/examples/customer_service):**\n-    항공사 고객 서비스 시스템 예제\n+-   **[고객 지원](https://github.com/openai/openai-agents-python/tree/main/examples/customer_service):**\n+    항공사를 위한 예시 고객 지원 시스템\n \n--   **[financial_research_agent](https://github.com/openai/openai-agents-python/tree/main/examples/financial_research_agent):**\n-    금융 데이터 분석을 위한 에이전트와 도구로 구성된 구조화 리서치 워크플로를 보여주는 금융 리서치 에이전트\n+-   **[금융 리서치 에이전트](https://github.com/openai/openai-agents-python/tree/main/examples/financial_research_agent):**\n+    에이전트와 도구를 사용한 금융 데이터 분석을 위해 구조화된 리서치 워크플로를 시연하는 금융 리서치 에이전트\n \n--   **[handoffs](https://github.com/openai/openai-agents-python/tree/main/examples/handoffs):**\n-    메시지 필터링을 활용한 에이전트 핸드오프의 실용적인 예제\n+-   **[핸드오프](https://github.com/openai/openai-agents-python/tree/main/examples/handoffs):**\n+    메시지 필터링을 활용한 에이전트 핸드오프의 실용적인 예제를 확인하세요\n \n--   **[hosted_mcp](https://github.com/openai/openai-agents-python/tree/main/examples/hosted_mcp):**\n-    호스티드 MCP(Model Context Protocol) 커넥터와 승인을 사용하는 방법을 보여주는 예제\n+-   **[호스티드 MCP](https://github.com/openai/openai-agents-python/tree/main/examples/hosted_mcp):**\n+    호스티드 MCP (Model Context Protocol) 커넥터와 승인 사용 방법을 보여주는 예제\n \n--   **[mcp](https://github.com/openai/openai-agents-python/tree/main/examples/mcp):**\n-    다음을 포함하여 MCP(Model Context Protocol)로 에이전트를 만드는 방법을 학습하세요\n+-   **[MCP](https://github.com/openai/openai-agents-python/tree/main/examples/mcp):**\n+    MCP (Model Context Protocol)를 사용해 에이전트를 빌드하는 방법을 학습하세요. 다음을 포함합니다\n \n-    -   파일시스템 예제\n-    -   Git 예제\n+    -   파일시스템 코드 예제\n+    -   Git 코드 예제\n     -   MCP 프롬프트 서버 코드 예제\n-    -   SSE(Server-Sent Events) 코드 예제\n+    -   SSE (Server-Sent Events) 코드 예제\n     -   스트리밍 가능한 HTTP 코드 예제\n \n--   **[memory](https://github.com/openai/openai-agents-python/tree/main/examples/memory):**\n-    에이전트를 위한 다양한 메모리 구현 예제\n+-   **[메모리](https://github.com/openai/openai-agents-python/tree/main/examples/memory):**\n+    에이전트를 위한 다양한 메모리 구현 예제. 다음을 포함합니다\n \n     -   SQLite 세션 스토리지\n     -   고급 SQLite 세션 스토리지\n@@ -64,30 +64,30 @@ search:\n     -   암호화된 세션 스토리지\n     -   OpenAI 세션 스토리지\n \n--   **[model_providers](https://github.com/openai/openai-agents-python/tree/main/examples/model_providers):**\n-    커스텀 프로바이더와 LiteLLM 통합을 포함하여 SDK로 OpenAI 이외의 모델을 사용하는 방법을 탐색하세요\n+-   **[모델 프로바이더](https://github.com/openai/openai-agents-python/tree/main/examples/model_providers):**\n+    커스텀 프로바이더와 LiteLLM 연동을 포함해, OpenAI 가 아닌 모델을 SDK와 함께 사용하는 방법을 살펴보세요\n \n--   **[realtime](https://github.com/openai/openai-agents-python/tree/main/examples/realtime):**\n-    SDK를 사용해 실시간 경험을 구축하는 방법을 보여주는 예제\n+-   **[실시간](https://github.com/openai/openai-agents-python/tree/main/examples/realtime):**\n+    SDK를 사용해 실시간 경험을 구축하는 방법을 보여주는 예제. 다음을 포함합니다\n \n     -   웹 애플리케이션\n     -   커맨드라인 인터페이스\n-    -   Twilio 통합\n+    -   Twilio 연동\n \n--   **[reasoning_content](https://github.com/openai/openai-agents-python/tree/main/examples/reasoning_content):**\n-    추론 콘텐츠와 structured outputs를 다루는 방법을 보여주는 예제\n+-   **[추론 콘텐츠](https://github.com/openai/openai-agents-python/tree/main/examples/reasoning_content):**\n+    추론 콘텐츠와 structured outputs 를 다루는 방법을 보여주는 예제\n \n--   **[research_bot](https://github.com/openai/openai-agents-python/tree/main/examples/research_bot):**\n-    복잡한 멀티 에이전트 리서치 워크플로를 보여주는 간단한 딥 리서치 클론\n+-   **[리서치 봇](https://github.com/openai/openai-agents-python/tree/main/examples/research_bot):**\n+    복잡한 멀티 에이전트 리서치 워크플로를 시연하는 단순한 딥 리서치 클론\n \n--   **[tools](https://github.com/openai/openai-agents-python/tree/main/examples/tools):**\n+-   **[도구](https://github.com/openai/openai-agents-python/tree/main/examples/tools):**\n     다음과 같은 OpenAI 호스트하는 도구를 구현하는 방법을 학습하세요\n \n-    -   웹 검색 및 필터를 사용한 웹 검색\n+    -   웹 검색 및 필터가 있는 웹 검색\n     -   파일 검색\n-    -   Code Interpreter\n+    -   Code interpreter\n     -   컴퓨터 사용\n     -   이미지 생성\n \n--   **[voice](https://github.com/openai/openai-agents-python/tree/main/examples/voice):**\n-    TTS 및 STT 모델을 사용하는 음성 에이전트 예제와 스트리밍 음성 코드 예제를 확인하세요\n\\ No newline at end of file\n+-   **[음성](https://github.com/openai/openai-agents-python/tree/main/examples/voice):**\n+    TTS 및 STT 모델을 사용하는 음성 에이전트 예제를 확인하세요. 스트리밍 음성 코드 예제를 포함합니다\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Fexamples.md",
        "sha": "67f7bfa8a982e91ba0dbf0d913bbed588bf04a9c",
        "status": "modified"
      },
      {
        "additions": 24,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Fguardrails.md",
        "changes": 48,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fko%2Fguardrails.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 24,
        "filename": "docs/ko/guardrails.md",
        "patch": "@@ -4,54 +4,54 @@ search:\n ---\n # 가드레일\n \n-가드레일은 사용자 입력과 에이전트 출력에 대한 점검과 검증을 수행할 수 있게 합니다. 예를 들어, 고객 요청을 돕기 위해 매우 똑똑한(따라서 느리고/비싼) 모델을 사용하는 에이전트가 있다고 가정해 보겠습니다. 악의적인 사용자가 모델에게 수학 숙제를 도와 달라고 요청하는 것을 원하지 않을 것입니다. 이때 빠르고/저렴한 모델로 가드레일을 실행할 수 있습니다. 가드레일이 악의적 사용을 감지하면 즉시 오류를 발생시키고 비용이 많이 드는 모델 실행을 막아 시간과 비용을 절약할 수 있습니다(**차단형 가드레일 사용 시; 병렬 가드레일의 경우 가드레일이 완료되기 전에 이미 비용이 많이 드는 모델이 실행을 시작했을 수 있습니다. 자세한 내용은 아래의 \"실행 모드\"를 참조하세요**).\n+가드레일은 사용자 입력과 에이전트 출력에 대한 점검과 검증을 수행할 수 있게 해줍니다. 예를 들어, 고객 요청을 돕기 위해 매우 똑똑한(그래서 느리고/비싼) 모델을 사용하는 에이전트가 있다고 가정해 봅시다. 악의적인 사용자가 수학 숙제를 도와 달라고 모델에 요청하는 상황은 원치 않을 것입니다. 이때 빠르고/저렴한 모델로 가드레일을 실행할 수 있습니다. 가드레일이 악의적 사용을 감지하면 즉시 오류를 발생시켜 비싼 모델의 실행을 막아 시간과 비용을 절약할 수 있습니다 (**블로킹 가드레일을 사용할 때 해당합니다. 병렬 가드레일의 경우, 가드레일이 완료되기 전에 비싼 모델이 이미 실행을 시작했을 수 있습니다. 자세한 내용은 아래 \"실행 모드\"를 참조하세요**).\n \n 가드레일에는 두 가지 종류가 있습니다:\n \n-1. 입력 가드레일은 초기 사용자 입력에 대해 실행됨\n-2. 출력 가드레일은 최종 에이전트 출력에 대해 실행됨\n+1. 입력 가드레일은 최초 사용자 입력에서 실행됨\n+2. 출력 가드레일은 최종 에이전트 출력에서 실행됨\n \n ## 입력 가드레일\n \n 입력 가드레일은 3단계로 실행됩니다:\n \n-1. 먼저, 가드레일은 에이전트에 전달된 것과 동일한 입력을 받습니다\n-2. 다음으로, 가드레일 함수가 실행되어 [`GuardrailFunctionOutput`][agents.guardrail.GuardrailFunctionOutput]을 생성하고, 이를 [`InputGuardrailResult`][agents.guardrail.InputGuardrailResult]로 래핑합니다\n-3. 마지막으로 [`.tripwire_triggered`][agents.guardrail.GuardrailFunctionOutput.tripwire_triggered]가 true인지 확인합니다. true인 경우 [`InputGuardrailTripwireTriggered`][agents.exceptions.InputGuardrailTripwireTriggered] 예외가 발생하므로 사용자에게 적절히 응답하거나 예외를 처리할 수 있습니다\n+1. 먼저, 가드레일은 에이전트에 전달된 것과 동일한 입력을 받습니다.\n+2. 다음으로, 가드레일 함수가 실행되어 [`GuardrailFunctionOutput`][agents.guardrail.GuardrailFunctionOutput]을 생성하고, 이는 [`InputGuardrailResult`][agents.guardrail.InputGuardrailResult]로 래핑됩니다\n+3. 마지막으로 [`.tripwire_triggered`][agents.guardrail.GuardrailFunctionOutput.tripwire_triggered]가 true인지 확인합니다. true이면 [`InputGuardrailTripwireTriggered`][agents.exceptions.InputGuardrailTripwireTriggered] 예외가 발생하며, 이에 따라 사용자에게 적절히 응답하거나 예외를 처리할 수 있습니다.\n \n !!! Note\n \n-    입력 가드레일은 사용자 입력에서 실행되도록 설계되었으므로, 에이전트의 가드레일은 해당 에이전트가 *첫 번째* 에이전트인 경우에만 실행됩니다. 왜 `guardrails` 속성이 `Runner.run`에 전달되는 대신 에이전트에 있는지 궁금할 수 있습니다. 가드레일은 실제 에이전트와 밀접하게 연관되는 경향이 있기 때문입니다. 에이전트마다 서로 다른 가드레일을 실행하므로, 코드를 같은 위치에 두면 가독성에 유리합니다.\n+    입력 가드레일은 사용자 입력에서 실행되도록 설계되었으므로, 에이전트의 가드레일은 해당 에이전트가 *첫 번째* 에이전트일 때만 실행됩니다. 왜 `guardrails` 속성이 `Runner.run`에 전달되는 대신 에이전트에 있냐고 궁금할 수 있습니다. 이는 가드레일이 실제 에이전트와 밀접하게 연관되는 경향이 있기 때문입니다. 에이전트마다 다른 가드레일을 실행하므로, 코드를 같은 위치에 두면 가독성에 도움이 됩니다.\n \n ### 실행 모드\n \n 입력 가드레일은 두 가지 실행 모드를 지원합니다:\n \n-- **병렬 실행**(기본값, `run_in_parallel=True`): 가드레일이 에이전트 실행과 동시에 실행됩니다. 둘 다 동시에 시작하므로 대기 시간이 가장 좋습니다. 그러나 가드레일이 실패하면, 에이전트는 취소되기 전에 이미 토큰을 소비하고 도구를 실행했을 수 있습니다\n+- **병렬 실행**(기본값, `run_in_parallel=True`): 가드레일이 에이전트 실행과 동시에 실행됩니다. 둘이 동시에 시작되므로 지연 시간이 가장 짧습니다. 그러나 가드레일이 실패하면, 에이전트가 취소되기 전에 이미 토큰을 소비하고 도구를 실행했을 수 있습니다.\n \n-- **차단 실행**(`run_in_parallel=False`): 가드레일이 에이전트 시작 *이전* 에 실행 및 완료됩니다. 가드레일 트립와이어가 트리거되면 에이전트는 전혀 실행되지 않아 토큰 소비와 도구 실행을 방지합니다. 비용 최적화와 도구 호출로 인한 잠재적 부작용을 피하고자 할 때 적합합니다\n+- **블로킹 실행**(`run_in_parallel=False`): 가드레일이 에이전트가 시작되기 *전*에 실행을 완료합니다. 가드레일의 트립와이어가 트리거되면 에이전트는 절대 실행되지 않아 토큰 소비와 도구 실행을 방지합니다. 비용 최적화와 도구 호출로 인한 부작용을 피하고자 할 때 적합합니다.\n \n ## 출력 가드레일\n \n 출력 가드레일은 3단계로 실행됩니다:\n \n-1. 먼저, 가드레일은 에이전트가 생성한 출력을 받습니다\n-2. 다음으로, 가드레일 함수가 실행되어 [`GuardrailFunctionOutput`][agents.guardrail.GuardrailFunctionOutput]을 생성하고, 이를 [`OutputGuardrailResult`][agents.guardrail.OutputGuardrailResult]로 래핑합니다\n-3. 마지막으로 [`.tripwire_triggered`][agents.guardrail.GuardrailFunctionOutput.tripwire_triggered]가 true인지 확인합니다. true인 경우 [`OutputGuardrailTripwireTriggered`][agents.exceptions.OutputGuardrailTripwireTriggered] 예외가 발생하므로 사용자에게 적절히 응답하거나 예외를 처리할 수 있습니다\n+1. 먼저, 가드레일은 에이전트가 생성한 출력을 받습니다.\n+2. 다음으로, 가드레일 함수가 실행되어 [`GuardrailFunctionOutput`][agents.guardrail.GuardrailFunctionOutput]을 생성하고, 이는 [`OutputGuardrailResult`][agents.guardrail.OutputGuardrailResult]로 래핑됩니다\n+3. 마지막으로 [`.tripwire_triggered`][agents.guardrail.GuardrailFunctionOutput.tripwire_triggered]가 true인지 확인합니다. true이면 [`OutputGuardrailTripwireTriggered`][agents.exceptions.OutputGuardrailTripwireTriggered] 예외가 발생하며, 이에 따라 사용자에게 적절히 응답하거나 예외를 처리할 수 있습니다.\n \n !!! Note\n \n-    출력 가드레일은 최종 에이전트 출력에서 실행되도록 설계되었으므로, 에이전트의 가드레일은 해당 에이전트가 *마지막* 에이전트인 경우에만 실행됩니다. 입력 가드레일과 마찬가지로, 가드레일은 실제 에이전트와 밀접하게 연관되는 경향이 있어 에이전트마다 다른 가드레일을 실행하게 되므로 코드를 같은 위치에 두면 가독성에 유리합니다.\n+    출력 가드레일은 최종 에이전트 출력에서 실행되도록 설계되었으므로, 에이전트의 가드레일은 해당 에이전트가 *마지막* 에이전트일 때만 실행됩니다. 입력 가드레일과 마찬가지로, 가드레일은 실제 에이전트와 밀접하게 연관되므로 에이전트마다 다른 가드레일을 실행하게 되며, 코드를 같은 위치에 두는 것이 가독성에 유리합니다.\n \n-    출력 가드레일은 항상 에이전트가 완료된 후에 실행되므로 `run_in_parallel` 매개변수를 지원하지 않습니다.\n+    출력 가드레일은 항상 에이전트 완료 후 실행되므로 `run_in_parallel` 매개변수를 지원하지 않습니다.\n \n ## 트립와이어\n \n-입력이나 출력이 가드레일을 통과하지 못하면, 가드레일은 트립와이어로 이를 신호할 수 있습니다. 트립와이어가 트리거된 가드레일을 발견하는 즉시 `{Input,Output}GuardrailTripwireTriggered` 예외를 발생시키고 에이전트 실행을 중단합니다.\n+입력 또는 출력이 가드레일을 통과하지 못하면, 가드레일은 트립와이어로 이를 신호할 수 있습니다. 트립와이어가 트리거된 가드레일을 확인하는 즉시 `{Input,Output}GuardrailTripwireTriggered` 예외를 발생시키고 에이전트 실행을 중단합니다.\n \n ## 가드레일 구현\n \n-입력을 받아 [`GuardrailFunctionOutput`][agents.guardrail.GuardrailFunctionOutput]을 반환하는 함수를 제공해야 합니다. 이 예제에서는 내부에서 에이전트를 실행하여 이를 수행하겠습니다.\n+입력을 받아 [`GuardrailFunctionOutput`][agents.guardrail.GuardrailFunctionOutput]을 반환하는 함수를 제공해야 합니다. 이 예제에서는 내부적으로 에이전트를 실행하여 이를 수행합니다.\n \n ```python\n from pydantic import BaseModel\n@@ -104,10 +104,10 @@ async def main():\n         print(\"Math homework guardrail tripped\")\n ```\n \n-1. 이 에이전트를 가드레일 함수에서 사용합니다\n-2. 이것은 에이전트의 입력/컨텍스트를 받아 결과를 반환하는 가드레일 함수입니다\n-3. 가드레일 결과에 추가 정보를 포함할 수 있습니다\n-4. 이것은 워크플로를 정의하는 실제 에이전트입니다\n+1. 이 에이전트를 가드레일 함수에서 사용합니다.\n+2. 이것이 에이전트의 입력/컨텍스트를 받아 결과를 반환하는 가드레일 함수입니다.\n+3. 가드레일 결과에 추가 정보를 포함할 수 있습니다.\n+4. 이것이 워크플로를 정의하는 실제 에이전트입니다.\n \n 출력 가드레일도 유사합니다.\n \n@@ -162,7 +162,7 @@ async def main():\n         print(\"Math output guardrail tripped\")\n ```\n \n-1. 이것은 실제 에이전트의 출력 타입입니다\n-2. 이것은 가드레일의 출력 타입입니다\n-3. 이것은 에이전트의 출력을 받아 결과를 반환하는 가드레일 함수입니다\n-4. 이것은 워크플로를 정의하는 실제 에이전트입니다\n\\ No newline at end of file\n+1. 이것이 실제 에이전트의 출력 타입입니다.\n+2. 이것이 가드레일의 출력 타입입니다.\n+3. 이것이 에이전트의 출력을 받아 결과를 반환하는 가드레일 함수입니다.\n+4. 이것이 워크플로를 정의하는 실제 에이전트입니다.\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Fguardrails.md",
        "sha": "6e788417f1a5d9531d9c93cd38400e6bf5033701",
        "status": "modified"
      },
      {
        "additions": 18,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Fhandoffs.md",
        "changes": 36,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fko%2Fhandoffs.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 18,
        "filename": "docs/ko/handoffs.md",
        "patch": "@@ -4,15 +4,15 @@ search:\n ---\n # 핸드오프\n \n-핸드오프는 한 에이전트가 작업을 다른 에이전트에 위임할 수 있게 합니다. 각 에이전트가 서로 다른 영역에 특화되어 있는 시나리오에서 특히 유용합니다. 예를 들어, 고객 지원 앱에서는 주문 상태, 환불, FAQ 등과 같은 작업을 각각 처리하는 에이전트가 있을 수 있습니다.\n+핸드오프를 사용하면 한 에이전트가 작업을 다른 에이전트에 위임할 수 있습니다. 이는 각기 다른 영역에 특화된 에이전트들이 있는 시나리오에서 특히 유용합니다. 예를 들어, 고객 지원 앱에서는 주문 상태, 환불, FAQ 등과 같은 작업을 각각 담당하는 에이전트가 있을 수 있습니다.\n \n-핸드오프는 LLM 에게 도구로 표현됩니다. 예를 들어 `Refund Agent`라는 에이전트로의 핸드오프가 있다면, 도구 이름은 `transfer_to_refund_agent`가 됩니다.\n+핸드오프는 LLM 에게 도구로 표현됩니다. 예를 들어 `Refund Agent` 라는 에이전트로의 핸드오프가 있다면, 도구 이름은 `transfer_to_refund_agent` 가 됩니다.\n \n ## 핸드오프 생성\n \n-모든 에이전트에는 [`handoffs`][agents.agent.Agent.handoffs] 매개변수가 있으며, 여기에 직접 `Agent`를 전달하거나, 핸드오프를 커스터마이즈하는 `Handoff` 객체를 전달할 수 있습니다.\n+모든 에이전트에는 [`handoffs`][agents.agent.Agent.handoffs] 매개변수가 있으며, 여기에 `Agent` 자체를 전달하거나 핸드오프를 커스터마이즈하는 `Handoff` 객체를 전달할 수 있습니다.\n \n-Agents SDK 에서 제공하는 [`handoff()`][agents.handoffs.handoff] 함수를 사용해 핸드오프를 생성할 수 있습니다. 이 함수는 핸드오프 대상 에이전트와 선택적인 override 및 입력 필터를 지정할 수 있습니다.\n+Agents SDK 에서 제공하는 [`handoff()`][agents.handoffs.handoff] 함수를 사용해 핸드오프를 생성할 수 있습니다. 이 함수는 핸드오프 대상 에이전트를 지정하고, 선택적으로 override 및 입력 필터를 설정할 수 있습니다.\n \n ### 기본 사용\n \n@@ -28,19 +28,19 @@ refund_agent = Agent(name=\"Refund agent\")\n triage_agent = Agent(name=\"Triage agent\", handoffs=[billing_agent, handoff(refund_agent)])\n ```\n \n-1. 에이전트를 직접 사용할 수도 있고(`billing_agent`처럼), `handoff()` 함수를 사용할 수도 있습니다\n+1. 에이전트를 직접 사용할 수 있습니다(예: `billing_agent`), 또는 `handoff()` 함수를 사용할 수 있습니다\n \n-### `handoff()` 함수를 통한 핸드오프 커스터마이징\n+### `handoff()` 함수로 핸드오프 커스터마이징\n \n [`handoff()`][agents.handoffs.handoff] 함수로 다양한 커스터마이징이 가능합니다.\n \n - `agent`: 작업을 넘길 대상 에이전트\n-- `tool_name_override`: 기본적으로 `Handoff.default_tool_name()` 함수가 사용되며, 이는 `transfer_to_<agent_name>`으로 결정됩니다. 이를 오버라이드할 수 있습니다\n-- `tool_description_override`: `Handoff.default_tool_description()`에서 제공하는 기본 도구 설명을 오버라이드합니다\n-- `on_handoff`: 핸드오프가 호출될 때 실행되는 콜백 함수입니다. 핸드오프가 호출됨을 알자마자 일부 데이터 패칭을 시작하는 등의 용도로 유용합니다. 이 함수는 에이전트 컨텍스트를 받으며, 선택적으로 LLM 이 생성한 입력도 받을 수 있습니다. 입력 데이터는 `input_type` 매개변수로 제어합니다\n-- `input_type`: 핸드오프가 기대하는 입력의 타입(선택 사항)\n-- `input_filter`: 다음 에이전트가 받는 입력을 필터링할 수 있습니다. 자세한 내용은 아래를 참고하세요\n-- `is_enabled`: 핸드오프 활성화 여부입니다. 불리언 또는 불리언을 반환하는 함수가 될 수 있어 런타임에 동적으로 핸드오프를 활성화/비활성화할 수 있습니다\n+- `tool_name_override`: 기본적으로 `Handoff.default_tool_name()` 함수가 사용되며, 이는 `transfer_to_<agent_name>` 으로 설정됩니다. 이를 오버라이드할 수 있습니다\n+- `tool_description_override`: `Handoff.default_tool_description()` 의 기본 도구 설명을 오버라이드\n+- `on_handoff`: 핸드오프가 호출될 때 실행되는 콜백 함수. 핸드오프가 발생하는 즉시 데이터 페치 등을 시작하는 데 유용합니다. 이 함수는 에이전트 컨텍스트를 받으며, 선택적으로 LLM 이 생성한 입력도 받을 수 있습니다. 입력 데이터는 `input_type` 매개변수로 제어됩니다\n+- `input_type`: 핸드오프에서 기대하는 입력 타입(선택 사항)\n+- `input_filter`: 다음 에이전트가 받는 입력을 필터링할 수 있습니다. 아래 내용을 참고하세요\n+- `is_enabled`: 핸드오프 활성화 여부. 불리언 또는 불리언을 반환하는 함수가 될 수 있어 런타임에 동적으로 활성/비활성화할 수 있습니다\n \n ```python\n from agents import Agent, handoff, RunContextWrapper\n@@ -60,7 +60,7 @@ handoff_obj = handoff(\n \n ## 핸드오프 입력\n \n-특정 상황에서는 핸드오프를 호출할 때 LLM 이 일부 데이터를 제공하길 원할 수 있습니다. 예를 들어 \"에스컬레이션 에이전트\"로의 핸드오프를 상상해 보세요. 로깅을 위해 사유(reason)를 제공받고 싶을 수 있습니다.\n+특정 상황에서는 LLM 이 핸드오프를 호출할 때 일부 데이터를 제공하길 원할 수 있습니다. 예를 들어, \"에스컬레이션 에이전트\"로의 핸드오프를 생각해 보면, 로깅을 위해 사유를 함께 제공하도록 할 수 있습니다.\n \n ```python\n from pydantic import BaseModel\n@@ -84,11 +84,11 @@ handoff_obj = handoff(\n \n ## 입력 필터\n \n-핸드오프가 발생하면, 마치 새 에이전트가 대화를 인계받아 이전의 전체 대화 기록을 모두 볼 수 있는 것과 같습니다. 이를 변경하려면 [`input_filter`][agents.handoffs.Handoff.input_filter]를 설정할 수 있습니다. 입력 필터는 [`HandoffInputData`][agents.handoffs.HandoffInputData]를 통해 기존 입력을 받아 새로운 `HandoffInputData`를 반환해야 하는 함수입니다.\n+핸드오프가 발생하면, 마치 새로운 에이전트가 대화를 인계받아 이전의 전체 대화 기록을 볼 수 있는 것과 같습니다. 이를 변경하려면 [`input_filter`][agents.handoffs.Handoff.input_filter] 를 설정할 수 있습니다. 입력 필터는 [`HandoffInputData`][agents.handoffs.HandoffInputData] 를 통해 기존 입력을 받고, 새로운 `HandoffInputData` 를 반환해야 하는 함수입니다.\n \n-기본적으로 러너는 이전 대화록을 하나의 assistant 요약 메시지로 축약합니다([`RunConfig.nest_handoff_history`][agents.run.RunConfig.nest_handoff_history] 참조). 이 요약은 동일한 실행 중 여러 번의 핸드오프가 발생할 때 새 턴을 계속 추가하는 `<CONVERSATION HISTORY>` 블록 안에 표시됩니다. 전체 `input_filter`를 작성하지 않고도 생성된 메시지를 대체하려면 [`RunConfig.handoff_history_mapper`][agents.run.RunConfig.handoff_history_mapper]를 통해 매핑 함수를 제공할 수 있습니다. 이 기본 동작은 핸드오프와 실행(run) 모두에서 명시적인 `input_filter`를 제공하지 않은 경우에만 적용되므로, 이미 페이로드를 커스터마이즈하는 기존 코드는 변경 없이 현재 동작을 유지합니다(이 저장소의 code examples 포함). 단일 핸드오프에 대해 중첩 동작을 오버라이드하려면 [`handoff(...)`][agents.handoffs.handoff]에 `nest_handoff_history=True` 또는 `False`를 전달해 [`Handoff.nest_handoff_history`][agents.handoffs.Handoff.nest_handoff_history]를 설정하세요. 생성된 요약의 래퍼 텍스트만 변경하면 되는 경우, 에이전트를 실행하기 전에 [`set_conversation_history_wrappers`][agents.handoffs.set_conversation_history_wrappers](필요 시 [`reset_conversation_history_wrappers`][agents.handoffs.reset_conversation_history_wrappers]도) 를 호출하세요.\n+기본적으로 이제 러너는 이전 대화록을 하나의 assistant 요약 메시지로 축약합니다([`RunConfig.nest_handoff_history`][agents.run.RunConfig.nest_handoff_history] 참조). 요약은 동일한 실행 중 여러 번 핸드오프가 발생할 때 새 턴을 계속 추가하는 `<CONVERSATION HISTORY>` 블록 내부에 표시됩니다. 전체 `input_filter` 를 작성하지 않고도 생성된 메시지를 교체하려면 [`RunConfig.handoff_history_mapper`][agents.run.RunConfig.handoff_history_mapper] 를 통해 매핑 함수를 제공할 수 있습니다. 해당 기본값은 핸드오프와 실행 모두에서 명시적인 `input_filter` 를 제공하지 않는 경우에만 적용되므로, 이미 페이로드를 커스터마이즈하는 기존 코드는(이 리포지토리의 code examples 포함) 변경 없이 현재 동작을 유지합니다. 단일 핸드오프에 대해 중첩 동작을 재정의하려면 [`handoff(...)`][agents.handoffs.handoff] 에 `nest_handoff_history=True` 또는 `False` 를 전달하여 [`Handoff.nest_handoff_history`][agents.handoffs.Handoff.nest_handoff_history] 를 설정하면 됩니다. 생성된 요약의 래퍼 텍스트만 변경하면 되는 경우, 에이전트를 실행하기 전에 [`set_conversation_history_wrappers`][agents.handoffs.set_conversation_history_wrappers] (그리고 선택적으로 [`reset_conversation_history_wrappers`][agents.handoffs.reset_conversation_history_wrappers])를 호출하세요.\n \n-일반적인 패턴(예: 기록에서 모든 도구 호출 제거)은 [`agents.extensions.handoff_filters`][] 에 이미 구현되어 있습니다\n+일반적인 패턴(예: 히스토리에서 모든 도구 호출 제거 등)은 [`agents.extensions.handoff_filters`][] 에 구현되어 있습니다\n \n ```python\n from agents import Agent, handoff\n@@ -102,11 +102,11 @@ handoff_obj = handoff(\n )\n ```\n \n-1. `FAQ agent`가 호출될 때 기록에서 모든 도구가 자동으로 제거됩니다\n+1. 이는 `FAQ agent` 가 호출될 때 히스토리에서 모든 도구를 자동으로 제거합니다\n \n ## 권장 프롬프트\n \n-LLM 이 핸드오프를 올바르게 이해하도록 하려면, 에이전트에 핸드오프 관련 정보를 포함하는 것을 권장합니다. [`agents.extensions.handoff_prompt.RECOMMENDED_PROMPT_PREFIX`][]에 권장 프리픽스가 있으며, 또는 [`agents.extensions.handoff_prompt.prompt_with_handoff_instructions`][]를 호출해 프롬프트에 권장 데이터를 자동으로 추가할 수 있습니다.\n+LLM 이 핸드오프를 올바르게 이해하도록 하려면, 에이전트에 핸드오프에 대한 정보를 포함하는 것을 권장합니다. [`agents.extensions.handoff_prompt.RECOMMENDED_PROMPT_PREFIX`][] 에 권장 접두사가 있으며, 또는 [`agents.extensions.handoff_prompt.prompt_with_handoff_instructions`][] 를 호출하여 권장 데이터를 프롬프트에 자동으로 추가할 수 있습니다.\n \n ```python\n from agents import Agent",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Fhandoffs.md",
        "sha": "956d2ba037fb826e2f7be86b2a6aecdc3eb44164",
        "status": "modified"
      },
      {
        "additions": 19,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Findex.md",
        "changes": 38,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fko%2Findex.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 19,
        "filename": "docs/ko/index.md",
        "patch": "@@ -4,39 +4,39 @@ search:\n ---\n # OpenAI Agents SDK\n \n-[OpenAI Agents SDK](https://github.com/openai/openai-agents-python)는 추상화를 최소화한 가볍고 사용하기 쉬운 패키지로 에이전트형 AI 앱을 구축할 수 있게 해줍니다. 이는 이전 에이전트 실험 프로젝트인 [Swarm](https://github.com/openai/swarm/tree/main)의 프로덕션급 업그레이드입니다. Agents SDK는 매우 작은 범위의 기본 구성요소를 제공합니다:\n+[OpenAI Agents SDK](https://github.com/openai/openai-agents-python)는 추상화가 매우 적은 가볍고 사용하기 쉬운 패키지로 에이전트형 AI 앱을 구축할 수 있도록 해줍니다. 이는 이전 에이전트 실험 프로젝트인 [Swarm](https://github.com/openai/swarm/tree/main)의 프로덕션 준비가 된 업그레이드입니다. Agents SDK에는 매우 소수의 기본 구성 요소가 있습니다:\n \n--   **에이전트**: 지시문(instructions)과 도구(tools)를 갖춘 LLM\n--   **핸드오프**: 특정 작업을 다른 에이전트에 위임할 수 있도록 함\n--   **가드레일**: 에이전트의 입력과 출력에 대한 검증을 가능하게 함\n--   **세션**: 에이전트 실행 간 대화 이력을 자동으로 유지 관리함\n+- **에이전트**: instructions와 tools를 갖춘 LLM\n+- **핸드오프**: 특정 작업에 대해 다른 에이전트에 위임할 수 있도록 함\n+- **가드레일**: 에이전트 입력과 출력의 검증을 가능하게 함\n+- **세션**: 에이전트 실행 간 대화 기록을 자동으로 유지 관리함\n \n-Python과 결합하면, 이 기본 구성요소만으로도 도구와 에이전트 간의 복잡한 관계를 충분히 표현할 수 있으며, 가파른 학습 곡선 없이 실제 애플리케이션을 구축할 수 있습니다. 또한 SDK에는 에이전트 플로우를 시각화하고 디버깅할 수 있게 해주는 내장 **트레이싱**이 포함되어 있으며, 이를 평가하고 애플리케이션에 맞게 모델을 파인튜닝하는 데에도 활용할 수 있습니다.\n+Python과 결합하면, 이 기본 구성 요소만으로도 도구와 에이전트 간의 복잡한 관계를 표현할 수 있으며 급격한 학습 곡선 없이 실제 애플리케이션을 구축할 수 있습니다. 또한 SDK에는 에이전트 플로우를 시각화하고 디버그하며, 평가하고 심지어 애플리케이션에 맞게 모델을 파인튜닝할 수 있게 해주는 **트레이싱**이 기본으로 포함되어 있습니다.\n \n-## Agents SDK를 사용하는 이유\n+## Agents SDK 사용 이유\n \n-SDK의 설계 원칙은 다음 두 가지입니다:\n+SDK는 두 가지 설계 원칙을 따릅니다:\n \n-1. 사용할 가치가 있을 만큼 충분한 기능을 제공하되, 빠르게 배울 수 있도록 기본 구성요소는 최소화합니다\n-2. 기본 설정만으로도 훌륭하게 작동하지만, 원하는 동작을 정확히 커스터마이즈할 수 있습니다\n+1. 사용할 가치가 있을 만큼 충분한 기능을 제공하되, 빠르게 배울 수 있도록 기본 구성 요소는 최소화합니다\n+2. 즉시 잘 동작하도록 제공하되, 원하는 동작을 정확히 커스터마이즈할 수 있습니다\n \n SDK의 주요 기능은 다음과 같습니다:\n \n--   에이전트 루프: 도구 호출, 결과를 LLM에 전달, LLM이 완료될 때까지 루프를 처리하는 내장 에이전트 루프\n--   파이썬 우선: 새로운 추상화를 배우지 않고도 언어의 기본 기능으로 에이전트를 오케스트레이션하고 체이닝\n--   핸드오프: 여러 에이전트 간 조정과 위임을 위한 강력한 기능\n--   가드레일: 에이전트와 병렬로 입력 검증과 점검을 실행하고, 실패 시 빠르게 중단\n--   세션: 에이전트 실행 간 대화 이력을 자동으로 관리하여 수동 상태 관리를 제거\n--   함수 도구: 어떤 Python 함수든 자동 스키마 생성과 Pydantic 기반 검증으로 도구로 변환\n--   트레이싱: 워크플로를 시각화, 디버그, 모니터링할 수 있는 내장 트레이싱과 OpenAI 평가, 파인튜닝, 증류 도구 연동\n+- 에이전트 루프: 도구 호출, 결과를 LLM으로 전달, LLM이 완료될 때까지 루프를 처리하는 내장 에이전트 루프\n+- 파이썬 우선: 새로운 추상화를 배우지 않고도, 내장 언어 기능으로 에이전트를 오케스트레이션하고 체이닝\n+- 핸드오프: 여러 에이전트 간 조정과 위임을 위한 강력한 기능\n+- 가드레일: 에이전트와 병렬로 입력 검증 및 체크를 실행하고 실패 시 조기 종료\n+- 세션: 에이전트 실행 간 대화 기록을 자동으로 관리하여 수동 상태 관리를 제거\n+- 함수 도구: 어떤 Python 함수든 자동 스키마 생성과 Pydantic 기반 검증으로 도구로 전환\n+- 트레이싱: 워크플로를 시각화, 디버그, 모니터링하고 OpenAI 제품군의 평가, 파인튜닝, 증류 도구를 활용할 수 있는 기본 트레이싱\n \n ## 설치\n \n ```bash\n pip install openai-agents\n ```\n \n-## Hello world 예제\n+## Hello World 예제\n \n ```python\n from agents import Agent, Runner\n@@ -51,7 +51,7 @@ print(result.final_output)\n # Infinite loop's dance.\n ```\n \n-(_이 코드를 실행할 때는 `OPENAI_API_KEY` 환경 변수를 설정해야 합니다_)\n+(_실행하는 경우, `OPENAI_API_KEY` 환경 변수를 설정했는지 확인하세요_)\n \n ```bash\n export OPENAI_API_KEY=sk-...",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Findex.md",
        "sha": "ec8a1800ac5fd9733d1a199f38433082a54f1cc9",
        "status": "modified"
      },
      {
        "additions": 56,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Fmcp.md",
        "changes": 100,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fko%2Fmcp.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 44,
        "filename": "docs/ko/mcp.md",
        "patch": "@@ -4,32 +4,36 @@ search:\n ---\n # Model context protocol (MCP)\n \n-[Model context protocol](https://modelcontextprotocol.io/introduction) (MCP)는 애플리케이션이 도구와 컨텍스트를 언어 모델에 노출하는 방식을 표준화합니다. 공식 문서에서 인용:\n+[Model context protocol](https://modelcontextprotocol.io/introduction) (MCP)은 애플리케이션이 도구와 컨텍스트를 언어 모델에 노출하는 방법을 표준화합니다. 공식 문서에서 인용:\n \n-> MCP는 애플리케이션이 LLM에 컨텍스트를 제공하는 방식을 표준화하는 오픈 프로토콜입니다. MCP를 AI 애플리케이션을 위한 USB-C 포트라고 생각해 보세요. USB-C가 다양한 주변기기와 액세서리에 기기를 연결하는 표준화된 방식을 제공하듯, MCP는 AI 모델을 다양한 데이터 소스와 도구에 연결하는 표준화된 방식을 제공합니다.\n+> MCP is an open protocol that standardizes how applications provide context to LLMs. Think of MCP like a USB-C port for AI\n+> applications. Just as USB-C provides a standardized way to connect your devices to various peripherals and accessories, MCP\n+> provides a standardized way to connect AI models to different data sources and tools.\n \n-Agents Python SDK는 여러 MCP 전송 방식을 지원합니다. 이를 통해 기존 MCP 서버를 재사용하거나 직접 구축하여 파일 시스템, HTTP, 커넥터 기반 도구를 에이전트에 노출할 수 있습니다.\n+Agents Python SDK는 여러 MCP 전송 방식을 이해합니다. 이를 통해 기존 MCP 서버를 재사용하거나 직접 구축하여 파일 시스템, HTTP, 커넥터 기반 도구를 에이전트에 노출할 수 있습니다.\n \n-## MCP 통합 선택\n+## Choosing an MCP integration\n \n-MCP 서버를 에이전트에 연결하기 전에 도구 호출을 어디에서 실행할지와 어떤 전송 방식을 사용할 수 있는지 결정하세요. 아래 매트릭스는 Python SDK가 지원하는 옵션을 요약합니다.\n+에이전트에 MCP 서버를 연결하기 전에 도구 호출이 어디서 실행되어야 하는지와 도달 가능한 전송 방식을 결정하세요. 아래 매트릭스는 Python SDK가 지원하는 옵션을 요약합니다.\n \n | What you need                                                                        | Recommended option                                    |\n | ------------------------------------------------------------------------------------ | ----------------------------------------------------- |\n-| Let OpenAI's Responses API call a publicly reachable MCP server on the model's behalf| **Hosted MCP server tools** via [`HostedMCPTool`][agents.tool.HostedMCPTool] |\n-| Connect to Streamable HTTP servers that you run locally or remotely                  | **Streamable HTTP MCP servers** via [`MCPServerStreamableHttp`][agents.mcp.server.MCPServerStreamableHttp] |\n-| Talk to servers that implement HTTP with Server-Sent Events                          | **HTTP with SSE MCP servers** via [`MCPServerSse`][agents.mcp.server.MCPServerSse] |\n-| Launch a local process and communicate over stdin/stdout                             | **stdio MCP servers** via [`MCPServerStdio`][agents.mcp.server.MCPServerStdio] |\n+| Let OpenAI's Responses API call a publicly reachable MCP server on the model's behalf| **호스티드 MCP 서버 도구** via [`HostedMCPTool`][agents.tool.HostedMCPTool] |\n+| Connect to Streamable HTTP servers that you run locally or remotely                  | **스트리머블 HTTP MCP 서버** via [`MCPServerStreamableHttp`][agents.mcp.server.MCPServerStreamableHttp] |\n+| Talk to servers that implement HTTP with Server-Sent Events                          | **HTTP with SSE MCP 서버** via [`MCPServerSse`][agents.mcp.server.MCPServerSse] |\n+| Launch a local process and communicate over stdin/stdout                             | **stdio MCP 서버** via [`MCPServerStdio`][agents.mcp.server.MCPServerStdio] |\n \n-아래 섹션에서는 각 옵션, 구성 방법, 그리고 어떤 전송 방식을 선호해야 하는지 살펴봅니다.\n+아래 섹션에서는 각 옵션, 구성 방법, 그리고 어떤 상황에서 어떤 전송 방식을 선호해야 하는지 설명합니다.\n \n ## 1. Hosted MCP server tools\n \n-호스티드 툴은 도구 왕복 전 과정을 OpenAI 인프라에서 처리합니다. 코드가 도구를 나열하고 호출하는 대신, [`HostedMCPTool`][agents.tool.HostedMCPTool]이 Responses API에 서버 라벨(및 선택적 커넥터 메타데이터)을 전달합니다. 모델은 원격 서버의 도구를 나열하고, 사용자의 Python 프로세스 콜백 없이 이를 호출합니다. 호스티드 툴은 현재 Responses API의 hosted MCP 통합을 지원하는 OpenAI 모델에서 동작합니다.\n+호스티드 툴은 전체 도구 라운드트립을 OpenAI 인프라에서 처리합니다. 코드가 도구를 나열하고 호출하는 대신,\n+[`HostedMCPTool`][agents.tool.HostedMCPTool]이 서버 레이블(및 선택적 커넥터 메타데이터)을 Responses API로 전달합니다. 모델은 원격 서버의 도구를 나열하고 Python 프로세스에 대한 추가 콜백 없이 이를 호출합니다. 호스티드 툴은 현재 Responses API의 호스티드 MCP 통합을 지원하는 OpenAI 모델에서 동작합니다.\n \n-### 기본 호스티드 MCP 툴\n+### Basic hosted MCP tool\n \n-에이전트의 `tools` 목록에 [`HostedMCPTool`][agents.tool.HostedMCPTool]을 추가하여 호스티드 툴을 생성합니다. `tool_config` 딕셔너리는 REST API에 보낼 JSON과 동일합니다:\n+에이전트의 `tools` 목록에 [`HostedMCPTool`][agents.tool.HostedMCPTool]을 추가하여 호스티드 툴을 생성하세요. `tool_config`\n+딕셔너리는 REST API로 전송하는 JSON을 그대로 반영합니다:\n \n ```python\n import asyncio\n@@ -59,9 +63,10 @@ asyncio.run(main())\n \n 호스티드 서버는 도구를 자동으로 노출합니다. `mcp_servers`에 추가할 필요가 없습니다.\n \n-### 스트리밍 호스티드 MCP 결과\n+### Streaming hosted MCP results\n \n-호스티드 툴은 함수 도구와 정확히 동일한 방식으로 스트리밍을 지원합니다. `Runner.run_streamed`에 `stream=True`를 전달하여 모델이 아직 작업 중일 때 점진적인 MCP 출력을 소비할 수 있습니다:\n+호스티드 툴은 함수 도구와 동일한 방식으로 스트리밍 결과를 지원합니다. `Runner.run_streamed`에 `stream=True`를 전달해\n+모델이 아직 작업 중일 때 점진적인 MCP 출력을 소비하세요:\n \n ```python\n result = Runner.run_streamed(agent, \"Summarise this repository's top languages\")\n@@ -71,9 +76,10 @@ async for event in result.stream_events():\n print(result.final_output)\n ```\n \n-### 선택적 승인 플로우\n+### Optional approval flows\n \n-서버가 민감한 작업을 수행할 수 있는 경우, 각 도구 실행 전에 사람 또는 프로그램적 승인을 요구할 수 있습니다. `tool_config`의 `require_approval`을 단일 정책(`\"always\"`, `\"never\"`) 또는 도구 이름에서 정책으로 매핑되는 딕셔너리로 설정하세요. Python 내부에서 결정을 내리려면 `on_approval_request` 콜백을 제공하세요.\n+서버가 민감한 작업을 수행할 수 있는 경우 각 도구 실행 전에 사람 또는 프로그램의 승인을 요구할 수 있습니다. `tool_config`의\n+`require_approval`을 단일 정책(`\"always\"`, `\"never\"`) 또는 도구 이름을 정책에 매핑한 딕셔너리로 구성하세요. Python 내부에서 결정을 내리려면 `on_approval_request` 콜백을 제공하세요.\n \n ```python\n from agents import MCPToolApprovalFunctionResult, MCPToolApprovalRequest\n@@ -101,11 +107,12 @@ agent = Agent(\n )\n ```\n \n-콜백은 동기 또는 비동기로 작성할 수 있으며, 모델이 계속 실행하는 데 필요한 승인 데이터가 필요할 때마다 호출됩니다.\n+콜백은 동기 또는 비동기식일 수 있으며, 모델이 계속 실행하기 위한 승인 데이터가 필요할 때마다 호출됩니다.\n \n-### 커넥터 기반 호스티드 서버\n+### Connector-backed hosted servers\n \n-호스티드 MCP는 OpenAI 커넥터도 지원합니다. `server_url`을 지정하는 대신 `connector_id`와 액세스 토큰을 제공하세요. Responses API가 인증을 처리하고, 호스티드 서버가 커넥터의 도구를 노출합니다.\n+호스티드 MCP는 OpenAI 커넥터도 지원합니다. `server_url`을 지정하는 대신 `connector_id`와 액세스 토큰을 제공하세요.\n+Responses API가 인증을 처리하고 호스티드 서버가 커넥터의 도구를 노출합니다.\n \n ```python\n import os\n@@ -121,11 +128,13 @@ HostedMCPTool(\n )\n ```\n \n-스트리밍, 승인, 커넥터를 포함한 완전한 호스티드 툴 샘플은 [`examples/hosted_mcp`](https://github.com/openai/openai-agents-python/tree/main/examples/hosted_mcp)에 있습니다.\n+스트리밍, 승인, 커넥터를 포함한 완전한 호스티드 툴 샘플은\n+[`examples/hosted_mcp`](https://github.com/openai/openai-agents-python/tree/main/examples/hosted_mcp)에 있습니다.\n \n ## 2. Streamable HTTP MCP servers\n \n-네트워크 연결을 직접 관리하려면 [`MCPServerStreamableHttp`][agents.mcp.server.MCPServerStreamableHttp]를 사용하세요. Streamable HTTP 서버는 전송을 직접 제어하거나, 지연 시간을 낮게 유지하면서 자체 인프라 내에서 서버를 실행하고자 할 때 이상적입니다.\n+네트워크 연결을 직접 관리하려면\n+[`MCPServerStreamableHttp`][agents.mcp.server.MCPServerStreamableHttp]를 사용하세요. 스트리머블 HTTP 서버는 전송을 직접 제어하거나, 지연 시간을 낮게 유지하면서 자체 인프라 내에서 서버를 실행하고자 할 때 이상적입니다.\n \n ```python\n import asyncio\n@@ -164,12 +173,13 @@ asyncio.run(main())\n \n - `client_session_timeout_seconds`는 HTTP 읽기 타임아웃을 제어합니다\n - `use_structured_content`는 `tool_result.structured_content`를 텍스트 출력보다 우선할지 여부를 전환합니다\n-- `max_retry_attempts`와 `retry_backoff_seconds_base`는 `list_tools()` 및 `call_tool()`에 자동 재시도를 추가합니다\n-- `tool_filter`는 노출할 도구의 부분집합만 선택할 수 있게 합니다([Tool filtering](#tool-filtering) 참조)\n+- `max_retry_attempts`와 `retry_backoff_seconds_base`는 `list_tools()`와 `call_tool()`에 대한 자동 재시도를 추가합니다\n+- `tool_filter`를 사용하면 도구의 일부만 노출할 수 있습니다([도구 필터링](#tool-filtering) 참고)\n \n ## 3. HTTP with SSE MCP servers\n \n-MCP 서버가 HTTP with SSE 전송을 구현한다면 [`MCPServerSse`][agents.mcp.server.MCPServerSse]를 인스턴스화하세요. 전송 방식을 제외하면 API는 Streamable HTTP 서버와 동일합니다.\n+MCP 서버가 HTTP with SSE 전송을 구현하는 경우\n+[`MCPServerSse`][agents.mcp.server.MCPServerSse]를 인스턴스화하세요. 전송 방식을 제외하면 API는 스트리머블 HTTP 서버와 동일합니다.\n \n ```python\n \n@@ -198,7 +208,7 @@ async with MCPServerSse(\n \n ## 4. stdio MCP servers\n \n-로컬 하위 프로세스로 실행되는 MCP 서버의 경우 [`MCPServerStdio`][agents.mcp.server.MCPServerStdio]를 사용하세요. SDK가 프로세스를 생성하고 파이프를 열어 유지하며, 컨텍스트 매니저가 종료될 때 자동으로 닫습니다. 이 옵션은 빠른 프로토타이핑이나 서버가 커맨드라인 엔트리 포인트만 노출하는 경우에 유용합니다.\n+로컬 하위 프로세스로 실행되는 MCP 서버에는 [`MCPServerStdio`][agents.mcp.server.MCPServerStdio]를 사용하세요. SDK는 프로세스를 시작하고 파이프를 유지하며 컨텍스트 매니저가 종료될 때 자동으로 닫습니다. 이 옵션은 빠른 프로토타입이나 서버가 커맨드라인 엔트리 포인트만 노출하는 경우에 유용합니다.\n \n ```python\n from pathlib import Path\n@@ -224,11 +234,11 @@ async with MCPServerStdio(\n     print(result.final_output)\n ```\n \n-## 도구 필터링\n+## Tool filtering\n \n 각 MCP 서버는 에이전트에 필요한 기능만 노출할 수 있도록 도구 필터를 지원합니다. 필터링은 생성 시점 또는 실행별로 동적으로 수행할 수 있습니다.\n \n-### 정적 도구 필터링\n+### Static tool filtering\n \n [`create_static_tool_filter`][agents.mcp.create_static_tool_filter]를 사용하여 간단한 허용/차단 목록을 구성하세요:\n \n@@ -248,11 +258,11 @@ filesystem_server = MCPServerStdio(\n )\n ```\n \n-`allowed_tool_names`와 `blocked_tool_names`가 모두 제공되면 SDK는 허용 목록을 먼저 적용한 뒤 남은 집합에서 차단된 도구를 제거합니다.\n+`allowed_tool_names`와 `blocked_tool_names`가 모두 제공된 경우 SDK는 먼저 허용 목록을 적용한 다음 남은 집합에서 차단된 도구를 제거합니다.\n \n-### 동적 도구 필터링\n+### Dynamic tool filtering\n \n-더 정교한 로직이 필요하다면 [`ToolFilterContext`][agents.mcp.ToolFilterContext]를 받는 호출 가능 객체를 전달하세요. 이 호출 가능 객체는 동기 또는 비동기일 수 있으며, 도구를 노출해야 하면 `True`를 반환합니다.\n+더 정교한 로직이 필요하면 [`ToolFilterContext`][agents.mcp.ToolFilterContext]를 받는 호출 가능 객체를 전달하세요. 이 호출 가능 객체는 동기 또는 비동기식일 수 있으며, 도구를 노출해야 하면 `True`를 반환합니다.\n \n ```python\n from pathlib import Path\n@@ -278,11 +288,12 @@ async with MCPServerStdio(\n \n 필터 컨텍스트는 활성 `run_context`, 도구를 요청하는 `agent`, 그리고 `server_name`을 제공합니다.\n \n-## 프롬프트\n+## Prompts\n \n-MCP 서버는 에이전트 instructions를 동적으로 생성하는 프롬프트도 제공할 수 있습니다. 프롬프트를 지원하는 서버는 두 가지 메서드를 노출합니다:\n+MCP 서버는 에이전트 instructions를 동적으로 생성하는 프롬프트도 제공할 수 있습니다. 프롬프트를 지원하는 서버는 두 가지\n+메서드를 노출합니다:\n \n-- `list_prompts()`는 사용 가능한 프롬프트 템플릿을 열거합니다\n+- `list_prompts()`는 사용 가능한 프롬프트 템플릿을 나열합니다\n - `get_prompt(name, arguments)`는 선택적 매개변수와 함께 구체적인 프롬프트를 가져옵니다\n \n ```python\n@@ -301,21 +312,22 @@ agent = Agent(\n )\n ```\n \n-## 캐싱\n+## Caching\n \n-모든 에이전트 실행은 각 MCP 서버에 대해 `list_tools()`를 호출합니다. 원격 서버는 눈에 띄는 지연을 초래할 수 있으므로, 모든 MCP 서버 클래스는 `cache_tools_list` 옵션을 노출합니다. 도구 정의가 자주 변경되지 않는다고 확신할 때만 `True`로 설정하세요. 나중에 새 목록을 강제로 가져오려면 서버 인스턴스에서 `invalidate_tools_cache()`를 호출하세요.\n+모든 에이전트 실행은 각 MCP 서버에서 `list_tools()`를 호출합니다. 원격 서버는 눈에 띄는 지연을 유발할 수 있으므로, 모든 MCP\n+서버 클래스는 `cache_tools_list` 옵션을 노출합니다. 도구 정의가 자주 변경되지 않는다고 확신할 때에만 `True`로 설정하세요. 나중에 새 목록을 강제로 가져오려면 서버 인스턴스에서 `invalidate_tools_cache()`를 호출하세요.\n \n-## 트레이싱\n+## Tracing\n \n-[Tracing](./tracing.md)은 다음을 포함하여 MCP 활동을 자동으로 캡처합니다:\n+[Tracing](./tracing.md)은 MCP 활동을 자동으로 캡처합니다. 포함 내용:\n \n-1. 도구 목록을 가져오기 위한 MCP 서버 호출\n+1. 도구를 나열하기 위한 MCP 서버 호출\n 2. 도구 호출에 대한 MCP 관련 정보\n \n-![MCP Tracing Screenshot](../assets/images/mcp-tracing.jpg)\n+![MCP 트레이싱 스크린샷](../assets/images/mcp-tracing.jpg)\n \n-## 추가 자료\n+## Further reading\n \n-- [Model Context Protocol](https://modelcontextprotocol.io/) – 명세와 설계 가이드\n-- [examples/mcp](https://github.com/openai/openai-agents-python/tree/main/examples/mcp) – 실행 가능한 stdio, SSE, Streamable HTTP 샘플\n-- [examples/hosted_mcp](https://github.com/openai/openai-agents-python/tree/main/examples/hosted_mcp) – 승인과 커넥터를 포함한 완전한 호스티드 MCP 데모\n\\ No newline at end of file\n+- [Model Context Protocol](https://modelcontextprotocol.io/) – 사양 및 설계 가이드\n+- [examples/mcp](https://github.com/openai/openai-agents-python/tree/main/examples/mcp) – 실행 가능한 stdio, SSE, 스트리머블 HTTP 샘플\n+- [examples/hosted_mcp](https://github.com/openai/openai-agents-python/tree/main/examples/hosted_mcp) – 승인 및 커넥터를 포함한 완전한 호스티드 MCP 데모\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Fmcp.md",
        "sha": "a681ed3bd285f04cb0cadc40e55bee2637eb3596",
        "status": "modified"
      },
      {
        "additions": 45,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Fmodels%2Findex.md",
        "changes": 90,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fko%2Fmodels%2Findex.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 45,
        "filename": "docs/ko/models/index.md",
        "patch": "@@ -4,20 +4,20 @@ search:\n ---\n # 모델\n \n-Agents SDK는 OpenAI 모델을 두 가지 형태로 기본 지원합니다:\n+Agents SDK 는 OpenAI 모델을 두 가지 방식으로 바로 사용할 수 있도록 지원합니다:\n \n-- **권장**: [`OpenAIResponsesModel`][agents.models.openai_responses.OpenAIResponsesModel] — 새로운 [Responses API](https://platform.openai.com/docs/api-reference/responses)를 사용하여 OpenAI API를 호출\n-- [`OpenAIChatCompletionsModel`][agents.models.openai_chatcompletions.OpenAIChatCompletionsModel] — [Chat Completions API](https://platform.openai.com/docs/api-reference/chat)를 사용하여 OpenAI API를 호출\n+- **권장**: 새로운 [Responses API](https://platform.openai.com/docs/api-reference/responses)를 사용하는 [`OpenAIResponsesModel`][agents.models.openai_responses.OpenAIResponsesModel]\n+- [Chat Completions API](https://platform.openai.com/docs/api-reference/chat)를 사용하는 [`OpenAIChatCompletionsModel`][agents.models.openai_chatcompletions.OpenAIChatCompletionsModel]\n \n ## OpenAI 모델\n \n-`Agent`를 초기화할 때 모델을 지정하지 않으면 기본 모델이 사용됩니다. 현재 기본값은 호환성과 낮은 지연 시간을 위해 [`gpt-4.1`](https://platform.openai.com/docs/models/gpt-4.1)입니다. 권한이 있다면 더 높은 품질을 위해 에이전트를 [`gpt-5.2`](https://platform.openai.com/docs/models/gpt-5.2)로 설정하고, `model_settings`는 명시적으로 유지할 것을 권장합니다.\n+`Agent` 를 초기화할 때 모델을 지정하지 않으면 기본 모델이 사용됩니다. 현재 기본값은 호환성과 낮은 지연 시간을 위해 [`gpt-4.1`](https://platform.openai.com/docs/models/gpt-4.1) 입니다. 접근 권한이 있다면, 더 높은 품질을 위해 에이전트를 [`gpt-5.2`](https://platform.openai.com/docs/models/gpt-5.2) 로 설정하고 `model_settings` 는 명시적으로 유지할 것을 권장합니다.\n \n-[`gpt-5.2`](https://platform.openai.com/docs/models/gpt-5.2) 같은 다른 모델로 전환하려면 다음 섹션의 단계를 따르세요.\n+[`gpt-5.2`](https://platform.openai.com/docs/models/gpt-5.2) 와 같은 다른 모델로 전환하려면 다음 섹션의 단계를 따르세요.\n \n ### 기본 OpenAI 모델\n \n-사용자 지정 모델을 설정하지 않은 모든 에이전트에 대해 특정 모델을 일관되게 사용하려면, 에이전트를 실행하기 전에 `OPENAI_DEFAULT_MODEL` 환경 변수를 설정하세요.\n+사용자 지정 모델을 설정하지 않은 모든 에이전트에 대해 일관되게 특정 모델을 사용하려면, 에이전트를 실행하기 전에 `OPENAI_DEFAULT_MODEL` 환경 변수를 설정하세요.\n \n ```bash\n export OPENAI_DEFAULT_MODEL=gpt-5\n@@ -26,9 +26,9 @@ python3 my_awesome_agent.py\n \n #### GPT-5 모델\n \n-GPT-5의 reasoning 모델들([`gpt-5`](https://platform.openai.com/docs/models/gpt-5), [`gpt-5-mini`](https://platform.openai.com/docs/models/gpt-5-mini), [`gpt-5-nano`](https://platform.openai.com/docs/models/gpt-5-nano))을 이렇게 사용하면, SDK는 기본적으로 합리적인 `ModelSettings`를 적용합니다. 구체적으로 `reasoning.effort`와 `verbosity`를 모두 `\"low\"`로 설정합니다. 이러한 설정을 직접 구성하려면 `agents.models.get_default_model_settings(\"gpt-5\")`를 호출하세요.\n+이 방식으로 GPT-5 계열 추론 모델([`gpt-5`](https://platform.openai.com/docs/models/gpt-5), [`gpt-5-mini`](https://platform.openai.com/docs/models/gpt-5-mini), [`gpt-5-nano`](https://platform.openai.com/docs/models/gpt-5-nano))을 사용할 때, SDK 는 합리적인 기본 `ModelSettings` 를 적용합니다. 구체적으로 `reasoning.effort` 와 `verbosity` 를 모두 `\"low\"` 로 설정합니다. 이러한 설정을 직접 구성하려면 `agents.models.get_default_model_settings(\"gpt-5\")` 를 호출하세요.\n \n-더 낮은 지연 시간이나 특정 요구 사항이 있다면 다른 모델과 설정을 선택할 수 있습니다. 기본 모델의 reasoning effort를 조정하려면, 사용자 정의 `ModelSettings`를 전달하세요:\n+더 낮은 지연 시간이나 특정 요구 사항이 있는 경우, 다른 모델과 설정을 선택할 수 있습니다. 기본 모델의 추론 노력도를 조정하려면 사용자 정의 `ModelSettings` 를 전달하세요:\n \n ```python\n from openai.types.shared import Reasoning\n@@ -44,52 +44,52 @@ my_agent = Agent(\n )\n ```\n \n-특히 지연 시간을 낮추기 위해 [`gpt-5-mini`](https://platform.openai.com/docs/models/gpt-5-mini) 또는 [`gpt-5-nano`](https://platform.openai.com/docs/models/gpt-5-nano) 모델을 `reasoning.effort=\"minimal\"`로 사용하는 것이 기본 설정보다 더 빠르게 응답을 반환하는 경우가 많습니다. 다만 Responses API의 일부 내장 도구(예: 파일 검색 및 이미지 생성)는 `\"minimal\"` reasoning effort를 지원하지 않으므로, 이 Agents SDK의 기본값은 `\"low\"`입니다.\n+특히 더 낮은 지연 시간을 원한다면, [`gpt-5-mini`](https://platform.openai.com/docs/models/gpt-5-mini) 또는 [`gpt-5-nano`](https://platform.openai.com/docs/models/gpt-5-nano) 모델에 `reasoning.effort=\"minimal\"` 을 사용하는 것이 기본 설정보다 더 빠르게 응답을 반환하는 경우가 많습니다. 다만 Responses API 의 일부 내장 도구(예: 파일 검색과 이미지 생성)는 `\"minimal\"` 추론 노력도를 지원하지 않으므로, 본 Agents SDK 의 기본값은 `\"low\"` 입니다.\n \n-#### 비 GPT-5 모델\n+#### GPT-5가 아닌 모델\n \n-사용자 지정 `model_settings` 없이 비 GPT-5 모델 이름을 전달하면, SDK는 모든 모델과 호환되는 일반적인 `ModelSettings`로 되돌립니다.\n+사용자 지정 `model_settings` 없이 GPT-5가 아닌 모델 이름을 전달하면, SDK 는 모든 모델과 호환되는 일반적인 `ModelSettings` 로 되돌립니다.\n \n-## 비 OpenAI 모델\n+## OpenAI가 아닌 모델\n \n-대부분의 다른 비 OpenAI 모델은 [LiteLLM 통합](./litellm.md)을 통해 사용할 수 있습니다. 먼저 litellm 의존성 그룹을 설치하세요:\n+대부분의 OpenAI가 아닌 모델은 [LiteLLM 연동](./litellm.md)을 통해 사용할 수 있습니다. 먼저, litellm 의존성 그룹을 설치하세요:\n \n ```bash\n pip install \"openai-agents[litellm]\"\n ```\n \n-그런 다음 `litellm/` 접두사를 사용해 [지원되는 모델](https://docs.litellm.ai/docs/providers) 중 아무 것이나 사용하세요:\n+그런 다음, `litellm/` 접두사를 붙여 [지원되는 모델](https://docs.litellm.ai/docs/providers) 을 사용하세요:\n \n ```python\n claude_agent = Agent(model=\"litellm/anthropic/claude-3-5-sonnet-20240620\", ...)\n gemini_agent = Agent(model=\"litellm/gemini/gemini-2.5-flash-preview-04-17\", ...)\n ```\n \n-### 비 OpenAI 모델 사용의 다른 방법\n+### OpenAI가 아닌 모델을 사용하는 다른 방법\n \n-다른 LLM 제공업체는 추가로 3가지 방법으로 통합할 수 있습니다(예시는 [여기](https://github.com/openai/openai-agents-python/tree/main/examples/model_providers/)에 있음):\n+다른 LLM 제공자를 통합하는 방법은 추가로 3가지가 더 있습니다(예시는 [여기](https://github.com/openai/openai-agents-python/tree/main/examples/model_providers/) 를 참고하세요):\n \n-1. [`set_default_openai_client`][agents.set_default_openai_client]는 전역적으로 `AsyncOpenAI` 인스턴스를 LLM 클라이언트로 사용하고자 할 때 유용합니다. 이는 LLM 제공업체가 OpenAI 호환 API 엔드포인트를 제공하고 `base_url`과 `api_key`를 설정할 수 있는 경우에 해당합니다. 구성 가능한 예시는 [examples/model_providers/custom_example_global.py](https://github.com/openai/openai-agents-python/tree/main/examples/model_providers/custom_example_global.py)를 참고하세요.\n-2. [`ModelProvider`][agents.models.interface.ModelProvider]는 `Runner.run` 수준에서 동작합니다. 이를 통해 “이 실행의 모든 에이전트에 사용자 지정 모델 제공업체를 사용”하도록 지정할 수 있습니다. 구성 가능한 예시는 [examples/model_providers/custom_example_provider.py](https://github.com/openai/openai-agents-python/tree/main/examples/model_providers/custom_example_provider.py)를 참고하세요.\n-3. [`Agent.model`][agents.agent.Agent.model]을 사용하면 특정 Agent 인스턴스에서 모델을 지정할 수 있습니다. 이를 통해 에이전트별로 서로 다른 제공업체를 혼합하여 사용할 수 있습니다. 구성 가능한 예시는 [examples/model_providers/custom_example_agent.py](https://github.com/openai/openai-agents-python/tree/main/examples/model_providers/custom_example_agent.py)를 참고하세요. 대부분의 사용 가능한 모델을 쉽게 사용하는 방법은 [LiteLLM 통합](./litellm.md)을 활용하는 것입니다.\n+1. [`set_default_openai_client`][agents.set_default_openai_client] 는 전역적으로 `AsyncOpenAI` 인스턴스를 LLM 클라이언트로 사용하고자 할 때 유용합니다. 이는 LLM 제공자가 OpenAI 호환 API 엔드포인트를 제공하고 `base_url` 과 `api_key` 를 설정할 수 있는 경우에 해당합니다. 구성 가능한 예시는 [examples/model_providers/custom_example_global.py](https://github.com/openai/openai-agents-python/tree/main/examples/model_providers/custom_example_global.py) 를 참고하세요.\n+2. [`ModelProvider`][agents.models.interface.ModelProvider] 는 `Runner.run` 단계에 있습니다. 이를 통해 “이번 실행에서 모든 에이전트에 사용자 지정 모델 제공자를 사용”하도록 지정할 수 있습니다. 구성 가능한 예시는 [examples/model_providers/custom_example_provider.py](https://github.com/openai/openai-agents-python/tree/main/examples/model_providers/custom_example_provider.py) 를 참고하세요.\n+3. [`Agent.model`][agents.agent.Agent.model] 은 특정 Agent 인스턴스에 모델을 지정할 수 있게 합니다. 이를 통해 서로 다른 에이전트에 대해 서로 다른 제공자를 혼합하여 사용할 수 있습니다. 구성 가능한 예시는 [examples/model_providers/custom_example_agent.py](https://github.com/openai/openai-agents-python/tree/main/examples/model_providers/custom_example_agent.py) 를 참고하세요. 대부분의 사용 가능한 모델을 손쉽게 사용하는 방법은 [LiteLLM 연동](./litellm.md) 입니다.\n \n-`platform.openai.com`의 API 키가 없는 경우, `set_tracing_disabled()`로 트레이싱을 비활성화하거나, [다른 트레이싱 프로세서](../tracing.md)를 설정하는 것을 권장합니다.\n+`platform.openai.com` 의 API 키가 없는 경우, `set_tracing_disabled()` 를 통해 트레이싱을 비활성화하거나, [다른 트레이싱 프로세서](../tracing.md) 를 설정하는 것을 권장합니다.\n \n !!! note\n \n-    이 예시들에서는 대부분의 LLM 제공업체가 아직 Responses API를 지원하지 않기 때문에 Chat Completions API/모델을 사용합니다. LLM 제공업체가 이를 지원한다면 Responses 사용을 권장합니다.\n+    이 예시에서는 대부분의 LLM 제공자가 아직 Responses API 를 지원하지 않기 때문에 Chat Completions API/모델을 사용합니다. LLM 제공자가 이를 지원한다면 Responses 사용을 권장합니다.\n \n ## 모델 혼합 및 매칭\n \n-단일 워크플로 내에서 에이전트별로 다른 모델을 사용하고 싶을 수 있습니다. 예를 들어, 선별(트리아지)에는 더 작고 빠른 모델을 사용하고, 복잡한 작업에는 더 크고 강력한 모델을 사용할 수 있습니다. [`Agent`][agents.Agent]를 구성할 때 다음 중 하나로 특정 모델을 선택할 수 있습니다:\n+하나의 워크플로 내에서 에이전트마다 다른 모델을 사용하고 싶을 수 있습니다. 예를 들어, 분류(트리아지)에는 더 작고 빠른 모델을 사용하고, 복잡한 작업에는 더 크고 강력한 모델을 사용할 수 있습니다. [`Agent`][agents.Agent] 를 구성할 때 다음 중 하나의 방법으로 특정 모델을 선택할 수 있습니다:\n \n-1. 모델 이름을 직접 전달\n-2. 임의의 모델 이름 + 해당 이름을 Model 인스턴스로 매핑할 수 있는 [`ModelProvider`][agents.models.interface.ModelProvider]를 전달\n+1. 모델 이름을 전달\n+2. 임의의 모델 이름 + 해당 이름을 Model 인스턴스로 매핑할 수 있는 [`ModelProvider`][agents.models.interface.ModelProvider] 를 전달\n 3. [`Model`][agents.models.interface.Model] 구현체를 직접 제공\n \n !!!note\n \n-    SDK는 [`OpenAIResponsesModel`][agents.models.openai_responses.OpenAIResponsesModel]과 [`OpenAIChatCompletionsModel`][agents.models.openai_chatcompletions.OpenAIChatCompletionsModel] 두 형태를 모두 지원하지만, 두 형태가 지원하는 기능과 도구 집합이 다르므로 각 워크플로에서는 단일 모델 형태를 사용하는 것을 권장합니다. 워크플로에서 다양한 모델 형태를 혼합해야 한다면, 사용하는 모든 기능이 두 형태 모두에서 제공되는지 확인하세요.\n+    SDK 는 [`OpenAIResponsesModel`][agents.models.openai_responses.OpenAIResponsesModel] 과 [`OpenAIChatCompletionsModel`][agents.models.openai_chatcompletions.OpenAIChatCompletionsModel] 두 형태를 모두 지원하지만, 두 형태가 지원하는 기능과 도구 세트가 다르므로 각 워크플로에는 단일 모델 형태 사용을 권장합니다. 워크플로에서 모델 형태를 혼합해야 한다면, 사용하는 모든 기능이 두 형태에서 모두 제공되는지 확인하세요.\n \n ```python\n from agents import Agent, Runner, AsyncOpenAI, OpenAIChatCompletionsModel\n@@ -122,10 +122,10 @@ async def main():\n     print(result.final_output)\n ```\n \n-1. OpenAI 모델의 이름을 직접 설정\n+1. OpenAI 모델 이름을 직접 설정\n 2. [`Model`][agents.models.interface.Model] 구현체를 제공\n \n-에이전트에 사용되는 모델을 더 세부적으로 구성하려면, temperature 같은 선택적 모델 구성 매개변수를 제공하는 [`ModelSettings`][agents.models.interface.ModelSettings]를 전달할 수 있습니다.\n+에이전트에 사용되는 모델을 더 세밀하게 구성하려면, temperature 와 같은 선택적 모델 구성 매개변수를 제공하는 [`ModelSettings`][agents.models.interface.ModelSettings] 를 전달할 수 있습니다.\n \n ```python\n from agents import Agent, ModelSettings\n@@ -138,7 +138,7 @@ english_agent = Agent(\n )\n ```\n \n-또한 OpenAI의 Responses API를 사용할 때는 [몇 가지 다른 선택적 매개변수](https://platform.openai.com/docs/api-reference/responses/create)(예: `user`, `service_tier` 등)가 있습니다. 최상위에서 제공되지 않는 경우 `extra_args`를 사용해 함께 전달할 수 있습니다.\n+또한 OpenAI 의 Responses API 를 사용할 때 [몇 가지 다른 선택적 매개변수](https://platform.openai.com/docs/api-reference/responses/create) (예: `user`, `service_tier` 등)가 있습니다. 최상위에서 제공되지 않는 경우 `extra_args` 를 사용해 함께 전달할 수 있습니다.\n \n ```python\n from agents import Agent, ModelSettings\n@@ -154,39 +154,39 @@ english_agent = Agent(\n )\n ```\n \n-## 다른 LLM 제공업체 사용 시 일반 문제\n+## 다른 LLM 제공자 사용 시 일반적인 문제\n \n-### Tracing 클라이언트 오류 401\n+### 트레이싱 클라이언트 오류 401\n \n-트레이싱 관련 오류가 발생하는 경우, 트레이스가 OpenAI 서버로 업로드되는데 OpenAI API 키가 없기 때문입니다. 해결 방법은 다음 중 하나입니다:\n+트레이싱 관련 오류가 발생하는 경우, 이는 트레이스가 OpenAI 서버로 업로드되는데 OpenAI API 키가 없기 때문입니다. 해결 방법은 세 가지입니다:\n \n-1. 트레이싱 완전 비활성화: [`set_tracing_disabled(True)`][agents.set_tracing_disabled]\n-2. 트레이싱용 OpenAI 키 설정: [`set_tracing_export_api_key(...)`][agents.set_tracing_export_api_key]. 이 API 키는 트레이스 업로드에만 사용되며, [platform.openai.com](https://platform.openai.com/)의 키여야 합니다.\n-3. 비 OpenAI 트레이스 프로세서를 사용. [트레이싱 문서](../tracing.md#custom-tracing-processors)를 참고하세요.\n+1. 트레이싱을 완전히 비활성화: [`set_tracing_disabled(True)`][agents.set_tracing_disabled]\n+2. 트레이싱을 위한 OpenAI 키 설정: [`set_tracing_export_api_key(...)`][agents.set_tracing_export_api_key]. 이 API 키는 트레이스 업로드에만 사용되며, [platform.openai.com](https://platform.openai.com/) 의 키여야 합니다\n+3. OpenAI가 아닌 트레이스 프로세서를 사용. [tracing 문서](../tracing.md#custom-tracing-processors) 를 참고하세요\n \n ### Responses API 지원\n \n-SDK는 기본적으로 Responses API를 사용하지만, 대부분의 다른 LLM 제공업체는 아직 이를 지원하지 않습니다. 그 결과 404 같은 문제가 발생할 수 있습니다. 해결하려면 다음 두 가지 옵션이 있습니다:\n+SDK 는 기본적으로 Responses API 를 사용하지만, 대부분의 다른 LLM 제공자는 아직 이를 지원하지 않습니다. 이로 인해 404 등 유사한 문제가 발생할 수 있습니다. 해결하려면 다음 두 가지 중 하나를 선택하세요:\n \n-1. [`set_default_openai_api(\"chat_completions\")`][agents.set_default_openai_api]를 호출하세요. 환경 변수로 `OPENAI_API_KEY`와 `OPENAI_BASE_URL`을 설정하는 경우에 동작합니다.\n-2. [`OpenAIChatCompletionsModel`][agents.models.openai_chatcompletions.OpenAIChatCompletionsModel]을 사용하세요. 예시는 [여기](https://github.com/openai/openai-agents-python/tree/main/examples/model_providers/)에 있습니다.\n+1. [`set_default_openai_api(\"chat_completions\")`][agents.set_default_openai_api] 를 호출하세요. 환경 변수로 `OPENAI_API_KEY` 와 `OPENAI_BASE_URL` 을 설정한 경우에 동작합니다\n+2. [`OpenAIChatCompletionsModel`][agents.models.openai_chatcompletions.OpenAIChatCompletionsModel] 을 사용하세요. 예시는 [여기](https://github.com/openai/openai-agents-python/tree/main/examples/model_providers/) 에 있습니다\n \n-### Structured outputs 지원\n+### structured outputs 지원\n \n-일부 모델 제공업체는 [structured outputs](https://platform.openai.com/docs/guides/structured-outputs)을 지원하지 않습니다. 이로 인해 다음과 유사한 오류가 발생할 수 있습니다:\n+일부 모델 제공자는 [structured outputs](https://platform.openai.com/docs/guides/structured-outputs) 를 지원하지 않습니다. 이로 인해 다음과 유사한 오류가 발생할 수 있습니다:\n \n ```\n \n BadRequestError: Error code: 400 - {'error': {'message': \"'response_format.type' : value is not one of the allowed values ['text','json_object']\", 'type': 'invalid_request_error'}}\n \n ```\n \n-이는 일부 모델 제공업체의 한계로, JSON 출력을 지원하더라도 출력에 사용할 `json_schema`를 지정할 수 없습니다. 이에 대한 해결책을 마련 중이지만, JSON 스키마 출력을 지원하는 제공업체를 사용하는 것을 권장합니다. 그렇지 않으면 잘못된 JSON 때문에 앱이 자주 중단될 수 있습니다.\n+이는 일부 모델 제공자의 한계로, JSON 출력을 지원하더라도 출력에 사용할 `json_schema` 를 지정할 수 없기 때문입니다. 이에 대한 해결책을 마련 중이지만, JSON 스키마 출력을 지원하는 제공자에 의존할 것을 권장합니다. 그렇지 않으면 잘못된 JSON 때문에 앱이 자주 깨질 수 있습니다.\n \n-## 제공업체 간 모델 혼합\n+## 제공자 간 모델 혼합 사용\n \n-모델 제공업체 간의 기능 차이를 인지하지 못하면 오류가 발생할 수 있습니다. 예를 들어, OpenAI는 structured outputs, 멀티모달 입력, 호스티드 파일 검색 및 웹 검색을 지원하지만, 다른 많은 제공업체는 이러한 기능을 지원하지 않습니다. 다음 제한 사항을 유의하세요:\n+모델 제공자 간 기능 차이를 인지해야 하며, 그렇지 않으면 오류가 발생할 수 있습니다. 예를 들어 OpenAI 는 structured outputs, 멀티모달 입력, 호스티드 파일 검색과 웹 검색을 지원하지만, 다른 많은 제공자는 이러한 기능을 지원하지 않습니다. 다음 제한 사항에 유의하세요:\n \n-- 지원하지 않는 `tools`를 이해하지 못하는 제공업체에 보내지 않기\n-- 텍스트 전용 모델을 호출하기 전에 멀티모달 입력을 필터링\n-- structured JSON 출력을 지원하지 않는 제공업체는 때때로 잘못된 JSON을 생성할 수 있음을 인지하기\n\\ No newline at end of file\n+- 지원하지 않는 제공자에게 이해할 수 없는 `tools` 를 보내지 말 것\n+- 텍스트 전용 모델을 호출하기 전에 멀티모달 입력을 필터링할 것\n+- structured JSON 출력을 지원하지 않는 제공자는 때때로 유효하지 않은 JSON 을 생성할 수 있음을 인지할 것\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Fmodels%2Findex.md",
        "sha": "bbbd823141809175f0e6346f5955cb82665a7537",
        "status": "modified"
      },
      {
        "additions": 13,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Fmodels%2Flitellm.md",
        "changes": 26,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fko%2Fmodels%2Flitellm.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 13,
        "filename": "docs/ko/models/litellm.md",
        "patch": "@@ -2,33 +2,33 @@\n search:\n   exclude: true\n ---\n-# LiteLLM를 통한 임의 모델 사용\n+# LiteLLM 을 통한 임의 모델 사용\n \n !!! note\n \n-    LiteLLM 통합은 베타입니다. 특히 규모가 작은 일부 모델 제공자에서는 문제가 발생할 수 있습니다. [Github issues](https://github.com/openai/openai-agents-python/issues)를 통해 문제를 신고해 주시면 신속히 수정하겠습니다.\n+    LiteLLM 통합은 베타 상태입니다. 특히 소규모 모델 제공업체와 함께 사용할 때 일부 문제가 발생할 수 있습니다. 문제를 발견하시면 [Github issues](https://github.com/openai/openai-agents-python/issues)로 보고해 주시면 신속히 수정하겠습니다.\n \n-[LiteLLM](https://docs.litellm.ai/docs/)은 하나의 인터페이스로 100개 이상의 모델을 사용할 수 있게 해 주는 라이브러리입니다. Agents SDK에서 어떤 AI 모델이든 사용할 수 있도록 LiteLLM 통합을 추가했습니다.\n+[LiteLLM](https://docs.litellm.ai/docs/) 은 단일 인터페이스로 100개 이상의 모델을 사용할 수 있게 해주는 라이브러리입니다. Agents SDK 에 LiteLLM 통합을 추가하여 어떤 AI 모델이든 사용할 수 있습니다.\n \n ## 설정\n \n-`litellm`이 사용 가능한지 확인해야 합니다. 선택적 `litellm` 의존성 그룹을 설치하여 진행할 수 있습니다:\n+`litellm` 이 사용 가능해야 합니다. 선택적 `litellm` 의존성 그룹을 설치하여 설정할 수 있습니다:\n \n ```bash\n pip install \"openai-agents[litellm]\"\n ```\n \n-설치가 끝나면, 어떤 에이전트에서든 [`LitellmModel`][agents.extensions.models.litellm_model.LitellmModel]을 사용할 수 있습니다.\n+완료되면 어떤 에이전트에서든 [`LitellmModel`][agents.extensions.models.litellm_model.LitellmModel] 을 사용할 수 있습니다.\n \n-## 예제\n+## 예시\n \n-다음은 완전히 동작하는 예제입니다. 실행하면 모델 이름과 API 키를 입력하라는 프롬프트가 표시됩니다. 예를 들어 다음과 같이 입력할 수 있습니다:\n+다음은 완전히 동작하는 예시입니다. 실행하면 모델 이름과 API 키를 입력하라는 메시지가 표시됩니다. 예를 들어 다음과 같이 입력할 수 있습니다:\n \n-- `openai/gpt-4.1` 모델과 OpenAI API 키\n-- `anthropic/claude-3-5-sonnet-20240620` 모델과 Anthropic API 키\n-- 등등\n+-   모델에 `openai/gpt-4.1`, 그리고 OpenAI API 키\n+-   모델에 `anthropic/claude-3-5-sonnet-20240620`, 그리고 Anthropic API 키\n+-   기타 등등\n \n-LiteLLM에서 지원되는 모델의 전체 목록은 [litellm providers docs](https://docs.litellm.ai/docs/providers)를 참고하세요.\n+LiteLLM 에서 지원하는 전체 모델 목록은 [litellm providers docs](https://docs.litellm.ai/docs/providers) 를 참고하세요.\n \n ```python\n from __future__ import annotations\n@@ -78,7 +78,7 @@ if __name__ == \"__main__\":\n \n ## 사용량 데이터 추적\n \n-LiteLLM 응답으로 Agents SDK 사용량 지표를 채우려면 에이전트를 생성할 때 `ModelSettings(include_usage=True)`를 전달하세요.\n+LiteLLM 응답을 Agents SDK 사용량 메트릭에 채우려면, 에이전트를 생성할 때 `ModelSettings(include_usage=True)` 를 전달하세요.\n \n ```python\n from agents import Agent, ModelSettings\n@@ -91,4 +91,4 @@ agent = Agent(\n )\n ```\n \n-`include_usage=True`인 경우, LiteLLM 요청은 기본 OpenAI 모델과 마찬가지로 `result.context_wrapper.usage`를 통해 토큰 및 요청 수를 보고합니다.\n\\ No newline at end of file\n+`include_usage=True` 를 사용하면, LiteLLM 요청은 기본 제공 OpenAI 모델과 마찬가지로 `result.context_wrapper.usage` 를 통해 토큰 및 요청 수를 보고합니다.\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Fmodels%2Flitellm.md",
        "sha": "9a0ad16729c214bb46281deb401e32a93a4d4c59",
        "status": "modified"
      },
      {
        "additions": 21,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Fmulti_agent.md",
        "changes": 42,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fko%2Fmulti_agent.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 21,
        "filename": "docs/ko/multi_agent.md",
        "patch": "@@ -4,38 +4,38 @@ search:\n ---\n # 멀티 에이전트 오케스트레이션\n \n-오케스트레이션은 앱에서 에이전트의 흐름을 의미합니다. 어떤 에이전트를 어떤 순서로 실행하며, 다음에 무엇을 할지 어떻게 결정할까요? 에이전트를 오케스트레이션하는 방법은 크게 두 가지가 있습니다:\n+오케스트레이션은 앱에서 에이전트가 흐르는 방식을 말합니다. 어떤 에이전트가 어떤 순서로 실행되며, 다음 단계를 어떻게 결정할까요? 에이전트를 오케스트레이션하는 방법은 두 가지가 있습니다:\n \n-1. LLM이 결정을 내리도록 허용: LLM의 지능을 활용해 계획하고 추론하며, 그에 따라 수행할 단계를 결정\n-2. 코드로 오케스트레이션: 코드로 에이전트의 흐름을 결정\n+1. LLM 에게 결정을 맡기기: LLM 의 지능을 활용해 계획하고 추론하며 그에 따라 수행할 단계를 결정\n+2. 코드로 오케스트레이션하기: 코드로 에이전트의 흐름을 결정\n \n-이 두 패턴은 혼합해 사용할 수 있습니다. 각각의 트레이드오프는 아래에 설명되어 있습니다.\n+이 패턴은 혼합해서 사용할 수 있습니다. 각각의 트레이드오프는 아래에 설명합니다.\n \n ## LLM 기반 오케스트레이션\n \n-에이전트는 instructions, tools 및 핸드오프로 장착된 LLM입니다. 이는 개방형 작업이 주어졌을 때, LLM이 도구를 사용해 행동하고 데이터를 획득하며, 핸드오프를 통해 하위 에이전트에 작업을 위임하면서 작업을 수행할 계획을 자율적으로 세울 수 있음을 의미합니다. 예를 들어, 리서치 에이전트는 다음과 같은 도구를 갖출 수 있습니다:\n+에이전트는 instructions, tools 및 핸드오프로 장착된 LLM 입니다. 이는 개방형 태스크가 주어졌을 때, LLM 이 도구를 사용해 행동하고 데이터를 획득하며, 핸드오프를 통해 하위 에이전트에 작업을 위임하면서 태스크를 수행하는 계획을 자율적으로 세울 수 있음을 의미합니다. 예를 들어, 리서치 에이전트는 다음과 같은 도구를 갖출 수 있습니다:\n \n-- 웹 검색을 통한 온라인 정보 탐색\n-- 파일 검색 및 검색을 통한 자체 데이터 및 커넥션 탐색\n-- 컴퓨터 사용을 통한 컴퓨터 상의 행동 수행\n+- 온라인에서 정보를 찾기 위한 웹 검색\n+- 사내 데이터와 연결을 탐색하기 위한 파일 검색 및 조회\n+- 컴퓨터에서 직접 작업을 수행하기 위한 컴퓨터 사용\n - 데이터 분석을 위한 코드 실행\n-- 기획, 보고서 작성 등에 특화된 에이전트로의 핸드오프\n+- 기획, 보고서 작성 등 특정 작업에 뛰어난 전문 에이전트로의 핸드오프\n \n-이 패턴은 작업이 개방형이고 LLM의 지능에 의존하고자 할 때 특히 유용합니다. 여기서 가장 중요한 전술은 다음과 같습니다:\n+이 패턴은 태스크가 개방형이고 LLM 의 지능에 의존하고 싶을 때 유용합니다. 중요한 전술은 다음과 같습니다:\n \n-1. 좋은 프롬프트에 투자하세요. 사용 가능한 도구, 사용 방법, 그리고 운영해야 하는 매개변수를 명확히 하세요.\n-2. 앱을 모니터링하고 반복 개선하세요. 어디에서 문제가 발생하는지 확인하고 프롬프트를 개선하세요.\n-3. 에이전트가 자기 성찰하고 개선하도록 허용하세요. 예를 들어 루프에서 실행하며 스스로 비판하게 하거나, 오류 메시지를 제공해 개선하도록 하세요.\n-4. 모든 분야에 능한 범용 에이전트 대신, 하나의 작업에 뛰어난 특화 에이전트를 두세요.\n-5. [evals](https://platform.openai.com/docs/guides/evals)에 투자하세요. 이를 통해 에이전트를 학습시켜 작업 성능을 향상할 수 있습니다.\n+1. 좋은 프롬프트에 투자하세요. 사용 가능한 도구, 사용 방법, 그리고 준수해야 할 매개변수를 명확히 하세요.\n+2. 앱을 모니터링하고 반복 개선하세요. 문제가 생기는 지점을 파악하고 프롬프트를 개선하세요.\n+3. 에이전트가 스스로 성찰하고 개선하도록 하세요. 예를 들어 루프로 실행해 자기 비평을 하게 하거나, 오류 메시지를 제공해 개선하도록 하세요.\n+4. 모든 것을 잘하려는 범용 에이전트 대신 하나의 작업에 특화된 에이전트를 두세요.\n+5. [평가(evals)](https://platform.openai.com/docs/guides/evals)에 투자하세요. 이를 통해 에이전트를 학습시켜 태스크 수행 능력을 향상할 수 있습니다.\n \n ## 코드 기반 오케스트레이션\n \n-LLM 기반 오케스트레이션이 강력하긴 하지만, 코드 기반 오케스트레이션은 속도, 비용, 성능 면에서 더 결정적이고 예측 가능하게 만듭니다. 일반적인 패턴은 다음과 같습니다:\n+LLM 기반 오케스트레이션이 강력하긴 하지만, 코드 기반 오케스트레이션은 속도, 비용, 성능 면에서 더 결정론적이고 예측 가능하게 만듭니다. 일반적인 패턴은 다음과 같습니다:\n \n-- [structured outputs](https://platform.openai.com/docs/guides/structured-outputs)를 사용해 코드로 검사할 수 있는 적절한 형식의 데이터를 생성. 예를 들어, 에이전트에게 작업을 몇 가지 카테고리로 분류하도록 요청한 다음, 해당 카테고리에 따라 다음 에이전트를 선택할 수 있음\n-- 하나의 에이전트 출력을 다음 에이전트 입력으로 변환하여 여러 에이전트를 체이닝. 블로그 글 작성 같은 작업을 리서치, 개요 작성, 본문 작성, 비판, 개선의 일련의 단계로 분해할 수 있음\n-- 수행 에이전트와 평가 및 피드백을 제공하는 에이전트를 `while` 루프로 함께 실행해, 평가자가 출력이 특정 기준을 통과했다고 말할 때까지 반복\n-- 여러 에이전트를 병렬로 실행. 예: `asyncio.gather` 같은 Python 기본 컴포넌트를 활용. 서로 의존하지 않는 여러 작업이 있을 때 속도 향상에 유용\n+- [structured outputs](https://platform.openai.com/docs/guides/structured-outputs)를 사용해 코드로 검사할 수 있는 적절한 형식의 데이터를 생성. 예를 들어 에이전트에게 태스크를 몇 가지 카테고리로 분류하게 한 뒤, 그 카테고리에 따라 다음 에이전트를 선택할 수 있음\n+- 한 에이전트의 출력을 다음 에이전트의 입력으로 변환하여 여러 에이전트를 체이닝. 예를 들어 블로그 글 작성 태스크를 리서치, 개요 작성, 본문 작성, 비평, 개선의 연속적인 단계로 분해\n+- 평가와 피드백을 제공하는 에이전트와 함께 태스크 수행 에이전트를 `while` 루프에서 실행하고, 평가자가 출력이 특정 기준을 충족한다고 할 때까지 반복\n+- 여러 에이전트를 병렬로 실행. 예: `asyncio.gather` 와 같은 Python 기본 구성 요소를 사용. 서로 의존하지 않는 여러 태스크가 있을 때 속도 향상에 유용\n \n-[`examples/agent_patterns`](https://github.com/openai/openai-agents-python/tree/main/examples/agent_patterns) 에 다양한 code examples가 있습니다.\n\\ No newline at end of file\n+[`examples/agent_patterns`](https://github.com/openai/openai-agents-python/tree/main/examples/agent_patterns) 에 다양한 code examples 를 찾아볼 수 있습니다.\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Fmulti_agent.md",
        "sha": "aa4971112d10a9041a1c460f3aa0016d5fdc1f59",
        "status": "modified"
      },
      {
        "additions": 18,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Fquickstart.md",
        "changes": 36,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fko%2Fquickstart.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 18,
        "filename": "docs/ko/quickstart.md",
        "patch": "@@ -2,11 +2,11 @@\n search:\n   exclude: true\n ---\n-# 빠른 시작\n+# 퀵스타트\n \n-## 프로젝트와 가상 환경 생성\n+## 프로젝트 및 가상 환경 생성\n \n-한 번만 수행하면 됩니다.\n+이 작업은 한 번만 수행하면 됩니다.\n \n ```bash\n mkdir my_project\n@@ -16,7 +16,7 @@ python -m venv .venv\n \n ### 가상 환경 활성화\n \n-새 터미널 세션을 시작할 때마다 수행하세요.\n+새 터미널 세션을 시작할 때마다 실행하세요.\n \n ```bash\n source .venv/bin/activate\n@@ -30,15 +30,15 @@ pip install openai-agents # or `uv add openai-agents`, etc\n \n ### OpenAI API 키 설정\n \n-아직 없다면 OpenAI API 키를 생성하려면 [이 지침](https://platform.openai.com/docs/quickstart#create-and-export-an-api-key)을 따르세요.\n+아직 없다면 OpenAI API 키를 생성하려면 [이 안내](https://platform.openai.com/docs/quickstart#create-and-export-an-api-key)를 따라주세요.\n \n ```bash\n export OPENAI_API_KEY=sk-...\n ```\n \n ## 첫 에이전트 생성\n \n-에이전트는 instructions, 이름, 그리고 선택적 구성(예: `model_config`)으로 정의됩니다\n+에이전트는 instructions, 이름, 선택적 구성(예: `model_config`)으로 정의됩니다\n \n ```python\n from agents import Agent\n@@ -49,9 +49,9 @@ agent = Agent(\n )\n ```\n \n-## 에이전트 몇 개 더 추가\n+## 에이전트 추가\n \n-추가 에이전트도 같은 방식으로 정의할 수 있습니다. `handoff_descriptions`는 핸드오프 라우팅을 결정하는 데 추가 컨텍스트를 제공합니다\n+추가 에이전트도 같은 방식으로 정의할 수 있습니다. `handoff_descriptions`는 핸드오프 라우팅을 결정하는 데 필요한 추가 컨텍스트를 제공합니다\n \n ```python\n from agents import Agent\n@@ -71,7 +71,7 @@ math_tutor_agent = Agent(\n \n ## 핸드오프 정의\n \n-각 에이전트에서, 작업을 진행하는 방법을 결정할 때 선택할 수 있는 아웃바운드 핸드오프 옵션의 목록을 정의할 수 있습니다.\n+각 에이전트에서 작업을 진행하는 방법을 결정하기 위해 선택할 수 있는 아웃고잉 핸드오프 옵션 목록을 정의할 수 있습니다.\n \n ```python\n triage_agent = Agent(\n@@ -83,7 +83,7 @@ triage_agent = Agent(\n \n ## 에이전트 오케스트레이션 실행\n \n-워크플로가 실행되고 트리아지 에이전트가 두 전문 에이전트 사이에서 올바르게 라우팅하는지 확인해 봅시다.\n+워크플로가 실행되고 분류(트리아지) 에이전트가 두 전문 에이전트 사이를 올바르게 라우팅하는지 확인해 보겠습니다.\n \n ```python\n from agents import Runner\n@@ -95,7 +95,7 @@ async def main():\n \n ## 가드레일 추가\n \n-입력 또는 출력에 대해 실행되는 사용자 지정 가드레일을 정의할 수 있습니다.\n+입력 또는 출력에 대해 사용자 정의 가드레일을 정의할 수 있습니다.\n \n ```python\n from agents import GuardrailFunctionOutput, Agent, Runner\n@@ -121,9 +121,9 @@ async def homework_guardrail(ctx, agent, input_data):\n     )\n ```\n \n-## 전체 통합\n+## 전체 워크플로 통합\n \n-모두 합쳐 전체 워크플로를 실행해 봅시다. 핸드오프와 입력 가드레일을 사용합니다.\n+모든 것을 합쳐서, 핸드오프와 입력 가드레일을 사용해 전체 워크플로를 실행해 보겠습니다.\n \n ```python\n from agents import Agent, InputGuardrail, GuardrailFunctionOutput, Runner\n@@ -192,12 +192,12 @@ if __name__ == \"__main__\":\n \n ## 트레이스 보기\n \n-에이전트 실행 중에 무엇이 일어났는지 검토하려면 [OpenAI 대시보드의 Trace viewer](https://platform.openai.com/traces)로 이동하여 에이전트 실행의 트레이스를 확인하세요.\n+에이전트 실행 중에 무슨 일이 있었는지 검토하려면 [OpenAI Dashboard의 Trace viewer](https://platform.openai.com/traces)로 이동하여 에이전트 실행 트레이스를 확인하세요.\n \n ## 다음 단계\n \n-더 복잡한 에이전트 플로를 만드는 방법 알아보기:\n+더 복잡한 에이전트 플로우를 만드는 방법을 알아보세요:\n \n-- Learn about how to configure [에이전트](agents.md).\n-- Learn about [running agents](running_agents.md).\n-- Learn about [도구](tools.md), [가드레일](guardrails.md) and [모델](models/index.md).\n\\ No newline at end of file\n+- [에이전트](agents.md) 구성 방법 알아보기\n+- [에이전트 실행](running_agents.md) 알아보기\n+- [도구](tools.md), [가드레일](guardrails.md), [모델](models/index.md) 알아보기\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Fquickstart.md",
        "sha": "f9bc9b061e30725bc27d88d3b92264b6cec8f7e0",
        "status": "modified"
      },
      {
        "additions": 41,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Frealtime%2Fguide.md",
        "changes": 82,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fko%2Frealtime%2Fguide.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 41,
        "filename": "docs/ko/realtime/guide.md",
        "patch": "@@ -4,65 +4,65 @@ search:\n ---\n # 가이드\n \n-이 가이드는 OpenAI Agents SDK의 실시간 기능을 사용하여 음성 기반 AI 에이전트를 구축하는 방법을 자세히 설명합니다.\n+이 가이드는 OpenAI Agents SDK의 실시간 기능을 사용해 음성 지원 AI 에이전트를 구축하는 방법을 자세히 설명합니다.\n \n-!!! warning \"Beta feature\"\n-Realtime agents are in beta. Expect some breaking changes as we improve the implementation.\n+!!! warning \"베타 기능\"\n+실시간 에이전트는 베타 상태입니다. 구현을 개선하는 동안 호환성 깨짐이 발생할 수 있습니다.\n \n ## 개요\n \n-Realtime agents는 오디오와 텍스트 입력을 실시간으로 처리하고 실시간 오디오로 응답하는 대화 흐름을 제공합니다. OpenAI의 Realtime API와 지속적인 연결을 유지하여, 낮은 지연으로 자연스러운 음성 대화를 가능하게 하고 인터럽션(중단 처리)을 원활하게 처리합니다.\n+실시간 에이전트는 대화형 플로우를 가능하게 하여 오디오와 텍스트 입력을 실시간으로 처리하고 실시간 오디오로 응답합니다. OpenAI의 Realtime API와 지속적인 연결을 유지해 낮은 지연의 자연스러운 음성 대화를 제공하며, 인터럽션(중단 처리)을 우아하게 처리할 수 있습니다.\n \n ## 아키텍처\n \n ### 핵심 구성 요소\n \n-실시간 시스템은 여러 핵심 구성 요소로 이루어져 있습니다:\n+실시간 시스템은 다음과 같은 주요 구성 요소로 이루어집니다:\n \n--   **RealtimeAgent**: instructions, tools, handoffs로 구성된 에이전트\n--   **RealtimeRunner**: 구성을 관리합니다. `runner.run()`을 호출하여 세션을 얻을 수 있습니다\n--   **RealtimeSession**: 단일 상호작용 세션입니다. 일반적으로 사용자가 대화를 시작할 때마다 하나를 생성하고 대화가 끝날 때까지 유지합니다\n+-   **RealtimeAgent**: instructions, tools, 핸드오프로 구성된 에이전트\n+-   **RealtimeRunner**: 구성을 관리합니다. `runner.run()`을 호출해 세션을 얻을 수 있습니다.\n+-   **RealtimeSession**: 단일 상호작용 세션입니다. 일반적으로 사용자가 대화를 시작할 때마다 하나를 만들고, 대화가 끝날 때까지 유지합니다.\n -   **RealtimeModel**: 기본 모델 인터페이스(일반적으로 OpenAI의 WebSocket 구현)\n \n ### 세션 흐름\n \n-일반적인 실시간 세션은 다음 흐름을 따릅니다:\n+일반적인 실시간 세션 흐름은 다음과 같습니다:\n \n-1. instructions, tools, handoffs와 함께 **RealtimeAgent(들)를 생성**합니다\n-2. 에이전트와 구성 옵션으로 **RealtimeRunner를 설정**합니다\n-3. `await runner.run()`을 사용해 **세션을 시작**하고, RealtimeSession을 반환받습니다\n-4. `send_audio()` 또는 `send_message()`를 사용해 **오디오 또는 텍스트 메시지를 전송**합니다\n-5. 세션을 순회(iterate)하며 **이벤트를 수신**합니다 - 이벤트에는 오디오 출력, 전사, 도구 호출, 핸드오프, 오류가 포함됩니다\n-6. 사용자가 에이전트 말 중간에 말할 때 **인터럽션(중단 처리)** 을 처리합니다. 현재 오디오 생성이 자동으로 중지됩니다\n+1. instructions, tools, 핸드오프로 **RealtimeAgent**를 생성\n+2. 에이전트와 구성 옵션으로 **RealtimeRunner 설정**\n+3. `await runner.run()`을 사용해 **세션 시작**. 이 호출은 RealtimeSession을 반환\n+4. `send_audio()` 또는 `send_message()`로 **오디오 또는 텍스트 메시지 전송**\n+5. 세션을 순회(iterate)하며 **이벤트 수신**: 오디오 출력, 전사, 도구 호출, 핸드오프, 오류 등\n+6. 사용자가 에이전트가 말하는 도중 말할 때 **인터럽션 처리**: 현재 오디오 생성이 자동으로 중단\n \n-세션은 대화 기록을 유지하고 실시간 모델과의 지속 연결을 관리합니다.\n+세션은 대화 기록을 유지하고 실시간 모델과의 지속적 연결을 관리합니다.\n \n ## 에이전트 구성\n \n-RealtimeAgent는 일반 Agent 클래스와 유사하게 동작하지만 몇 가지 중요한 차이가 있습니다. 전체 API 세부 정보는 [`RealtimeAgent`][agents.realtime.agent.RealtimeAgent] API 레퍼런스를 참고하세요.\n+RealtimeAgent는 일반 Agent 클래스와 유사하지만 몇 가지 중요한 차이점이 있습니다. 전체 API 세부 정보는 [`RealtimeAgent`][agents.realtime.agent.RealtimeAgent] API 레퍼런스를 참조하세요.\n \n 일반 에이전트와의 주요 차이점:\n \n--   모델 선택은 에이전트 레벨이 아닌 세션 레벨에서 구성합니다\n--   structured output 지원이 없습니다(`outputType` 미지원)\n--   음성은 에이전트별로 설정할 수 있으나, 첫 번째 에이전트가 말하기 시작한 이후에는 변경할 수 없습니다\n--   그 외 도구, 핸드오프, instructions 등은 동일하게 동작합니다\n+-   모델 선택은 에이전트 레벨이 아닌 세션 레벨에서 구성\n+-   structured outputs 지원 없음 (`outputType` 미지원)\n+-   보이스는 에이전트별로 설정할 수 있지만, 첫 번째 에이전트가 말하기 시작한 후에는 변경 불가\n+-   tools, 핸드오프, instructions 등 기타 기능은 동일하게 동작\n \n ## 세션 구성\n \n ### 모델 설정\n \n-세션 구성에서는 기본 실시간 모델의 동작을 제어할 수 있습니다. 모델 이름(예: `gpt-realtime`), 음성 선택(alloy, echo, fable, onyx, nova, shimmer), 지원하는 모달리티(텍스트 및/또는 오디오)를 설정할 수 있습니다. 오디오 형식은 입력과 출력 모두에 대해 설정 가능하며, 기본값은 PCM16입니다.\n+세션 구성으로 기본 실시간 모델 동작을 제어할 수 있습니다. 모델 이름(예: `gpt-realtime`), 보이스 선택(alloy, echo, fable, onyx, nova, shimmer), 지원 모달리티(텍스트 및/또는 오디오)를 설정할 수 있습니다. 오디오 포맷은 입력과 출력 모두에서 설정 가능하며, 기본값은 PCM16입니다.\n \n ### 오디오 구성\n \n-오디오 설정은 세션이 음성 입력과 출력을 처리하는 방식을 제어합니다. Whisper와 같은 모델을 사용한 입력 오디오 전사, 언어 선호 설정, 도메인 특화 용어의 정확도를 높이기 위한 전사 프롬프트를 구성할 수 있습니다. 턴 감지 설정은 에이전트가 언제 응답을 시작하고 멈출지 제어하며, 음성 활동 감지 임계값, 무음 지속 시간, 감지된 발화 주변 패딩 등의 옵션을 제공합니다.\n+오디오 설정은 세션이 음성 입력과 출력을 처리하는 방식을 제어합니다. Whisper와 같은 모델로 입력 오디오 전사를 설정하고, 언어 선호도를 지정하며, 도메인 특화 용어의 정확도를 높이기 위한 전사 프롬프트를 제공할 수 있습니다. 발화 감지 설정으로 에이전트가 언제 응답을 시작하고 멈출지 제어할 수 있으며, 음성 활동 감지 임계값, 무음 지속 시간, 감지된 발화 주변 패딩 등의 옵션을 제공합니다.\n \n ## 도구와 함수\n \n ### 도구 추가\n \n-일반 에이전트와 마찬가지로, realtime agents는 대화 중에 실행되는 함수 도구를 지원합니다:\n+일반 에이전트와 마찬가지로, 실시간 에이전트는 대화 중 실행되는 함수 도구를 지원합니다:\n \n ```python\n from agents import function_tool\n@@ -119,20 +119,20 @@ main_agent = RealtimeAgent(\n \n ## 이벤트 처리\n \n-세션은 세션 객체를 순회(iterate)하여 수신할 수 있는 이벤트를 스트리밍합니다. 이벤트에는 오디오 출력 청크, 전사 결과, 도구 실행 시작/종료, 에이전트 핸드오프, 오류가 포함됩니다. 처리해야 할 주요 이벤트는 다음과 같습니다:\n+세션은 세션 객체를 순회하여 수신할 수 있는 이벤트를 스트리밍합니다. 이벤트에는 오디오 출력 청크, 전사 결과, 도구 실행 시작/종료, 에이전트 핸드오프, 오류 등이 포함됩니다. 처리해야 할 주요 이벤트는 다음과 같습니다:\n \n--   **audio**: 에이전트 응답의 원문 오디오 데이터\n--   **audio_end**: 에이전트 발화 종료\n--   **audio_interrupted**: 사용자가 에이전트를 인터럽션(중단 처리)\n--   **tool_start/tool_end**: 도구 실행 생애주기\n+-   **audio**: 에이전트 응답의 원시 오디오 데이터\n+-   **audio_end**: 에이전트가 말하기 종료\n+-   **audio_interrupted**: 사용자가 에이전트를 중단\n+-   **tool_start/tool_end**: 도구 실행 라이프사이클\n -   **handoff**: 에이전트 핸드오프 발생\n -   **error**: 처리 중 오류 발생\n \n-자세한 이벤트 목록은 [`RealtimeSessionEvent`][agents.realtime.events.RealtimeSessionEvent]를 참고하세요.\n+전체 이벤트 세부 사항은 [`RealtimeSessionEvent`][agents.realtime.events.RealtimeSessionEvent]를 참조하세요.\n \n ## 가드레일\n \n-Realtime agents는 출력 가드레일만 지원합니다. 성능 문제를 피하기 위해 실시간 생성 중 매 단어마다가 아니라 디바운싱되어 주기적으로 실행됩니다. 기본 디바운스 길이는 100자이며, 설정 가능합니다.\n+실시간 에이전트는 출력 가드레일만 지원합니다. 성능 문제를 방지하기 위해, 이 가드레일은 디바운싱 처리되어(모든 단어마다가 아니라) 주기적으로 실행됩니다. 기본 디바운스 길이는 100자이며, 구성 가능합니다.\n \n 가드레일은 `RealtimeAgent`에 직접 연결하거나 세션의 `run_config`를 통해 제공할 수 있습니다. 두 소스의 가드레일은 함께 실행됩니다.\n \n@@ -152,19 +152,19 @@ agent = RealtimeAgent(\n )\n ```\n \n-가드레일이 트리거되면 `guardrail_tripped` 이벤트를 생성하고 에이전트의 현재 응답을 인터럽트할 수 있습니다. 디바운스 동작은 안전성과 실시간 성능 요구 사항 간의 균형을 맞추는 데 도움이 됩니다. 텍스트 에이전트와 달리, realtime agents는 가드레일이 작동해도 Exception을 발생시키지 않습니다.\n+가드레일이 트리거되면 `guardrail_tripped` 이벤트를 생성하고, 에이전트의 현재 응답을 인터럽트할 수 있습니다. 디바운스 동작은 안전성과 실시간 성능 요구사항의 균형을 맞추는 데 도움을 줍니다. 텍스트 에이전트와 달리, 실시간 에이전트는 가드레일이 트리거되어도 Exception을 발생시키지 **않습니다**.\n \n ## 오디오 처리\n \n-[`session.send_audio(audio_bytes)`][agents.realtime.session.RealtimeSession.send_audio]로 오디오를 세션에 전송하거나, [`session.send_message()`][agents.realtime.session.RealtimeSession.send_message]로 텍스트를 전송하세요.\n+[`session.send_audio(audio_bytes)`][agents.realtime.session.RealtimeSession.send_audio]를 사용해 오디오를 세션으로 보내거나, [`session.send_message()`][agents.realtime.session.RealtimeSession.send_message]를 사용해 텍스트를 전송하세요.\n \n-오디오 출력의 경우 `audio` 이벤트를 수신하고 선호하는 오디오 라이브러리를 통해 오디오 데이터를 재생하세요. 사용자가 에이전트를 인터럽션할 때 재생을 즉시 중지하고 대기 중인 오디오를 지우기 위해 `audio_interrupted` 이벤트를 반드시 수신하세요.\n+오디오 출력을 위해서는 `audio` 이벤트를 수신하고 선호하는 오디오 라이브러리를 통해 오디오 데이터를 재생하세요. 사용자가 에이전트를 중단할 때 즉시 재생을 중지하고 대기 중인 오디오를 모두 비우기 위해 `audio_interrupted` 이벤트를 반드시 수신하세요.\n \n-## SIP 통합\n+## SIP 연동\n \n-[Realtime Calls API](https://platform.openai.com/docs/guides/realtime-sip)를 통해 들어오는 전화에 realtime agents를 연결할 수 있습니다. SDK는 SIP를 통해 미디어를 협상하면서 동일한 에이전트 플로우를 재사용하는 [`OpenAIRealtimeSIPModel`][agents.realtime.openai_realtime.OpenAIRealtimeSIPModel]을 제공합니다.\n+[Realtime Calls API](https://platform.openai.com/docs/guides/realtime-sip)로 수신되는 전화 통화에 실시간 에이전트를 연결할 수 있습니다. SDK는 [`OpenAIRealtimeSIPModel`][agents.realtime.openai_realtime.OpenAIRealtimeSIPModel]을 제공하며, SIP를 통해 미디어를 협상하면서 동일한 에이전트 플로우를 재사용합니다.\n \n-사용하려면, 러너에 모델 인스턴스를 전달하고 세션 시작 시 SIP `call_id`를 제공하세요. 통화 ID는 수신 전화를 알리는 웹훅을 통해 전달됩니다.\n+사용하려면 모델 인스턴스를 러너에 전달하고 세션 시작 시 SIP `call_id`를 제공하세요. 통화 ID는 수신 전화를 알리는 웹훅으로 전달됩니다.\n \n ```python\n from agents.realtime import RealtimeAgent, RealtimeRunner\n@@ -187,19 +187,19 @@ async with await runner.run(\n         ...\n ```\n \n-발신자가 전화를 끊으면 SIP 세션이 종료되고 실시간 연결이 자동으로 닫힙니다. 전체 전화 예시는 [`examples/realtime/twilio_sip`](https://github.com/openai/openai-agents-python/tree/main/examples/realtime/twilio_sip)를 참고하세요.\n+발신자가 전화를 끊으면 SIP 세션이 종료되고 실시간 연결이 자동으로 닫힙니다. 완전한 전화 연동 예시는 [`examples/realtime/twilio_sip`](https://github.com/openai/openai-agents-python/tree/main/examples/realtime/twilio_sip)을 참조하세요.\n \n ## 모델 직접 액세스\n \n-기본 모델에 접근하여 커스텀 리스너를 추가하거나 고급 작업을 수행할 수 있습니다:\n+기본 모델에 액세스해 커스텀 리스너를 추가하거나 고급 작업을 수행할 수 있습니다:\n \n ```python\n # Add a custom listener to the model\n session.model.add_listener(my_custom_listener)\n ```\n \n-이는 연결에 대한 하위 수준 제어가 필요한 고급 사용 사례를 위해 [`RealtimeModel`][agents.realtime.model.RealtimeModel] 인터페이스에 직접 접근할 수 있도록 합니다.\n+이 방법을 통해 연결에 대한 저수준 제어가 필요한 고급 사용 사례를 위해 [`RealtimeModel`][agents.realtime.model.RealtimeModel] 인터페이스에 직접 접근할 수 있습니다.\n \n ## 코드 예제\n \n-완전한 동작 예시는 UI 구성 요소가 있는 경우와 없는 경우를 모두 포함한 [examples/realtime 디렉터리](https://github.com/openai/openai-agents-python/tree/main/examples/realtime)를 확인하세요.\n\\ No newline at end of file\n+완전한 동작 예시는 [examples/realtime 디렉터리](https://github.com/openai/openai-agents-python/tree/main/examples/realtime)를 참고하세요. UI 구성 요소가 있는 데모와 없는 데모가 모두 포함되어 있습니다.\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Frealtime%2Fguide.md",
        "sha": "786d8c4897d946b466962f5e0f49117cdc80f271",
        "status": "modified"
      },
      {
        "additions": 25,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Frealtime%2Fquickstart.md",
        "changes": 50,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fko%2Frealtime%2Fquickstart.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 25,
        "filename": "docs/ko/realtime/quickstart.md",
        "patch": "@@ -2,18 +2,18 @@\n search:\n   exclude: true\n ---\n-# 빠른 시작\n+# 퀵스타트\n \n-실시간 에이전트는 OpenAI의 Realtime API를 사용해 AI 에이전트와의 음성 대화를 가능하게 합니다. 이 가이드는 첫 실시간 음성 에이전트를 만드는 과정을 안내합니다.\n+실시간 에이전트는 OpenAI의 Realtime API를 사용해 AI 에이전트와 음성 대화를 가능하게 합니다. 이 가이드는 첫 실시간 음성 에이전트를 만드는 과정을 안내합니다.\n \n !!! warning \"베타 기능\"\n-실시간 에이전트는 베타 단계입니다. 구현을 개선하는 과정에서 호환성이 깨지는 변경이 있을 수 있습니다.\n+실시간 에이전트는 베타 단계입니다. 구현을 개선하는 과정에서 호환성 문제가 발생할 수 있습니다.\n \n-## 사전 준비 사항\n+## 사전 준비\n \n-- Python 3.9 이상\n-- OpenAI API 키\n-- OpenAI Agents SDK에 대한 기본적인 숙지\n+-   Python 3.9 이상\n+-   OpenAI API 키\n+-   OpenAI Agents SDK에 대한 기본 지식\n \n ## 설치\n \n@@ -111,7 +111,7 @@ def _truncate_str(s: str, max_length: int) -> str:\n \n ## 전체 예제\n \n-다음은 완전한 동작 예제입니다:\n+작동하는 전체 예제는 다음과 같습니다:\n \n ```python\n import asyncio\n@@ -192,40 +192,40 @@ if __name__ == \"__main__\":\n \n ### 모델 설정\n \n-- `model_name`: 사용 가능한 실시간 모델에서 선택 (예: `gpt-realtime`)\n-- `voice`: 음성 선택 (`alloy`, `echo`, `fable`, `onyx`, `nova`, `shimmer`)\n-- `modalities`: 텍스트 또는 오디오 활성화 (`[\"text\"]` 또는 `[\"audio\"]`)\n+-   `model_name`: 사용 가능한 실시간 모델에서 선택 (예: `gpt-realtime`)\n+-   `voice`: 음성 선택 (`alloy`, `echo`, `fable`, `onyx`, `nova`, `shimmer`)\n+-   `modalities`: 텍스트 또는 오디오 활성화 (`[\"text\"]` 또는 `[\"audio\"]`)\n \n ### 오디오 설정\n \n-- `input_audio_format`: 입력 오디오 형식 (`pcm16`, `g711_ulaw`, `g711_alaw`)\n-- `output_audio_format`: 출력 오디오 형식\n-- `input_audio_transcription`: 전사 구성\n+-   `input_audio_format`: 입력 오디오 형식 (`pcm16`, `g711_ulaw`, `g711_alaw`)\n+-   `output_audio_format`: 출력 오디오 형식\n+-   `input_audio_transcription`: 음성 인식 구성\n \n ### 턴 감지\n \n-- `type`: 감지 방식 (`server_vad`, `semantic_vad`)\n-- `threshold`: 음성 활동 임계값 (0.0-1.0)\n-- `silence_duration_ms`: 턴 종료를 감지할 무음 지속 시간\n-- `prefix_padding_ms`: 발화 전 오디오 패딩\n+-   `type`: 감지 방법 (`server_vad`, `semantic_vad`)\n+-   `threshold`: 음성 활동 임계값 (0.0-1.0)\n+-   `silence_duration_ms`: 턴 종료를 감지할 무음 지속시간\n+-   `prefix_padding_ms`: 발화 전 오디오 패딩\n \n ## 다음 단계\n \n-- [실시간 에이전트에 대해 더 알아보기](guide.md)\n-- [examples/realtime](https://github.com/openai/openai-agents-python/tree/main/examples/realtime) 폴더의 작동하는 code examples 확인\n-- 에이전트에 도구 추가\n-- 에이전트 간 핸드오프 구현\n-- 안전을 위한 가드레일 설정\n+-   [실시간 에이전트 더 알아보기](guide.md)\n+-   [examples/realtime](https://github.com/openai/openai-agents-python/tree/main/examples/realtime) 폴더의 동작 예시 확인\n+-   에이전트에 도구 추가\n+-   에이전트 간 핸드오프 구현\n+-   안전을 위한 가드레일 설정\n \n ## 인증\n \n-환경에 OpenAI API 키가 설정되어 있는지 확인하세요:\n+환경 변수에 OpenAI API 키가 설정되어 있는지 확인하세요:\n \n ```bash\n export OPENAI_API_KEY=\"your-api-key-here\"\n ```\n \n-또는 세션을 만들 때 직접 전달하세요:\n+또는 세션을 생성할 때 직접 전달하세요:\n \n ```python\n session = await runner.run(model_config={\"api_key\": \"your-api-key\"})",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Frealtime%2Fquickstart.md",
        "sha": "3dee450f6462a7c894c6d59394b307dacdbe40f5",
        "status": "modified"
      },
      {
        "additions": 16,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Frelease.md",
        "changes": 32,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fko%2Frelease.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 16,
        "filename": "docs/ko/release.md",
        "patch": "@@ -4,49 +4,49 @@ search:\n ---\n # 릴리스 프로세스/변경 로그\n \n-이 프로젝트는 `0.Y.Z` 형식의 약간 수정된 시맨틱 버저닝을 따릅니다. 앞의 `0`은 SDK가 아직 빠르게 발전 중임을 나타냅니다. 각 구성 요소 증분 규칙은 다음과 같습니다:\n+이 프로젝트는 `0.Y.Z` 형식의 약간 수정된 시맨틱 버전 규칙을 따릅니다. 선행 `0`은 SDK가 아직 빠르게 진화 중임을 의미합니다. 각 구성 요소는 다음과 같이 증가합니다:\n \n-## 마이너 (`Y`) 버전\n+## 마이너(`Y`) 버전\n \n-베타로 표시되지 않은 공개 인터페이스에 **브레이킹 체인지**가 있을 때 마이너 버전 `Y`를 올립니다. 예를 들어 `0.0.x`에서 `0.1.x`로 올라갈 때 브레이킹 체인지가 포함될 수 있습니다.\n+베타로 표시되지 않은 공개 인터페이스에 **호환성 깨짐 변경**이 있을 경우 마이너 버전 `Y`를 올립니다. 예를 들어, `0.0.x`에서 `0.1.x`로 올라가면 호환성 깨짐 변경이 포함될 수 있습니다.\n \n-브레이킹 체인지를 원하지 않는 경우, 프로젝트에서 `0.0.x` 버전에 고정할 것을 권장합니다.\n+호환성 깨짐 변경을 원하지 않는 경우, 프로젝트에서 `0.0.x` 버전에 고정하는 것을 권장합니다.\n \n-## 패치 (`Z`) 버전\n+## 패치(`Z`) 버전\n \n-하위 호환을 깨지 않는 변경에는 `Z`를 증가시킵니다:\n+호환성을 깨지 않는 변경에 대해 `Z`를 증가시킵니다:\n \n - 버그 수정\n-- 새로운 기능\n+- 신규 기능\n - 비공개 인터페이스 변경\n - 베타 기능 업데이트\n \n-## 브레이킹 체인지 변경 로그\n+## 호환성 깨짐 변경 로그\n \n ### 0.6.0\n \n-이 버전에서는 기본 핸드오프 기록이 원문 사용자/어시스턴트 턴을 노출하는 대신 단일 어시스턴트 메시지로 패키징되어, 다운스트림 에이전트가 간결하고 예측 가능한 요약을 받습니다\n-- 기존의 단일 메시지 핸드오프 전사는 이제 기본적으로 `<CONVERSATION HISTORY>` 블록 앞에 \"참고로, 아래는 사용자와 이전 에이전트 간의 현재까지의 대화입니다:\"로 시작하여, 다운스트림 에이전트가 명확하게 라벨된 요약을 받도록 합니다\n+이 버전에서는 기본 핸드오프 기록이 raw user/assistant 턴을 노출하는 대신 하나의 assistant 메시지로 패키징되어, 하위 에이전트에게 간결하고 예측 가능한 요약을 제공합니다\n+- 기존의 단일 메시지 핸드오프 전사는 이제 기본적으로 `<CONVERSATION HISTORY>` 블록 앞에 \"참고를 위해, 지금까지 사용자와 이전 에이전트 간의 대화는 다음과 같습니다:\"로 시작하므로, 하위 에이전트가 명확히 라벨링된 요약을 받습니다\n \n ### 0.5.0\n \n-이 버전은 눈에 띄는 브레이킹 체인지를 도입하지 않지만, 새로운 기능과 내부적으로 몇 가지 중요한 업데이트가 포함되어 있습니다:\n+이 버전은 눈에 띄는 호환성 깨짐 변경은 없습니다. 하지만 새로운 기능과 내부적으로 몇 가지 중요한 업데이트가 포함되어 있습니다:\n \n-- `RealtimeRunner`가 [SIP 프로토콜 연결](https://platform.openai.com/docs/guides/realtime-sip)을 처리하도록 지원 추가\n+- `RealtimeRunner`가 [SIP protocol connections](https://platform.openai.com/docs/guides/realtime-sip)을 처리하도록 지원 추가\n - Python 3.14 호환성을 위해 `Runner#run_sync`의 내부 로직을 대폭 수정\n \n ### 0.4.0\n \n-이 버전부터는 [openai](https://pypi.org/project/openai/) 패키지 v1.x 버전을 더 이상 지원하지 않습니다. 이 SDK와 함께 openai v2.x를 사용해 주세요.\n+이 버전에서는 [openai](https://pypi.org/project/openai/) 패키지 v1.x 버전을 더 이상 지원하지 않습니다. 이 SDK와 함께 openai v2.x를 사용해 주세요.\n \n ### 0.3.0\n \n-이 버전에서는 Realtime API 지원이 gpt-realtime 모델 및 해당 API 인터페이스(GA 버전)로 마이그레이션됩니다.\n+이 버전에서는 Realtime API 지원이 gpt-realtime 모델과 해당 API 인터페이스(GA 버전)로 마이그레이션됩니다.\n \n ### 0.2.0\n \n-이 버전에서는 이전에 `Agent`를 인자로 받던 몇몇 곳이 이제 `AgentBase`를 인자로 받습니다. 예: MCP 서버의 `list_tools()` 호출. 이는 순수한 타입 변경이며, 여전히 `Agent` 객체를 받게 됩니다. 업데이트하려면 타입 오류를 `Agent`를 `AgentBase`로 바꾸어 수정하면 됩니다.\n+이 버전에서는 이전에 `Agent`를 인자로 받던 몇몇 위치가 이제 `AgentBase`를 인자로 받습니다. 예: MCP 서버의 `list_tools()` 호출. 이는 순수하게 타입 변경이며, 여전히 `Agent` 객체를 받게 됩니다. 업데이트하려면, 타입 오류를 `Agent`를 `AgentBase`로 바꾸어 수정하면 됩니다.\n \n ### 0.1.0\n \n-이 버전에서는 [`MCPServer.list_tools()`][agents.mcp.server.MCPServer]에 `run_context`와 `agent`라는 두 개의 새로운 매개변수가 추가되었습니다. `MCPServer`를 상속하는 모든 클래스에 이 매개변수를 추가해야 합니다.\n\\ No newline at end of file\n+이 버전에서는 [`MCPServer.list_tools()`][agents.mcp.server.MCPServer]에 `run_context`와 `agent`라는 두 개의 새로운 params가 추가되었습니다. `MCPServer`를 상속하는 모든 클래스에 이 params를 추가해야 합니다.\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Frelease.md",
        "sha": "a0d42b1a060f161076a67d16d3dcad9c5fdac5f2",
        "status": "modified"
      },
      {
        "additions": 3,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Frepl.md",
        "changes": 6,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fko%2Frepl.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 3,
        "filename": "docs/ko/repl.md",
        "patch": "@@ -4,7 +4,7 @@ search:\n ---\n # REPL 유틸리티\n \n-SDK는 터미널에서 에이전트의 동작을 빠르고 대화형으로 테스트할 수 있도록 `run_demo_loop`를 제공합니다.\n+SDK는 터미널에서 에이전트의 동작을 빠르게 대화형으로 테스트할 수 있도록 `run_demo_loop`를 제공합니다.\n \n ```python\n import asyncio\n@@ -18,6 +18,6 @@ if __name__ == \"__main__\":\n     asyncio.run(main())\n ```\n \n-`run_demo_loop`는 루프에서 사용자 입력을 요구하며, 턴 사이의 대화 기록을 유지합니다. 기본적으로 생성되는 대로 모델 출력을 스트리밍합니다. 위 예시를 실행하면 run_demo_loop가 대화형 채팅 세션을 시작합니다. 계속해서 입력을 요청하고, 턴 사이의 전체 대화 기록을 기억하여(에이전트가 논의된 내용을 알 수 있도록) 생성되는 즉시 에이전트의 응답을 실시간으로 자동 스트리밍합니다.\n+`run_demo_loop`는 반복해서 사용자 입력을 요청하며, 턴 간 대화 기록을 유지합니다. 기본적으로 모델 출력을 생성되는 즉시 스트리밍합니다. 위 예제를 실행하면 run_demo_loop가 대화형 채팅 세션을 시작합니다. 계속해서 입력을 요청하고, 턴 간 전체 대화 기록을 기억하여(에이전트가 이미 논의된 내용을 알 수 있도록) 생성되는 대로 에이전트의 응답을 실시간으로 자동 스트리밍합니다.\n \n-이 채팅 세션을 종료하려면 `quit` 또는 `exit`를 입력하고 Enter 키를 누르거나 `Ctrl-D` 키보드 단축키를 사용하세요.\n\\ No newline at end of file\n+이 채팅 세션을 종료하려면 `quit` 또는 `exit`를 입력하고 Enter를 누르거나 `Ctrl-D` 키보드 단축키를 사용하세요.\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Frepl.md",
        "sha": "7431736eb782a10c9384e27ba8564894dbd5b351",
        "status": "modified"
      },
      {
        "additions": 17,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Fresults.md",
        "changes": 34,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fko%2Fresults.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 17,
        "filename": "docs/ko/results.md",
        "patch": "@@ -9,48 +9,48 @@ search:\n - [`RunResult`][agents.result.RunResult] (`run` 또는 `run_sync` 호출 시)\n - [`RunResultStreaming`][agents.result.RunResultStreaming] (`run_streamed` 호출 시)\n \n-이 둘은 모두 [`RunResultBase`][agents.result.RunResultBase]를 상속하며, 대부분의 유용한 정보가 여기에 포함됩니다.\n+둘 다 대부분의 유용한 정보가 담긴 [`RunResultBase`][agents.result.RunResultBase]를 상속합니다.\n \n ## 최종 출력\n \n-[`final_output`][agents.result.RunResultBase.final_output] 속성에는 마지막으로 실행된 에이전트의 최종 출력이 포함됩니다. 이는 다음 중 하나입니다:\n+[`final_output`][agents.result.RunResultBase.final_output] 속성에는 마지막으로 실행된 에이전트의 최종 출력이 들어 있습니다. 다음 중 하나입니다:\n \n-- 마지막 에이전트에 `output_type`이 정의되지 않은 경우 `str`\n-- 에이전트에 출력 타입이 정의된 경우 `last_agent.output_type` 타입의 객체\n+- 마지막 에이전트에 `output_type`이 정의되어 있지 않다면 `str`\n+- 에이전트에 출력 타입이 정의되어 있다면 `last_agent.output_type` 타입의 객체\n \n !!! note\n \n-    `final_output`의 타입은 `Any`입니다. 핸드오프 때문에 정적 타이핑을 할 수 없습니다. 핸드오프가 발생하면 어떤 에이전트든 마지막 에이전트가 될 수 있으므로, 가능한 출력 타입 집합을 정적으로 알 수 없습니다.\n+    `final_output`의 타입은 `Any`입니다. 핸드오프 때문에 정적으로 타입을 고정할 수 없습니다. 핸드오프가 발생하면 어느 에이전트든 마지막 에이전트가 될 수 있으므로, 가능한 출력 타입 집합을 정적으로 알 수 없습니다.\n \n-## 다음 턴을 위한 입력\n+## 다음 턴 입력\n \n-[`result.to_input_list()`][agents.result.RunResultBase.to_input_list]를 사용하면 결과를 입력 리스트로 변환하여, 원래 제공한 입력과 에이전트 실행 중 생성된 항목들을 연결할 수 있습니다. 이를 통해 한 번의 에이전트 실행 결과를 다른 실행에 쉽게 전달하거나, 루프에서 실행하며 매번 새로운 사용자 입력을 추가할 수 있습니다.\n+[`result.to_input_list()`][agents.result.RunResultBase.to_input_list]를 사용하여 결과를 입력 리스트로 변환할 수 있습니다. 이 리스트는 제공한 원래 입력과 에이전트 실행 중 생성된 항목들을 연결합니다. 이를 통해 한 번의 에이전트 실행의 출력을 다른 실행에 넘기거나, 루프로 실행하면서 매번 새로운 사용자 입력을 덧붙이기에 편리합니다.\n \n ## 마지막 에이전트\n \n-[`last_agent`][agents.result.RunResultBase.last_agent] 속성에는 마지막으로 실행된 에이전트가 포함됩니다. 애플리케이션에 따라, 이는 사용자가 다음에 무언가를 입력할 때 유용한 경우가 많습니다. 예를 들어, 1차 분류 에이전트가 언어별 에이전트로 핸드오프하는 경우, 마지막 에이전트를 저장해 두었다가 사용자가 다음에 에이전트에 메시지를 보낼 때 재사용할 수 있습니다.\n+[`last_agent`][agents.result.RunResultBase.last_agent] 속성에는 마지막으로 실행된 에이전트가 들어 있습니다. 애플리케이션에 따라, 사용자가 다음에 무언가를 입력할 때 자주 유용합니다. 예를 들어, 프런트라인 분류 에이전트가 언어별 에이전트로 핸드오프하는 경우, 마지막 에이전트를 저장해 두었다가 사용자가 다음에 에이전트에게 메시지를 보낼 때 재사용할 수 있습니다.\n \n-## 새로운 항목\n+## 새 항목\n \n-[`new_items`][agents.result.RunResultBase.new_items] 속성에는 실행 중 생성된 새로운 항목이 포함됩니다. 항목은 [`RunItem`][agents.items.RunItem]입니다. 런 아이템은 LLM이 생성한 원문 항목을 래핑합니다.\n+[`new_items`][agents.result.RunResultBase.new_items] 속성에는 실행 중 생성된 새 항목들이 들어 있습니다. 항목은 [`RunItem`][agents.items.RunItem]들입니다. 실행 항목은 LLM이 생성한 원문 항목을 래핑합니다.\n \n - [`MessageOutputItem`][agents.items.MessageOutputItem]은 LLM의 메시지를 나타냅니다. 원문 항목은 생성된 메시지입니다.\n-- [`HandoffCallItem`][agents.items.HandoffCallItem]은 LLM이 핸드오프 도구를 호출했음을 나타냅니다. 원문 항목은 LLM의 도구 호출 아이템입니다.\n-- [`HandoffOutputItem`][agents.items.HandoffOutputItem]은 핸드오프가 발생했음을 나타냅니다. 원문 항목은 핸드오프 도구 호출에 대한 도구 응답입니다. 또한 아이템에서 소스/타깃 에이전트에 접근할 수 있습니다.\n+- [`HandoffCallItem`][agents.items.HandoffCallItem]은 LLM이 핸드오프 도구를 호출했음을 나타냅니다. 원문 항목은 LLM의 도구 호출 항목입니다.\n+- [`HandoffOutputItem`][agents.items.HandoffOutputItem]은 핸드오프가 발생했음을 나타냅니다. 원문 항목은 핸드오프 도구 호출에 대한 도구 응답입니다. 항목에서 소스/타깃 에이전트에도 접근할 수 있습니다.\n - [`ToolCallItem`][agents.items.ToolCallItem]은 LLM이 도구를 호출했음을 나타냅니다.\n-- [`ToolCallOutputItem`][agents.items.ToolCallOutputItem]은 도구가 호출되었음을 나타냅니다. 원문 항목은 도구 응답입니다. 또한 아이템에서 도구 출력에 접근할 수 있습니다.\n+- [`ToolCallOutputItem`][agents.items.ToolCallOutputItem]은 도구가 호출되었음을 나타냅니다. 원문 항목은 도구 응답입니다. 항목에서 도구 출력에도 접근할 수 있습니다.\n - [`ReasoningItem`][agents.items.ReasoningItem]은 LLM의 추론 항목을 나타냅니다. 원문 항목은 생성된 추론입니다.\n \n ## 기타 정보\n \n ### 가드레일 결과\n \n-[`input_guardrail_results`][agents.result.RunResultBase.input_guardrail_results] 및 [`output_guardrail_results`][agents.result.RunResultBase.output_guardrail_results] 속성에는 (있는 경우) 가드레일의 결과가 포함됩니다. 가드레일 결과에는 기록하거나 저장하고 싶은 유용한 정보가 포함될 수 있어, 이를 확인할 수 있도록 제공합니다.\n+[`input_guardrail_results`][agents.result.RunResultBase.input_guardrail_results]와 [`output_guardrail_results`][agents.result.RunResultBase.output_guardrail_results] 속성에는 (있다면) 가드레일의 결과가 들어 있습니다. 가드레일 결과에는 로깅하거나 저장하고 싶은 유용한 정보가 포함될 수 있어, 이를 제공해 드립니다.\n \n ### 원문 응답\n \n-[`raw_responses`][agents.result.RunResultBase.raw_responses] 속성에는 LLM이 생성한 [`ModelResponse`][agents.items.ModelResponse]가 포함됩니다.\n+[`raw_responses`][agents.result.RunResultBase.raw_responses] 속성에는 LLM이 생성한 [`ModelResponse`][agents.items.ModelResponse]들이 들어 있습니다.\n \n-### 원래 입력\n+### 원본 입력\n \n-[`input`][agents.result.RunResultBase.input] 속성에는 `run` 메서드에 제공한 원래 입력이 포함됩니다. 대부분의 경우 필요하지 않지만, 필요한 경우를 대비해 제공됩니다.\n\\ No newline at end of file\n+[`input`][agents.result.RunResultBase.input] 속성에는 `run` 메서드에 제공한 원본 입력이 들어 있습니다. 대부분의 경우 필요하지 않지만, 필요한 경우를 대비해 제공됩니다.\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Fresults.md",
        "sha": "51cb5d28a3529d1af8efa8674303cf9b81cb13ac",
        "status": "modified"
      },
      {
        "additions": 49,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Frunning_agents.md",
        "changes": 99,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fko%2Frunning_agents.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 50,
        "filename": "docs/ko/running_agents.md",
        "patch": "@@ -4,11 +4,11 @@ search:\n ---\n # 에이전트 실행\n \n-[`Runner`][agents.run.Runner] 클래스를 통해 에이전트를 실행할 수 있습니다. 다음 3가지 옵션이 있습니다:\n+에이전트는 [`Runner`][agents.run.Runner] 클래스를 통해 실행할 수 있습니다. 선택지는 3가지입니다:\n \n-1. [`Runner.run()`][agents.run.Runner.run]: 비동기로 실행되며 [`RunResult`][agents.result.RunResult] 를 반환\n-2. [`Runner.run_sync()`][agents.run.Runner.run_sync]: 동기 메서드로, 내부적으로 `.run()` 을 호출\n-3. [`Runner.run_streamed()`][agents.run.Runner.run_streamed]: 비동기로 실행되며 [`RunResultStreaming`][agents.result.RunResultStreaming] 을 반환. LLM 을 스트리밍 모드로 호출하고, 수신되는 대로 이벤트를 스트리밍\n+1. [`Runner.run()`][agents.run.Runner.run]: 비동기로 실행되며 [`RunResult`][agents.result.RunResult] 를 반환합니다\n+2. [`Runner.run_sync()`][agents.run.Runner.run_sync]: 동기 메서드로, 내부적으로 `.run()` 을 실행합니다\n+3. [`Runner.run_streamed()`][agents.run.Runner.run_streamed]: 비동기로 실행되며 [`RunResultStreaming`][agents.result.RunResultStreaming] 를 반환합니다. LLM 을 스트리밍 모드로 호출하고 수신되는 대로 이벤트를 스트리밍합니다\n \n ```python\n from agents import Agent, Runner\n@@ -23,59 +23,59 @@ async def main():\n     # Infinite loop's dance\n ```\n \n-자세한 내용은 [결과 가이드](results.md)를 참고하세요.\n+자세한 내용은 [결과 가이드](results.md)에서 확인하세요.\n \n ## 에이전트 루프\n \n `Runner` 의 run 메서드를 사용할 때 시작 에이전트와 입력을 전달합니다. 입력은 문자열(사용자 메시지로 간주) 또는 OpenAI Responses API 의 입력 아이템 목록일 수 있습니다.\n \n-그런 다음 runner 는 다음 루프를 실행합니다:\n+그런 다음 러너는 다음 루프를 실행합니다:\n \n-1. 현재 에이전트와 현재 입력으로 LLM 을 호출\n-2. LLM 이 출력을 생성\n-    1. LLM 이 `final_output` 을 반환하면 루프를 종료하고 결과 반환\n-    2. LLM 이 핸드오프를 수행하면 현재 에이전트와 입력을 업데이트하고 루프 재실행\n-    3. LLM 이 도구 호출을 생성하면 해당 도구 호출을 수행하고 결과를 추가한 뒤 루프 재실행\n-3. 전달된 `max_turns` 를 초과하면 [`MaxTurnsExceeded`][agents.exceptions.MaxTurnsExceeded] 예외를 발생\n+1. 현재 에이전트와 현재 입력으로 LLM 을 호출합니다\n+2. LLM 이 출력을 생성합니다\n+    1. LLM 이 `final_output` 을 반환하면 루프가 종료되고 결과를 반환합니다\n+    2. LLM 이 핸드오프를 수행하면 현재 에이전트와 입력을 업데이트하고 루프를 다시 실행합니다\n+    3. LLM 이 도구 호출을 생성하면 해당 도구 호출을 실행하고 결과를 덧붙인 뒤 루프를 다시 실행합니다\n+3. 전달된 `max_turns` 를 초과하면 [`MaxTurnsExceeded`][agents.exceptions.MaxTurnsExceeded] 예외를 발생시킵니다\n \n !!! note\n \n     LLM 출력이 \"최종 출력\" 으로 간주되는 규칙은, 원하는 타입의 텍스트 출력을 생성하고 도구 호출이 없는 경우입니다.\n \n ## 스트리밍\n \n-스트리밍을 사용하면 LLM 이 실행되는 동안 스트리밍 이벤트를 추가로 수신할 수 있습니다. 스트림이 완료되면 [`RunResultStreaming`][agents.result.RunResultStreaming] 에는 실행에 대한 완전한 정보(생성된 모든 새 출력 포함)가 담깁니다. 스트리밍 이벤트는 `.stream_events()` 를 호출해 수신할 수 있습니다. 자세한 내용은 [스트리밍 가이드](streaming.md)를 참고하세요.\n+스트리밍을 사용하면 LLM 이 실행되는 동안 스트리밍 이벤트를 추가로 수신할 수 있습니다. 스트림이 끝나면 [`RunResultStreaming`][agents.result.RunResultStreaming] 에는 실행에 대한 완전한 정보와 새로 생성된 모든 출력이 포함됩니다. 스트리밍 이벤트는 `.stream_events()` 를 호출하세요. 자세한 내용은 [스트리밍 가이드](streaming.md)에서 확인하세요.\n \n-## 실행 설정\n+## Run config\n \n-`run_config` 매개변수를 사용하면 에이전트 실행에 대한 전역 설정을 구성할 수 있습니다:\n+`run_config` 매개변수로 에이전트 실행에 대한 전역 설정을 구성할 수 있습니다:\n \n-- [`model`][agents.run.RunConfig.model]: 각 Agent 의 `model` 설정과 무관하게 사용할 전역 LLM 모델 지정\n-- [`model_provider`][agents.run.RunConfig.model_provider]: 모델 이름 조회용 모델 제공자, 기본값은 OpenAI\n-- [`model_settings`][agents.run.RunConfig.model_settings]: 에이전트별 설정을 오버라이드. 예: 전역 `temperature` 또는 `top_p` 설정\n-- [`input_guardrails`][agents.run.RunConfig.input_guardrails], [`output_guardrails`][agents.run.RunConfig.output_guardrails]: 모든 실행에 포함할 입력/출력 가드레일 목록\n-- [`handoff_input_filter`][agents.run.RunConfig.handoff_input_filter]: 핸드오프에 전역 입력 필터 적용. 해당 핸드오프에 이미 필터가 없을 경우에만 적용됨. 입력 필터를 통해 새 에이전트로 전송되는 입력을 편집할 수 있음. 자세한 내용은 [`Handoff.input_filter`][agents.handoffs.Handoff.input_filter] 문서를 참고\n-- [`nest_handoff_history`][agents.run.RunConfig.nest_handoff_history]: `True`(기본값) 일 때 다음 에이전트를 호출하기 전 이전 대화를 단일 assistant 메시지로 축약. 도우미는 내용물을 `<CONVERSATION HISTORY>` 블록 안에 배치하며, 이후 핸드오프가 발생할 때마다 새 턴을 계속 추가. 원문 대화를 그대로 전달하려면 `False` 로 설정하거나 맞춤형 핸드오프 필터를 제공. [`Runner` 메서드](agents.run.Runner) 는 `RunConfig` 를 생략하면 자동 생성하므로, 퀵스타트와 code examples 는 기본값을 자동으로 사용하며, 명시적인 [`Handoff.input_filter`][agents.handoffs.Handoff.input_filter] 콜백은 계속 우선 적용. 개별 핸드오프는 [`Handoff.nest_handoff_history`][agents.handoffs.Handoff.nest_handoff_history] 로 이 설정을 오버라이드 가능\n-- [`handoff_history_mapper`][agents.run.RunConfig.handoff_history_mapper]: `nest_handoff_history` 가 `True` 일 때 정규화된 대화록(히스토리 + 핸드오프 아이템)을 전달받는 선택적 호출 가능 객체. 다음 에이전트로 전달할 입력 아이템 리스트를 정확히 반환해야 하며, 전체 핸드오프 필터 없이 기본 요약을 대체할 수 있음\n-- [`tracing_disabled`][agents.run.RunConfig.tracing_disabled]: 전체 실행에 대해 [트레이싱](tracing.md) 비활성화\n-- [`trace_include_sensitive_data`][agents.run.RunConfig.trace_include_sensitive_data]: LLM 및 도구 호출의 입력/출력 등 민감할 수 있는 데이터를 트레이스에 포함할지 여부 설정\n-- [`workflow_name`][agents.run.RunConfig.workflow_name], [`trace_id`][agents.run.RunConfig.trace_id], [`group_id`][agents.run.RunConfig.group_id]: 실행의 트레이싱 workflow 이름, trace ID, trace group ID 설정. 최소한 `workflow_name` 설정을 권장. group ID 는 여러 실행에 걸친 트레이스 연결에 사용할 수 있는 선택 필드\n+- [`model`][agents.run.RunConfig.model]: 각 Agent 의 `model` 과 무관하게 사용할 전역 LLM 모델을 설정\n+- [`model_provider`][agents.run.RunConfig.model_provider]: 모델 이름 조회를 위한 모델 제공자이며 기본값은 OpenAI\n+- [`model_settings`][agents.run.RunConfig.model_settings]: 에이전트별 설정을 재정의. 예를 들어 전역 `temperature` 또는 `top_p` 를 설정 가능\n+- [`input_guardrails`][agents.run.RunConfig.input_guardrails], [`output_guardrails`][agents.run.RunConfig.output_guardrails]: 모든 실행에 포함할 입력 또는 출력 가드레일 목록\n+- [`handoff_input_filter`][agents.run.RunConfig.handoff_input_filter]: 핸드오프에 이미 필터가 없다면 모든 핸드오프에 적용할 전역 입력 필터. 입력 필터를 통해 새 에이전트로 전송되는 입력을 편집할 수 있습니다. 자세한 내용은 [`Handoff.input_filter`][agents.handoffs.Handoff.input_filter] 문서를 참고하세요\n+- [`nest_handoff_history`][agents.run.RunConfig.nest_handoff_history]: `True`(기본값) 인 경우 다음 에이전트를 호출하기 전에 이전 대화 기록을 하나의 assistant 메시지로 접어 넣습니다. 도우미는 콘텐츠를 `<CONVERSATION HISTORY>` 블록 안에 배치하며, 이후 핸드오프가 발생할 때마다 새 턴을 계속 추가합니다. 원문 대화 기록을 그대로 전달하려면 이를 `False` 로 설정하거나 사용자 지정 핸드오프 필터를 제공하세요. 모든 [`Runner` methods](agents.run.Runner) 는 전달하지 않으면 자동으로 `RunConfig` 를 생성하므로, 빠른 시작과 code examples 는 이 기본값을 자동으로 사용하며, 명시적인 [`Handoff.input_filter`][agents.handoffs.Handoff.input_filter] 콜백은 계속해서 이를 재정의합니다. 개별 핸드오프는 [`Handoff.nest_handoff_history`][agents.handoffs.Handoff.nest_handoff_history] 를 통해 이 설정을 재정의할 수 있습니다\n+- [`handoff_history_mapper`][agents.run.RunConfig.handoff_history_mapper]: `nest_handoff_history` 가 `True` 일 때 정규화된 대화 기록(히스토리 + 핸드오프 아이템)을 수신하는 선택적 호출 가능 객체. 내장 요약을 완전한 핸드오프 필터 없이 교체할 수 있도록 다음 에이전트에 전달할 정확한 입력 아이템 목록을 반환해야 합니다\n+- [`tracing_disabled`][agents.run.RunConfig.tracing_disabled]: 실행 전체에 대해 [트레이싱](tracing.md) 을 비활성화\n+- [`trace_include_sensitive_data`][agents.run.RunConfig.trace_include_sensitive_data]: LLM 및 도구 호출 입출력 등 민감할 수 있는 데이터를 트레이스에 포함할지 여부를 구성\n+- [`workflow_name`][agents.run.RunConfig.workflow_name], [`trace_id`][agents.run.RunConfig.trace_id], [`group_id`][agents.run.RunConfig.group_id]: 실행에 대한 트레이싱 workflow 이름, trace ID, trace group ID 를 설정. 최소한 `workflow_name` 설정을 권장합니다. group ID 는 여러 실행에 걸쳐 트레이스를 연결할 수 있는 선택 필드입니다\n - [`trace_metadata`][agents.run.RunConfig.trace_metadata]: 모든 트레이스에 포함할 메타데이터\n \n-기본적으로 SDK 는 한 에이전트가 다른 에이전트로 핸드오프할 때 이전 턴들을 단일 assistant 요약 메시지 안에 중첩합니다. 이는 반복되는 assistant 메시지를 줄이고 전체 대화록을 새 에이전트가 빠르게 스캔할 수 있는 단일 블록 안에 유지합니다. 기존 동작으로 돌아가려면 `RunConfig(nest_handoff_history=False)` 를 전달하거나, 대화를 원하는 형태로 그대로 전달하는 `handoff_input_filter`(또는 `handoff_history_mapper`) 를 제공하세요. 특정 핸드오프에 대해서만 옵트아웃(또는 옵트인)하려면 `handoff(..., nest_handoff_history=False)` 또는 `True` 로 설정하세요. 맞춤형 매퍼 없이 생성된 요약의 래퍼 텍스트만 변경하려면 [`set_conversation_history_wrappers`][agents.handoffs.set_conversation_history_wrappers] 를 호출하세요(기본값 복원은 [`reset_conversation_history_wrappers`][agents.handoffs.reset_conversation_history_wrappers]).\n+기본적으로, SDK 는 한 에이전트가 다른 에이전트로 핸드오프할 때마다 이전 턴을 하나의 assistant 요약 메시지 안에 중첩합니다. 이는 반복되는 assistant 메시지를 줄이고 전체 대화 기록을 새 에이전트가 빠르게 스캔할 수 있는 단일 블록으로 유지합니다. 레거시 동작으로 돌아가려면 `RunConfig(nest_handoff_history=False)` 를 전달하거나, 대화를 필요한 그대로 전달하는 `handoff_input_filter`(또는 `handoff_history_mapper`) 를 제공하세요. 특정 핸드오프에 대해 옵트아웃(또는 옵트인)하려면 `handoff(..., nest_handoff_history=False)` 또는 `True` 로 설정하세요. 사용자 지정 매퍼를 작성하지 않고 생성된 요약에 사용되는 래퍼 텍스트를 변경하려면 [`set_conversation_history_wrappers`][agents.handoffs.set_conversation_history_wrappers] 를 호출하세요(기본값으로 복원하려면 [`reset_conversation_history_wrappers`][agents.handoffs.reset_conversation_history_wrappers]).\n \n ## 대화/채팅 스레드\n \n-어떤 run 메서드를 호출하더라도 하나 이상의 에이전트가 실행될 수 있으며(따라서 하나 이상의 LLM 호출), 채팅 대화에서 단일 논리적 턴을 의미합니다. 예:\n+어떤 run 메서드를 호출하든 하나 이상의 에이전트가 실행될 수 있으며(따라서 하나 이상의 LLM 호출), 이는 채팅 대화의 단일 논리적 턴을 나타냅니다. 예를 들어:\n \n 1. 사용자 턴: 사용자가 텍스트 입력\n-2. Runner 실행: 첫 번째 에이전트가 LLM 을 호출하고 도구를 실행한 뒤 두 번째 에이전트로 핸드오프, 두 번째 에이전트가 더 많은 도구를 실행한 뒤 출력을 생성\n+2. Runner 실행: 첫 번째 에이전트가 LLM 을 호출하고 도구를 실행하고 두 번째 에이전트로 핸드오프, 두 번째 에이전트가 더 많은 도구를 실행한 뒤 출력을 생성\n \n-에이전트 실행이 끝나면 사용자에게 무엇을 보여줄지 선택할 수 있습니다. 예를 들어 에이전트가 생성한 모든 새 아이템을 보여주거나 최종 출력만 보여줄 수 있습니다. 어느 쪽이든, 사용자가 후속 질문을 하면 run 메서드를 다시 호출하면 됩니다.\n+에이전트 실행이 끝나면 사용자에게 무엇을 보여줄지 선택할 수 있습니다. 예를 들어, 에이전트가 생성한 모든 새 아이템을 보여주거나 최종 출력만 보여줄 수 있습니다. 어느 쪽이든, 사용자가 후속 질문을 할 수 있으며 이 경우 run 메서드를 다시 호출할 수 있습니다.\n \n ### 수동 대화 관리\n \n-다음 턴의 입력을 얻기 위해 [`RunResultBase.to_input_list()`][agents.result.RunResultBase.to_input_list] 메서드를 사용해 대화 기록을 수동으로 관리할 수 있습니다:\n+다음 턴의 입력을 얻기 위해 [`RunResultBase.to_input_list()`][agents.result.RunResultBase.to_input_list] 메서드를 사용하여 대화 기록을 수동으로 관리할 수 있습니다:\n \n ```python\n async def main():\n@@ -95,9 +95,9 @@ async def main():\n         # California\n ```\n \n-### Sessions 로 자동 대화 관리\n+### Sessions 를 활용한 자동 대화 관리\n \n-더 간단한 방법으로, [Sessions](sessions/index.md) 를 사용하면 `.to_input_list()` 를 수동으로 호출하지 않고도 대화 기록을 자동으로 처리할 수 있습니다:\n+더 간단한 접근을 원한다면, [Sessions](sessions/index.md) 를 사용하여 `.to_input_list()` 를 수동으로 호출하지 않고도 대화 기록을 자동으로 처리할 수 있습니다:\n \n ```python\n from agents import Agent, Runner, SQLiteSession\n@@ -121,24 +121,23 @@ async def main():\n         # California\n ```\n \n-Sessions 는 다음을 자동으로 수행합니다:\n+Sessions 는 자동으로 다음을 수행합니다:\n \n-- 각 실행 전 대화 기록 조회\n+- 각 실행 전에 대화 기록 검색\n - 각 실행 후 새 메시지 저장\n-- 서로 다른 세션 ID 별로 대화를 분리 관리\n+- 서로 다른 세션 ID 에 대해 별도 대화 유지\n \n-자세한 내용은 [Sessions 문서](sessions/index.md) 를 참고하세요.\n+자세한 내용은 [Sessions 문서](sessions/index.md)에서 확인하세요.\n \n+### 서버 관리형 대화\n \n-### 서버 관리 대화\n-\n-OpenAI 의 대화 상태 기능을 사용해 `to_input_list()` 또는 `Sessions` 로 로컬에서 처리하는 대신 서버 측에서 대화 상태를 관리할 수도 있습니다. 이를 통해 과거 메시지를 모두 수동으로 다시 보내지 않고도 대화 기록을 보존할 수 있습니다. 자세한 내용은 [OpenAI Conversation state 가이드](https://platform.openai.com/docs/guides/conversation-state?api-mode=responses) 를 참고하세요.\n+로컬에서 `to_input_list()` 또는 `Sessions` 로 처리하는 대신, OpenAI 대화 상태 기능이 서버 측에서 대화 상태를 관리하도록 할 수도 있습니다. 이렇게 하면 과거 메시지를 모두 수동으로 재전송하지 않고도 대화 기록을 보존할 수 있습니다. 자세한 내용은 [OpenAI Conversation state 가이드](https://platform.openai.com/docs/guides/conversation-state?api-mode=responses)에서 확인하세요.\n \n OpenAI 는 턴 간 상태를 추적하는 두 가지 방법을 제공합니다:\n \n #### 1. `conversation_id` 사용\n \n-먼저 OpenAI Conversations API 로 대화를 생성하고, 이후 모든 호출에서 해당 ID 를 재사용합니다:\n+먼저 OpenAI Conversations API 를 사용해 대화를 생성한 뒤, 이후 모든 호출에서 해당 ID 를 재사용합니다:\n \n ```python\n from agents import Agent, Runner\n@@ -161,7 +160,7 @@ async def main():\n \n #### 2. `previous_response_id` 사용\n \n-또 다른 옵션은 **response chaining** 으로, 각 턴이 이전 턴의 response ID 와 명시적으로 연결됩니다.\n+또 다른 옵션은 각 턴이 이전 턴의 response ID 에 명시적으로 연결되는 **응답 체이닝(response chaining)** 입니다.\n \n ```python\n from agents import Agent, Runner\n@@ -186,18 +185,18 @@ async def main():\n         print(f\"Assistant: {result.final_output}\")\n ```\n \n-## 장시간 실행 에이전트 & 휴먼인더루프\n+## 장시간 실행 에이전트 및 휴먼인더루프 (HITL)\n \n-Agents SDK 의 [Temporal](https://temporal.io/) 통합을 사용하면, 휴먼인더루프(HITL) 작업을 포함해 내구성 있는 장시간 실행 워크플로를 운영할 수 있습니다. 장시간 작업을 완료하기 위해 Temporal 과 Agents SDK 가 함께 동작하는 데모는 [이 비디오](https://www.youtube.com/watch?v=fFBZqzT4DD8) 에서 확인하고, [여기 문서](https://github.com/temporalio/sdk-python/tree/main/temporalio/contrib/openai_agents) 를 참고하세요.\n+Agents SDK 의 [Temporal](https://temporal.io/) 통합을 사용하여 내구성 있는 장시간 워크플로우(휴먼인더루프 작업 포함)를 실행할 수 있습니다. 장시간 작업을 완료하기 위해 Temporal 과 Agents SDK 가 함께 동작하는 데모는 [이 영상](https://www.youtube.com/watch?v=fFBZqzT4DD8)에서 확인하고, [여기 문서](https://github.com/temporalio/sdk-python/tree/main/temporalio/contrib/openai_agents)를 참고하세요.\n \n ## 예외\n \n SDK 는 특정 경우 예외를 발생시킵니다. 전체 목록은 [`agents.exceptions`][] 에 있습니다. 개요는 다음과 같습니다:\n \n-- [`AgentsException`][agents.exceptions.AgentsException]: SDK 내에서 발생하는 모든 예외의 기본 클래스. 다른 모든 구체적 예외의 상위 일반 타입으로 사용\n-- [`MaxTurnsExceeded`][agents.exceptions.MaxTurnsExceeded]: `Runner.run`, `Runner.run_sync`, `Runner.run_streamed` 메서드에 전달한 `max_turns` 한도를 에이전트 실행이 초과했을 때 발생. 지정된 상호작용 턴 수 내에 작업을 완료하지 못했음을 의미\n-- [`ModelBehaviorError`][agents.exceptions.ModelBehaviorError]: 기반 모델(LLM) 이 예상치 못한 또는 유효하지 않은 출력을 생성했을 때 발생. 예를 들면:\n-    - 잘못된 JSON: 도구 호출용 또는 직접 출력에 대해 손상된 JSON 구조를 제공하는 경우, 특히 특정 `output_type` 이 정의된 경우\n-    - 예기치 않은 도구 관련 실패: 모델이 예상 방식으로 도구를 사용하지 못한 경우\n-- [`UserError`][agents.exceptions.UserError]: SDK 를 사용하는 코드 작성자(사용자)가 SDK 사용 중 오류를 저질렀을 때 발생. 보통 잘못된 코드 구현, 잘못된 구성, SDK API 오사용으로 인해 발생\n-- [`InputGuardrailTripwireTriggered`][agents.exceptions.InputGuardrailTripwireTriggered], [`OutputGuardrailTripwireTriggered`][agents.exceptions.OutputGuardrailTripwireTriggered]: 각각 입력 가드레일 또는 출력 가드레일의 조건이 충족되었을 때 발생. 입력 가드레일은 처리 전에 수신 메시지를 검사하고, 출력 가드레일은 에이전트의 최종 응답을 전달 전에 검사\n\\ No newline at end of file\n+- [`AgentsException`][agents.exceptions.AgentsException]: SDK 내에서 발생하는 모든 예외의 기본 클래스입니다. 다른 모든 구체적 예외의 상위 일반 타입입니다\n+- [`MaxTurnsExceeded`][agents.exceptions.MaxTurnsExceeded]: 에이전트 실행이 `Runner.run`, `Runner.run_sync`, `Runner.run_streamed` 메서드에 전달된 `max_turns` 제한을 초과했을 때 발생합니다. 지정된 상호작용 턴 수 내에 에이전트가 작업을 완료하지 못했음을 의미합니다\n+- [`ModelBehaviorError`][agents.exceptions.ModelBehaviorError]: 기본 모델(LLM) 이 예기치 않거나 유효하지 않은 출력을 생성할 때 발생합니다. 다음을 포함할 수 있습니다:\n+    - 잘못된 JSON: 특히 특정 `output_type` 이 정의된 경우, 도구 호출 또는 직접 출력에서 모델이 잘못된 JSON 구조를 제공하는 경우\n+    - 예기치 않은 도구 관련 실패: 모델이 예상된 방식으로 도구를 사용하지 못한 경우\n+- [`UserError`][agents.exceptions.UserError]: SDK 를 사용하는 코드 작성자(사용자) 측의 오류가 발생했을 때 발생합니다. 잘못된 코드 구현, 유효하지 않은 구성, SDK API 오용 등에서 비롯됩니다\n+- [`InputGuardrailTripwireTriggered`][agents.exceptions.InputGuardrailTripwireTriggered], [`OutputGuardrailTripwireTriggered`][agents.exceptions.OutputGuardrailTripwireTriggered]: 각각 입력 가드레일 또는 출력 가드레일의 조건이 충족되었을 때 발생합니다. 입력 가드레일은 처리 전에 들어오는 메시지를 검사하고, 출력 가드레일은 전달 전에 에이전트의 최종 응답을 검사합니다\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Frunning_agents.md",
        "sha": "1f484fae0266014d366fb6bf9a9c0c193c80f9e9",
        "status": "modified"
      },
      {
        "additions": 20,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Fsessions%2Fadvanced_sqlite_session.md",
        "changes": 39,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fko%2Fsessions%2Fadvanced_sqlite_session.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 19,
        "filename": "docs/ko/sessions/advanced_sqlite_session.md",
        "patch": "@@ -4,14 +4,14 @@ search:\n ---\n # 고급 SQLite 세션\n \n-`AdvancedSQLiteSession`은 기본 `SQLiteSession`을 확장한 버전으로, 대화 분기, 상세 사용 분석, 구조화된 대화 쿼리 등 고급 대화 관리 기능을 제공합니다.\n+`AdvancedSQLiteSession` 은 기본 `SQLiteSession` 을 확장한 버전으로, 대화 분기, 상세 사용량 분석, 구조화된 대화 쿼리 등 고급 대화 관리 기능을 제공합니다.\n \n ## 기능\n \n - **대화 분기**: 임의의 사용자 메시지에서 대체 대화 경로 생성\n-- **사용량 추적**: 전체 JSON 내역과 함께 턴별 토큰 사용량 상세 분석\n-- **구조화된 쿼리**: 턴 단위 대화 조회, 도구 사용 통계 등\n-- **브랜치 관리**: 독립적인 브랜치 전환 및 관리\n+- **사용량 추적**: 전체 JSON 분해와 함께 턴별 토큰 사용량 상세 분석\n+- **구조화된 쿼리**: 턴 단위 대화 조회, 도구 사용 통계 등 다양한 조회\n+- **분기 관리**: 독립적인 분기 전환 및 관리\n - **메시지 구조 메타데이터**: 메시지 유형, 도구 사용, 대화 흐름 추적\n \n ## 빠른 시작\n@@ -85,15 +85,15 @@ session = AdvancedSQLiteSession(\n ### 매개변수\n \n - `session_id` (str): 대화 세션의 고유 식별자\n-- `db_path` (str | Path): SQLite 데이터베이스 파일 경로. 인메모리 저장의 경우 기본값은 `:memory:`\n+- `db_path` (str | Path): SQLite 데이터베이스 파일 경로. 메모리 저장을 위해 기본값은 `:memory:`\n - `create_tables` (bool): 고급 테이블을 자동 생성할지 여부. 기본값은 `False`\n - `logger` (logging.Logger | None): 세션에 사용할 커스텀 로거. 기본값은 모듈 로거\n \n ## 사용량 추적\n \n-AdvancedSQLiteSession은 대화 턴마다 토큰 사용 데이터를 저장하여 상세 사용 분석을 제공합니다. **이는 각 에이전트 실행 후 `store_run_usage` 메서드가 호출되는 것에 전적으로 의존합니다.**\n+AdvancedSQLiteSession 은 대화 턴마다 토큰 사용 데이터를 저장하여 상세 사용량 분석을 제공합니다. **이는 각 에이전트 실행 이후 `store_run_usage` 메서드를 호출하는 것에 전적으로 의존합니다.**\n \n-### 사용 데이터 저장\n+### 사용량 데이터 저장\n \n ```python\n # After each agent run, store the usage data\n@@ -107,7 +107,7 @@ await session.store_run_usage(result)\n # - Detailed JSON token information (if available)\n ```\n \n-### 사용 통계 조회\n+### 사용량 통계 조회\n \n ```python\n # Get session-level usage (all branches)\n@@ -137,9 +137,9 @@ turn_2_usage = await session.get_turn_usage(user_turn_number=2)\n \n ## 대화 분기\n \n-AdvancedSQLiteSession의 핵심 기능 중 하나는 임의의 사용자 메시지에서 대화 브랜치를 생성하여 대체 대화 경로를 탐색할 수 있는 기능입니다.\n+AdvancedSQLiteSession 의 핵심 기능 중 하나는 임의의 사용자 메시지에서 대화 분기를 생성하여 대체 대화 경로를 탐색할 수 있는 능력입니다.\n \n-### 브랜치 생성\n+### 분기 생성\n \n ```python\n # Get available turns for branching\n@@ -165,7 +165,7 @@ branch_id = await session.create_branch_from_content(\n )\n ```\n \n-### 브랜치 관리\n+### 분기 관리\n \n ```python\n # List all branches\n@@ -182,7 +182,7 @@ await session.switch_to_branch(branch_id)\n await session.delete_branch(branch_id, force=True)  # force=True allows deleting current branch\n ```\n \n-### 브랜치 워크플로 예시\n+### 분기 워크플로 예시\n \n ```python\n # Original conversation\n@@ -217,7 +217,7 @@ await session.store_run_usage(result)\n \n ## 구조화된 쿼리\n \n-AdvancedSQLiteSession은 대화 구조와 내용을 분석하기 위한 여러 메서드를 제공합니다.\n+AdvancedSQLiteSession 은 대화의 구조와 내용을 분석하기 위한 여러 메서드를 제공합니다.\n \n ### 대화 분석\n \n@@ -247,15 +247,15 @@ for turn in matching_turns:\n \n 세션은 다음을 포함한 메시지 구조를 자동으로 추적합니다:\n \n-- 메시지 유형(user, assistant, tool_call 등)\n+- 메시지 유형 (user, assistant, tool_call 등)\n - 도구 호출의 도구 이름\n - 턴 번호와 시퀀스 번호\n-- 브랜치 연관 관계\n+- 분기 연관\n - 타임스탬프\n \n ## 데이터베이스 스키마\n \n-AdvancedSQLiteSession은 기본 SQLite 스키마를 두 개의 추가 테이블로 확장합니다:\n+AdvancedSQLiteSession 은 기본 SQLite 스키마를 확장하여 두 개의 추가 테이블을 포함합니다:\n \n ### message_structure 테이블\n \n@@ -298,9 +298,10 @@ CREATE TABLE turn_usage (\n \n ## 전체 예제\n \n-모든 기능을 종합적으로 시연하는 [완전한 예제](https://github.com/openai/openai-agents-python/tree/main/examples/memory/advanced_sqlite_session_example.py)를 확인하세요.\n+모든 기능을 종합적으로 보여주는 [전체 예제](https://github.com/openai/openai-agents-python/tree/main/examples/memory/advanced_sqlite_session_example.py)를 확인하세요.\n \n-## API 레퍼런스\n \n-- [`AdvancedSQLiteSession`][agents.extensions.memory.advanced_sqlite_session.AdvancedSQLiteSession] - 메인 클래스\n+## API Reference\n+\n+- [`AdvancedSQLiteSession`][agents.extensions.memory.advanced_sqlite_session.AdvancedSQLiteSession] - 주 클래스\n - [`Session`][agents.memory.session.Session] - 기본 세션 프로토콜\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Fsessions%2Fadvanced_sqlite_session.md",
        "sha": "622eef12be2b919963986a7580f497dd45d09f83",
        "status": "modified"
      },
      {
        "additions": 21,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Fsessions%2Fencrypted_session.md",
        "changes": 42,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fko%2Fsessions%2Fencrypted_session.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 21,
        "filename": "docs/ko/sessions/encrypted_session.md",
        "patch": "@@ -4,14 +4,14 @@ search:\n ---\n # 암호화된 세션\n \n-`EncryptedSession`은 모든 세션 구현에 대해 투명한 암호화를 제공하며, 대화 데이터를 보호하고 오래된 항목을 자동으로 만료합니다.\n+`EncryptedSession`은 모든 세션 구현에 투명한 암호화를 제공하며, 대화 데이터를 보호하고 오래된 항목을 자동으로 만료 처리합니다.\n \n-## 특징\n+## 기능\n \n-- **투명한 암호화**: 어떤 세션이든 Fernet 암호화로 래핑\n-- **세션별 키**: 세션마다 고유한 암호화를 위해 HKDF 키 파생 사용\n-- **자동 만료**: TTL 만료 시 오래된 항목을 조용히 건너뜀\n-- **손쉬운 대체**: 기존 세션 구현과 함께 동작\n+- **투명한 암호화**: 모든 세션을 Fernet 암호화로 감쌉니다\n+- **세션별 키**: HKDF 키 유도 방식으로 세션마다 고유한 암호화 적용\n+- **자동 만료**: TTL이 만료된 오래된 항목은 조용히 건너뜁니다\n+- **대체 가능**: 기존 세션 구현과 함께 바로 동작\n \n ## 설치\n \n@@ -57,7 +57,7 @@ if __name__ == \"__main__\":\n \n ### 암호화 키\n \n-암호화 키는 Fernet 키 또는 아무 문자열이나 사용할 수 있습니다:\n+암호화 키는 Fernet 키이거나 임의의 문자열일 수 있습니다:\n \n ```python\n from agents.extensions.memory import EncryptedSession\n@@ -81,7 +81,7 @@ session = EncryptedSession(\n \n ### TTL (Time To Live)\n \n-암호화된 항목이 유효하게 유지되는 시간을 설정합니다:\n+암호화된 항목이 유효하게 유지될 시간을 설정합니다:\n \n ```python\n # Items expire after 1 hour\n@@ -101,7 +101,7 @@ session = EncryptedSession(\n )\n ```\n \n-## 세션 유형별 사용 방법\n+## 다양한 세션 유형과의 사용\n \n ### SQLite 세션과 함께 사용\n \n@@ -142,28 +142,28 @@ session = EncryptedSession(\n \n     `EncryptedSession`을 `AdvancedSQLiteSession`과 같은 고급 세션 구현과 함께 사용할 때는 다음을 유의하세요:\n \n-    - 메시지 내용이 암호화되기 때문에 `find_turns_by_content()` 같은 메서드는 효과적으로 동작하지 않음\n-    - 콘텐츠 기반 검색은 암호화된 데이터에서 동작하므로 효과가 제한됨\n+    - 메시지 내용이 암호화되므로 `find_turns_by_content()` 같은 메서드는 효과적으로 동작하지 않습니다\n+    - 내용 기반 검색은 암호화된 데이터에 대해 수행되므로 효율이 제한됩니다\n \n \n \n-## 키 파생\n+## 키 유도\n \n-EncryptedSession은 세션마다 고유한 암호화 키를 파생하기 위해 HKDF(HMAC 기반 키 파생 함수)를 사용합니다:\n+EncryptedSession은 세션마다 고유한 암호화 키를 유도하기 위해 HKDF(HMAC 기반 키 유도 함수)를 사용합니다:\n \n-- **마스터 키**: 제공한 암호화 키\n+- **마스터 키**: 사용자가 제공한 암호화 키\n - **세션 솔트**: 세션 ID\n-- **정보 문자열**: `\"agents.session-store.hkdf.v1\"`\n+- **Info 문자열**: `\"agents.session-store.hkdf.v1\"`\n - **출력**: 32바이트 Fernet 키\n \n 이는 다음을 보장합니다:\n-- 각 세션은 고유한 암호화 키를 가짐\n-- 마스터 키 없이는 키를 파생할 수 없음\n-- 서로 다른 세션 간에는 세션 데이터를 복호화할 수 없음\n+- 각 세션은 고유한 암호화 키를 가집니다\n+- 마스터 키 없이는 키를 유도할 수 없습니다\n+- 서로 다른 세션 간에는 세션 데이터를 복호화할 수 없습니다\n \n ## 자동 만료\n \n-항목이 TTL을 초과하면 검색 중 자동으로 건너뜁니다:\n+항목이 TTL을 초과하면, 조회 시 자동으로 건너뜁니다:\n \n ```python\n # Items older than TTL are silently ignored\n@@ -173,7 +173,7 @@ items = await session.get_items()  # Only returns non-expired items\n result = await Runner.run(agent, \"Continue conversation\", session=session)\n ```\n \n-## API 참조\n+## API 레퍼런스\n \n-- [`EncryptedSession`][agents.extensions.memory.encrypt_session.EncryptedSession] - 기본 클래스\n+- [`EncryptedSession`][agents.extensions.memory.encrypt_session.EncryptedSession] - 메인 클래스\n - [`Session`][agents.memory.session.Session] - 기본 세션 프로토콜\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Fsessions%2Fencrypted_session.md",
        "sha": "d70454363957e2b80f754c7d2e4b9fc594cd0ad3",
        "status": "modified"
      },
      {
        "additions": 38,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Fsessions%2Findex.md",
        "changes": 77,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fko%2Fsessions%2Findex.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 39,
        "filename": "docs/ko/sessions/index.md",
        "patch": "@@ -4,9 +4,9 @@ search:\n ---\n # 세션\n \n-Agents SDK는 여러 에이전트 실행(run)에 걸쳐 대화 기록을 자동으로 유지하는 기본 세션 메모리를 제공하여, 턴 사이에 `.to_input_list()`를 수동으로 처리할 필요를 없애줍니다.\n+Agents SDK 는 여러 에이전트 실행 간에 대화 기록을 자동으로 유지하는 기본 세션 메모리를 제공하여, 턴 간에 `.to_input_list()` 를 수동으로 처리할 필요를 없앱니다.\n \n-세션은 특정 세션에 대한 대화 기록을 저장하여, 에이전트가 명시적인 수동 메모리 관리 없이도 컨텍스트를 유지할 수 있도록 합니다. 이는 에이전트가 이전 상호작용을 기억하기를 원하는 채팅 애플리케이션이나 멀티 턴 대화에서 특히 유용합니다.\n+세션은 특정 세션에 대한 대화 기록을 저장하여, 에이전트가 명시적인 수동 메모리 관리 없이도 컨텍스트를 유지할 수 있도록 합니다. 이는 에이전트가 이전 상호작용을 기억해야 하는 채팅 애플리케이션이나 멀티 턴 대화를 구축할 때 특히 유용합니다.\n \n ## 빠른 시작\n \n@@ -52,10 +52,10 @@ print(result.final_output)  # \"Approximately 39 million\"\n 세션 메모리가 활성화되면:\n \n 1. **각 실행 전**: 러너가 세션의 대화 기록을 자동으로 가져와 입력 항목 앞에 추가합니다\n-2. **각 실행 후**: 실행 중 생성된 모든 새 항목(사용자 입력, 어시스턴트 응답, 도구 호출 등)이 자동으로 세션에 저장됩니다\n-3. **컨텍스트 보존**: 동일한 세션으로 이어지는 각 후속 실행에는 전체 대화 기록이 포함되어 에이전트가 컨텍스트를 유지할 수 있습니다\n+2. **각 실행 후**: 실행 중 생성된 모든 새 항목(사용자 입력, 어시스턴트 응답, 도구 호출 등)이 세션에 자동으로 저장됩니다\n+3. **컨텍스트 보존**: 동일한 세션으로 이후 실행을 수행하면 전체 대화 기록이 포함되어 에이전트가 컨텍스트를 유지할 수 있습니다\n \n-이로써 `.to_input_list()`를 수동으로 호출하고 실행 간 대화 상태를 관리할 필요가 없어집니다.\n+이를 통해 `.to_input_list()` 를 수동으로 호출하고 실행 간 대화 상태를 관리할 필요가 없습니다.\n \n ## 메모리 작업\n \n@@ -86,9 +86,9 @@ print(last_item)  # {\"role\": \"assistant\", \"content\": \"Hi there!\"}\n await session.clear_session()\n ```\n \n-### 수정을 위한 pop_item 사용\n+### 수정용 pop_item 사용\n \n-`pop_item` 메서드는 대화에서 마지막 항목을 취소하거나 수정하고자 할 때 특히 유용합니다:\n+`pop_item` 메서드는 대화에서 마지막 항목을 되돌리거나 수정하고자 할 때 특히 유용합니다:\n \n ```python\n from agents import Agent, Runner, SQLiteSession\n@@ -119,11 +119,11 @@ print(f\"Agent: {result.final_output}\")\n \n ## 세션 유형\n \n-SDK는 다양한 사용 사례를 위한 여러 세션 구현을 제공합니다:\n+SDK 는 다양한 사용 사례를 위한 여러 세션 구현을 제공합니다:\n \n ### OpenAI Conversations API 세션\n \n-`OpenAIConversationsSession`을 통해 [OpenAI's Conversations API](https://platform.openai.com/docs/api-reference/conversations)를 사용하세요.\n+`OpenAIConversationsSession` 을 통해 [OpenAI's Conversations API](https://platform.openai.com/docs/api-reference/conversations) 를 사용하세요.\n \n ```python\n from agents import Agent, Runner, OpenAIConversationsSession\n@@ -159,7 +159,7 @@ print(result.final_output)  # \"California\"\n \n ### SQLite 세션\n \n-기본이며 가벼운 SQLite 기반 세션 구현:\n+기본이자 가벼운 SQLite 기반 세션 구현:\n \n ```python\n from agents import SQLiteSession\n@@ -180,7 +180,7 @@ result = await Runner.run(\n \n ### SQLAlchemy 세션\n \n-SQLAlchemy가 지원하는 모든 데이터베이스를 사용하는 프로덕션 준비 세션:\n+SQLAlchemy 가 지원하는 모든 데이터베이스를 사용하는 프로덕션 준비 완료 세션:\n \n ```python\n from agents.extensions.memory import SQLAlchemySession\n@@ -198,13 +198,13 @@ engine = create_async_engine(\"postgresql+asyncpg://user:pass@localhost/db\")\n session = SQLAlchemySession(\"user_123\", engine=engine, create_tables=True)\n ```\n \n-자세한 문서는 [SQLAlchemy 세션](sqlalchemy_session.md)을 참조하세요.\n+자세한 문서는 [SQLAlchemy Sessions](sqlalchemy_session.md) 를 참조하세요.\n \n \n \n ### 고급 SQLite 세션\n \n-대화 브랜칭, 사용량 분석, 구조화된 쿼리를 제공하는 향상된 SQLite 세션:\n+대화 분기, 사용량 분석, 구조화된 쿼리를 지원하는 향상된 SQLite 세션:\n \n ```python\n from agents.extensions.memory import AdvancedSQLiteSession\n@@ -224,11 +224,11 @@ await session.store_run_usage(result)  # Track token usage\n await session.create_branch_from_turn(2)  # Branch from turn 2\n ```\n \n-자세한 문서는 [Advanced SQLite Sessions](advanced_sqlite_session.md)을 참조하세요.\n+자세한 문서는 [Advanced SQLite Sessions](advanced_sqlite_session.md) 를 참조하세요.\n \n-### 암호화된 세션\n+### 암호화 세션\n \n-모든 세션 구현을 위한 투명한 암호화 래퍼:\n+모든 세션 구현에 적용 가능한 투명한 암호화 래퍼:\n \n ```python\n from agents.extensions.memory import EncryptedSession, SQLAlchemySession\n@@ -251,32 +251,31 @@ session = EncryptedSession(\n result = await Runner.run(agent, \"Hello\", session=session)\n ```\n \n-자세한 문서는 [Encrypted Sessions](encrypted_session.md)을 참조하세요.\n+자세한 문서는 [Encrypted Sessions](encrypted_session.md) 를 참조하세요.\n \n ### 기타 세션 유형\n \n-몇 가지 추가 내장 옵션이 있습니다. `examples/memory/` 및 `extensions/memory/` 아래의 소스 코드를 참고하세요.\n+몇 가지 추가 내장 옵션이 있습니다. `examples/memory/` 와 `extensions/memory/` 아래 소스 코드를 참고하세요.\n \n ## 세션 관리\n \n ### 세션 ID 명명\n \n-대화를 체계적으로 정리하는 데 도움이 되는 의미 있는 세션 ID를 사용하세요:\n+대화를 체계적으로 구성할 수 있도록 의미 있는 세션 ID 를 사용하세요:\n \n-- 사용자 기반: `\"user_12345\"`\n-- 스레드 기반: `\"thread_abc123\"`\n-- 컨텍스트 기반: `\"support_ticket_456\"`\n+- User-based: `\"user_12345\"`\n+- Thread-based: `\"thread_abc123\"`\n+- Context-based: `\"support_ticket_456\"`\n \n-### 메모리 지속성\n+### 메모리 영속성\n \n-- 임시 대화에는 인메모리 SQLite(`SQLiteSession(\"session_id\")`) 사용\n-- 지속형 대화에는 파일 기반 SQLite(`SQLiteSession(\"session_id\", \"path/to/db.sqlite\")`) 사용\n-- SQLAlchemy가 지원하는 기존 데이터베이스를 사용하는 프로덕션 시스템에는 SQLAlchemy 기반 세션(`SQLAlchemySession(\"session_id\", engine=engine, create_tables=True)`) 사용\n-- 클라우드 네이티브 프로덕션 배포에는 Dapr 상태 저장소 세션(`DaprSession.from_address(\"session_id\", state_store_name=\"statestore\", dapr_address=\"localhost:50001\")`) 사용. 지원:\n-30+ 데이터베이스 백엔드, 내장 텔레메트리, 트레이싱, 데이터 격리\n-- 기록을 OpenAI Conversations API에 저장하기를 원할 때는 OpenAI가 호스팅하는 스토리지(`OpenAIConversationsSession()`) 사용\n-- 투명한 암호화 및 TTL 기반 만료와 함께 모든 세션을 래핑하려면 암호화된 세션(`EncryptedSession(session_id, underlying_session, encryption_key)`) 사용\n-- 더 고급 사용 사례를 위해 기타 프로덕션 시스템(Redis, Django 등)에 대한 커스텀 세션 백엔드를 구현하는 방안 고려\n+- 인메모리 SQLite(`SQLiteSession(\"session_id\")`) 를 사용하여 임시 대화를 처리\n+- 파일 기반 SQLite(`SQLiteSession(\"session_id\", \"path/to/db.sqlite\")`) 를 사용하여 영구 대화를 처리\n+- SQLAlchemy 지원 데이터베이스를 사용하는 프로덕션 시스템에는 SQLAlchemy 기반 세션(`SQLAlchemySession(\"session_id\", engine=engine, create_tables=True)`) 사용\n+- 클라우드 네이티브 프로덕션 배포에는 Dapr 상태 저장소 세션(`DaprSession.from_address(\"session_id\", state_store_name=\"statestore\", dapr_address=\"localhost:50001\")`) 사용 — 기본 제공 텔레메트리, 트레이싱, 데이터 격리를 포함한 30+ 데이터베이스 백엔드 지원\n+- 기록을 OpenAI Conversations API 에 저장하고자 할 때는 OpenAI 가 호스팅하는 스토리지(`OpenAIConversationsSession()`) 사용\n+- 투명한 암호화 및 TTL 기반 만료를 위해 암호화 세션(`EncryptedSession(session_id, underlying_session, encryption_key)`)으로 모든 세션을 래핑\n+- 더 고급 사용 사례를 위해 다른 프로덕션 시스템(Redis, Django 등)에 대한 사용자 지정 세션 백엔드를 구현하는 것을 고려\n \n ### 다중 세션\n \n@@ -322,9 +321,9 @@ result2 = await Runner.run(\n )\n ```\n \n-## 전체 예제\n+## 전체 예시\n \n-다음은 세션 메모리가 실제로 동작하는 전체 예제입니다:\n+다음은 세션 메모리가 실제로 동작하는 완전한 예시입니다:\n \n ```python\n import asyncio\n@@ -433,15 +432,15 @@ result = await Runner.run(\n \n ## 커뮤니티 세션 구현\n \n-커뮤니티에서는 추가 세션 구현을 개발했습니다:\n+커뮤니티에서 추가 세션 구현을 개발했습니다:\n \n-| 패키지 | 설명 |\n+| Package | Description |\n |---------|-------------|\n-| [openai-django-sessions](https://pypi.org/project/openai-django-sessions/) | Django가 지원하는 모든 데이터베이스(PostgreSQL, MySQL, SQLite 등)를 위한 Django ORM 기반 세션 |\n+| [openai-django-sessions](https://pypi.org/project/openai-django-sessions/) | Django 가 지원하는 모든 데이터베이스(PostgreSQL, MySQL, SQLite 등)를 위한 Django ORM 기반 세션 |\n \n-세션 구현을 제작하셨다면, 여기 추가될 수 있도록 문서 PR을 자유롭게 제출해 주세요!\n+세션 구현을 개발하셨다면, 이곳에 추가할 수 있도록 문서 PR 을 자유롭게 제출해 주세요!\n \n-## API 참조\n+## API 레퍼런스\n \n 자세한 API 문서는 다음을 참조하세요:\n \n@@ -450,5 +449,5 @@ result = await Runner.run(\n - [`SQLiteSession`][agents.memory.sqlite_session.SQLiteSession] - 기본 SQLite 구현\n - [`SQLAlchemySession`][agents.extensions.memory.sqlalchemy_session.SQLAlchemySession] - SQLAlchemy 기반 구현\n - [`DaprSession`][agents.extensions.memory.dapr_session.DaprSession] - Dapr 상태 저장소 구현\n-- [`AdvancedSQLiteSession`][agents.extensions.memory.advanced_sqlite_session.AdvancedSQLiteSession] - 브랜칭과 분석 기능을 갖춘 향상된 SQLite\n+- [`AdvancedSQLiteSession`][agents.extensions.memory.advanced_sqlite_session.AdvancedSQLiteSession] - 분기 및 분석을 지원하는 향상된 SQLite\n - [`EncryptedSession`][agents.extensions.memory.encrypt_session.EncryptedSession] - 모든 세션을 위한 암호화 래퍼\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Fsessions%2Findex.md",
        "sha": "3e005f71f501735714163f97080176ae3c246556",
        "status": "modified"
      },
      {
        "additions": 2,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Fsessions%2Fsqlalchemy_session.md",
        "changes": 4,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fko%2Fsessions%2Fsqlalchemy_session.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 2,
        "filename": "docs/ko/sessions/sqlalchemy_session.md",
        "patch": "@@ -8,7 +8,7 @@ search:\n \n ## 설치\n \n-SQLAlchemy 세션에는 `sqlalchemy` extra가 필요합니다:\n+SQLAlchemy 세션을 사용하려면 `sqlalchemy` extra가 필요합니다:\n \n ```bash\n pip install openai-agents[sqlalchemy]\n@@ -74,7 +74,7 @@ if __name__ == \"__main__\":\n ```\n \n \n-## API 참조\n+## API 레퍼런스\n \n - [`SQLAlchemySession`][agents.extensions.memory.sqlalchemy_session.SQLAlchemySession] - 메인 클래스\n - [`Session`][agents.memory.session.Session] - 기본 세션 프로토콜\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Fsessions%2Fsqlalchemy_session.md",
        "sha": "c80b79b8ffe24f42537ec04b796feef2a8a8ff17",
        "status": "modified"
      },
      {
        "additions": 5,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Fstreaming.md",
        "changes": 10,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fko%2Fstreaming.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 5,
        "filename": "docs/ko/streaming.md",
        "patch": "@@ -4,13 +4,13 @@ search:\n ---\n # 스트리밍\n \n-스트리밍은 에이전트 실행이 진행되는 동안 업데이트를 구독할 수 있게 해줍니다. 최종 사용자에게 진행 상태와 부분 응답을 보여줄 때 유용합니다.\n+스트리밍을 사용하면 에이전트 실행이 진행되는 동안 업데이트를 구독할 수 있습니다. 이는 최종 사용자에게 진행 상태와 부분 응답을 보여주는 데 유용합니다.\n \n-스트리밍을 사용하려면 [`Runner.run_streamed()`][agents.run.Runner.run_streamed]를 호출하면 되며, 그러면 [`RunResultStreaming`][agents.result.RunResultStreaming]이 반환됩니다. `result.stream_events()`를 호출하면 아래에 설명된 [`StreamEvent`][agents.stream_events.StreamEvent] 객체의 비동기 스트림을 받습니다.\n+스트리밍을 사용하려면 [`Runner.run_streamed()`][agents.run.Runner.run_streamed]를 호출하면 되며, 이 메서드는 [`RunResultStreaming`][agents.result.RunResultStreaming]을 반환합니다. `result.stream_events()`를 호출하면 아래에서 설명하는 [`StreamEvent`][agents.stream_events.StreamEvent] 객체의 비동기 스트림을 얻을 수 있습니다.\n \n ## 원문 응답 이벤트\n \n-[`RawResponsesStreamEvent`][agents.stream_events.RawResponsesStreamEvent]는 LLM에서 직접 전달되는 원문 이벤트입니다. 이는 OpenAI Responses API 형식이므로 각 이벤트는 타입(예: `response.created`, `response.output_text.delta` 등)과 데이터를 가집니다. 이러한 이벤트는 생성되는 즉시 사용자에게 응답 메시지를 스트리밍하고 싶을 때 유용합니다.\n+[`RawResponsesStreamEvent`][agents.stream_events.RawResponsesStreamEvent]는 LLM에서 직접 전달되는 원문 이벤트입니다. 이들은 OpenAI Responses API 형식이며, 각 이벤트에는 타입(예: `response.created`, `response.output_text.delta` 등)과 데이터가 있습니다. 이러한 이벤트는 생성 즉시 사용자에게 응답 메시지를 스트리밍하고자 할 때 유용합니다.\n \n 예를 들어, 다음은 LLM이 생성한 텍스트를 토큰 단위로 출력합니다.\n \n@@ -35,9 +35,9 @@ if __name__ == \"__main__\":\n     asyncio.run(main())\n ```\n \n-## 실행 아이템 이벤트와 에이전트 이벤트\n+## 실행 항목 이벤트와 에이전트 이벤트\n \n-[`RunItemStreamEvent`][agents.stream_events.RunItemStreamEvent]는 더 상위 수준의 이벤트입니다. 아이템이 완전히 생성되었을 때를 알려줍니다. 이를 통해 각 토큰 단위가 아니라 \"메시지 생성됨\", \"도구 실행됨\" 등의 수준에서 진행 상황을 전달할 수 있습니다. 마찬가지로, [`AgentUpdatedStreamEvent`][agents.stream_events.AgentUpdatedStreamEvent]는 현재 에이전트가 변경될 때(예: 핸드오프 결과로) 업데이트를 제공합니다.\n+[`RunItemStreamEvent`][agents.stream_events.RunItemStreamEvent]는 더 높은 수준의 이벤트로, 항목이 완전히 생성되었을 때 알려줍니다. 이를 통해 각 토큰 대신 \"메시지 생성됨\", \"도구가 실행됨\" 등의 수준에서 진행 상황을 전달할 수 있습니다. 비슷하게, [`AgentUpdatedStreamEvent`][agents.stream_events.AgentUpdatedStreamEvent]는 현재 에이전트가 변경될 때(예: 핸드오프의 결과로) 업데이트를 제공합니다.\n \n 예를 들어, 다음은 원문 이벤트를 무시하고 사용자에게 업데이트를 스트리밍합니다.\n ",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Fstreaming.md",
        "sha": "c5ed3b1e9e569ea9106c4ac83705e94f108420c0",
        "status": "modified"
      },
      {
        "additions": 60,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Ftools.md",
        "changes": 120,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fko%2Ftools.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 60,
        "filename": "docs/ko/tools.md",
        "patch": "@@ -4,23 +4,23 @@ search:\n ---\n # 도구\n \n-도구는 에이전트가 동작을 수행하도록 합니다. 예를 들어 데이터 가져오기, 코드 실행, 외부 API 호출, 심지어 컴퓨터 사용까지 포함합니다. Agents SDK에는 세 가지 클래스의 도구가 있습니다:\n+도구는 에이전트가 데이터를 가져오고, 코드를 실행하고, 외부 API를 호출하고, 심지어 컴퓨터를 사용하는 등의 행동을 할 수 있게 합니다. Agents SDK 에는 세 가지 클래스의 도구가 있습니다:\n \n-- Hosted tools: 이는 AI 모델과 함께 LLM 서버에서 실행됩니다. OpenAI는 retrieval, 웹 검색 및 컴퓨터 사용을 호스티드 툴로 제공합니다\n-- 함수 호출: 임의의 Python 함수를 도구로 사용할 수 있습니다\n-- 에이전트를 도구로 사용: 에이전트를 도구로 사용할 수 있어, 에이전트가 다른 에이전트를 핸드오프 없이 호출할 수 있게 합니다\n+- 호스티드 툴: 이는 AI 모델과 함께 LLM 서버에서 실행됩니다. OpenAI 는 검색, 웹 검색 및 컴퓨터 사용을 호스티드 툴로 제공합니다.\n+- 함수 호출: 임의의 Python 함수를 도구로 사용할 수 있게 합니다.\n+- 도구로서의 에이전트: 에이전트를 도구로 사용해, 핸드오프 없이 에이전트가 다른 에이전트를 호출할 수 있게 합니다.\n \n ## 호스티드 툴\n \n-OpenAI는 [`OpenAIResponsesModel`][agents.models.openai_responses.OpenAIResponsesModel] 사용 시 몇 가지 기본 제공 도구를 제공합니다:\n+OpenAI 는 [`OpenAIResponsesModel`][agents.models.openai_responses.OpenAIResponsesModel] 사용 시 몇 가지 내장 도구를 제공합니다:\n \n-- [`WebSearchTool`][agents.tool.WebSearchTool]은 에이전트가 웹을 검색할 수 있게 합니다\n-- [`FileSearchTool`][agents.tool.FileSearchTool]은 OpenAI 벡터 스토어에서 정보를 검색할 수 있게 합니다\n-- [`ComputerTool`][agents.tool.ComputerTool]은 컴퓨터 사용 작업을 자동화할 수 있게 합니다\n-- [`CodeInterpreterTool`][agents.tool.CodeInterpreterTool]은 LLM이 샌드박스 환경에서 코드를 실행할 수 있게 합니다\n-- [`HostedMCPTool`][agents.tool.HostedMCPTool]은 원격 MCP 서버의 도구를 모델에 노출합니다\n-- [`ImageGenerationTool`][agents.tool.ImageGenerationTool]은 프롬프트로부터 이미지를 생성합니다\n-- [`LocalShellTool`][agents.tool.LocalShellTool]은 로컬 머신에서 셸 명령을 실행합니다\n+- [`WebSearchTool`][agents.tool.WebSearchTool]: 에이전트가 웹을 검색할 수 있게 합니다.\n+- [`FileSearchTool`][agents.tool.FileSearchTool]: OpenAI 벡터 스토어에서 정보를 검색할 수 있게 합니다.\n+- [`ComputerTool`][agents.tool.ComputerTool]: 컴퓨터 사용 작업을 자동화할 수 있게 합니다.\n+- [`CodeInterpreterTool`][agents.tool.CodeInterpreterTool]: LLM 이 샌드박스 환경에서 코드를 실행할 수 있게 합니다.\n+- [`HostedMCPTool`][agents.tool.HostedMCPTool]: 원격 MCP 서버의 도구를 모델에 노출합니다.\n+- [`ImageGenerationTool`][agents.tool.ImageGenerationTool]: 프롬프트로부터 이미지를 생성합니다.\n+- [`LocalShellTool`][agents.tool.LocalShellTool]: 로컬 머신에서 셸 명령을 실행합니다.\n \n ```python\n from agents import Agent, FileSearchTool, Runner, WebSearchTool\n@@ -43,14 +43,14 @@ async def main():\n \n ## 함수 도구\n \n-임의의 Python 함수를 도구로 사용할 수 있습니다. Agents SDK가 도구를 자동으로 설정합니다:\n+임의의 Python 함수를 도구로 사용할 수 있습니다. Agents SDK 가 도구 설정을 자동으로 처리합니다:\n \n-- 도구 이름은 Python 함수 이름이 됩니다(또는 별도의 이름을 제공할 수 있음)\n-- 도구 설명은 함수의 docstring에서 가져옵니다(또는 별도의 설명을 제공할 수 있음)\n-- 함수 입력에 대한 스키마는 함수의 인자에서 자동으로 생성됩니다\n-- 각 입력의 설명은, 비활성화하지 않는 한, 함수의 docstring에서 가져옵니다\n+- 도구 이름은 Python 함수 이름이 됩니다(또는 이름을 직접 지정할 수 있음)\n+- 도구 설명은 함수의 docstring 에서 가져옵니다(또는 설명을 직접 지정할 수 있음)\n+- 함수 입력의 스키마는 함수의 인수로부터 자동 생성됩니다\n+- 각 입력의 설명은 비활성화하지 않는 한 함수의 docstring 에서 가져옵니다\n \n-Python의 `inspect` 모듈을 사용해 함수 시그니처를 추출하고, [`griffe`](https://mkdocstrings.github.io/griffe/)로 docstring을 파싱하며 스키마 생성에는 `pydantic`을 사용합니다.\n+Python 의 `inspect` 모듈로 함수 시그니처를 추출하고, docstring 파싱에는 [`griffe`](https://mkdocstrings.github.io/griffe/), 스키마 생성에는 `pydantic` 을 사용합니다.\n \n ```python\n import json\n@@ -102,10 +102,10 @@ for tool in agent.tools:\n \n ```\n \n-1. 함수의 인자로 임의의 Python 타입을 사용할 수 있으며, 함수는 동기 또는 비동기일 수 있습니다\n-2. Docstring이 있으면 설명과 인자 설명을 캡처하는 데 사용됩니다\n-3. 함수는 선택적으로 `context`를 받을 수 있습니다(첫 번째 인자여야 함). 또한 도구 이름, 설명, 사용할 docstring 스타일 등 오버라이드를 설정할 수 있습니다\n-4. 데코레이트된 함수를 도구 목록에 전달할 수 있습니다\n+1. 함수 인자로는 어떤 Python 타입이든 사용할 수 있으며, 함수는 동기 또는 비동기일 수 있습니다.\n+2. docstring 이 있으면 설명과 인자 설명을 추출하는 데 사용합니다\n+3. 함수는 선택적으로 `context` 를 받을 수 있습니다(첫 번째 인자여야 함). 도구 이름, 설명, 사용할 docstring 스타일 등 오버라이드도 설정할 수 있습니다.\n+4. 데코레이터를 적용한 함수를 도구 목록에 전달하면 됩니다.\n \n ??? note \"출력을 보려면 펼치기\"\n \n@@ -179,20 +179,20 @@ for tool in agent.tools:\n \n ### 함수 도구에서 이미지 또는 파일 반환\n \n-텍스트 출력 외에도 함수 도구의 출력으로 하나 이상의 이미지나 파일을 반환할 수 있습니다. 이를 위해 다음 중 하나를 반환할 수 있습니다:\n+텍스트 출력 외에도, 함수 도구의 출력으로 하나 이상의 이미지 또는 파일을 반환할 수 있습니다. 이를 위해 다음 중 하나를 반환할 수 있습니다:\n \n-- 이미지: [`ToolOutputImage`][agents.tool.ToolOutputImage] (또는 TypedDict 버전, [`ToolOutputImageDict`][agents.tool.ToolOutputImageDict])\n-- 파일: [`ToolOutputFileContent`][agents.tool.ToolOutputFileContent] (또는 TypedDict 버전, [`ToolOutputFileContentDict`][agents.tool.ToolOutputFileContentDict])\n-- 텍스트: 문자열 또는 문자열로 변환 가능한 객체, 또는 [`ToolOutputText`][agents.tool.ToolOutputText] (또는 TypedDict 버전, [`ToolOutputTextDict`][agents.tool.ToolOutputTextDict])\n+- 이미지: [`ToolOutputImage`][agents.tool.ToolOutputImage] (또는 TypedDict 버전인 [`ToolOutputImageDict`][agents.tool.ToolOutputImageDict])\n+- 파일: [`ToolOutputFileContent`][agents.tool.ToolOutputFileContent] (또는 TypedDict 버전인 [`ToolOutputFileContentDict`][agents.tool.ToolOutputFileContentDict])\n+- 텍스트: 문자열 또는 문자열로 변환 가능한 객체, 혹은 [`ToolOutputText`][agents.tool.ToolOutputText] (또는 TypedDict 버전인 [`ToolOutputTextDict`][agents.tool.ToolOutputTextDict])\n \n ### 커스텀 함수 도구\n \n-때로는 Python 함수를 도구로 사용하고 싶지 않을 수 있습니다. 원하는 경우 [`FunctionTool`][agents.tool.FunctionTool]을 직접 생성할 수 있습니다. 다음을 제공해야 합니다:\n+때로는 Python 함수를 도구로 사용하고 싶지 않을 수 있습니다. 이 경우 [`FunctionTool`][agents.tool.FunctionTool] 을 직접 생성할 수 있습니다. 다음을 제공해야 합니다:\n \n - `name`\n - `description`\n-- 인자를 위한 JSON 스키마인 `params_json_schema`\n-- [`ToolContext`][agents.tool_context.ToolContext]와 인자(JSON 문자열)를 받아 도구 출력을 문자열로 반환해야 하는 비동기 함수 `on_invoke_tool`\n+- `params_json_schema` (인자의 JSON 스키마)\n+- `on_invoke_tool` (비동기 함수로, [`ToolContext`][agents.tool_context.ToolContext] 와 JSON 문자열 형태의 인자를 받아, 도구 출력을 문자열로 반환해야 함)\n \n ```python\n from typing import Any\n@@ -225,18 +225,18 @@ tool = FunctionTool(\n )\n ```\n \n-### 인자 및 docstring 자동 파싱\n+### 자동 인자 및 docstring 파싱\n \n-앞서 언급했듯이, 도구의 스키마를 추출하기 위해 함수 시그니처를 자동으로 파싱하고, 도구 및 개별 인자에 대한 설명을 추출하기 위해 docstring을 파싱합니다. 이에 대한 참고 사항:\n+앞서 언급했듯이, 함수 시그니처를 자동으로 파싱해 도구의 스키마를 추출하고, docstring 을 파싱해 도구 및 개별 인자 설명을 추출합니다. 이에 대한 몇 가지 참고 사항:\n \n-1. 시그니처 파싱은 `inspect` 모듈을 통해 수행됩니다. 타입 주석을 사용해 인자의 타입을 파악하고, 전체 스키마를 표현하는 Pydantic 모델을 동적으로 빌드합니다. Python 기본 타입, Pydantic 모델, TypedDict 등 대부분의 타입을 지원합니다\n-2. docstring 파싱에는 `griffe`를 사용합니다. 지원하는 docstring 형식은 `google`, `sphinx`, `numpy`입니다. docstring 형식은 자동 감지를 시도하지만 최선의 노력일 뿐이며, `function_tool` 호출 시 명시적으로 설정할 수 있습니다. `use_docstring_info`를 `False`로 설정하여 docstring 파싱을 비활성화할 수도 있습니다\n+1. 시그니처 파싱은 `inspect` 모듈을 통해 수행합니다. 타입 힌트를 사용해 인자의 타입을 파악하고, 전체 스키마를 표현하는 Pydantic 모델을 동적으로 구성합니다. Python 기본 타입, Pydantic 모델, TypedDict 등 대부분의 타입을 지원합니다.\n+2. docstring 파싱에는 `griffe` 를 사용합니다. 지원하는 docstring 형식은 `google`, `sphinx`, `numpy` 입니다. 형식을 자동 감지하려 시도하지만 최선의 노력일 뿐이므로, `function_tool` 호출 시 명시적으로 설정할 수 있습니다. `use_docstring_info` 를 `False` 로 설정해 docstring 파싱을 비활성화할 수도 있습니다.\n \n-스키마 추출에 대한 코드는 [`agents.function_schema`][]에 있습니다.\n+스키마 추출을 위한 코드는 [`agents.function_schema`][] 에 있습니다.\n \n-## 에이전트를 도구로 사용\n+## 도구로서의 에이전트\n \n-일부 워크플로에서는 핸드오프 대신 중앙 에이전트가 특화된 에이전트 네트워크를 멀티 에이전트 오케스트레이션하도록 하고 싶을 수 있습니다. 이를 위해 에이전트를 도구로 모델링할 수 있습니다.\n+일부 워크플로에서는 제어를 넘기지 않고, 중앙 에이전트가 특화된 에이전트들의 네트워크를 오케스트레이션하기를 원할 수 있습니다. 에이전트를 도구로 모델링하여 이를 구현할 수 있습니다.\n \n ```python\n from agents import Agent, Runner\n@@ -277,7 +277,7 @@ async def main():\n \n ### 도구-에이전트 커스터마이징\n \n-`agent.as_tool` 함수는 에이전트를 도구로 쉽게 전환하기 위한 편의 메서드입니다. 다만 모든 구성을 지원하지는 않습니다. 예를 들어 `max_turns`는 설정할 수 없습니다. 고급 사용 사례에서는 도구 구현에서 `Runner.run`을 직접 사용하십시오:\n+`agent.as_tool` 함수는 에이전트를 손쉽게 도구로 바꿀 수 있는 편의 메서드입니다. 다만 모든 구성을 지원하지는 않습니다. 예를 들어 `max_turns` 를 설정할 수 없습니다. 고급 사용 사례에서는 도구 구현 내에서 `Runner.run` 을 직접 사용하세요:\n \n ```python\n @function_tool\n@@ -298,10 +298,10 @@ async def run_my_agent() -> str:\n \n ### 커스텀 출력 추출\n \n-특정 경우, 중앙 에이전트에 반환하기 전에 도구-에이전트의 출력을 수정하고 싶을 수 있습니다. 다음과 같은 상황에서 유용합니다:\n+특정 경우, 중앙 에이전트에 반환하기 전에 도구-에이전트의 출력을 수정하고 싶을 수 있습니다. 다음이 필요한 경우 유용합니다:\n \n-- 하위 에이전트의 대화 내역에서 특정 정보(예: JSON payload)를 추출\n-- 에이전트의 최종 답변을 변환 또는 재포맷(예: Markdown을 일반 텍스트 또는 CSV로 변환)\n+- 하위 에이전트의 채팅 기록에서 특정 정보(예: JSON 페이로드)를 추출\n+- 에이전트의 최종 답변을 변환 또는 재포맷(예: Markdown 을 일반 텍스트 또는 CSV 로 변환)\n - 에이전트의 응답이 없거나 잘못된 경우 출력을 검증하거나 폴백 값을 제공\n \n 이는 `as_tool` 메서드에 `custom_output_extractor` 인자를 제공하여 수행할 수 있습니다:\n@@ -325,7 +325,7 @@ json_tool = data_agent.as_tool(\n \n ### 중첩 에이전트 실행 스트리밍\n \n-중첩된 에이전트가 내보내는 스트리밍 이벤트를 수신하면서 스트림 완료 후 최종 출력을 반환하려면 `as_tool`에 `on_stream` 콜백을 전달하십시오.\n+중첩 에이전트가 내보내는 스트리밍 이벤트를 수신하기 위해 `as_tool` 에 `on_stream` 콜백을 전달하세요. 스트림이 완료되면 최종 출력은 그대로 반환됩니다.\n \n ```python\n from agents import AgentToolStreamEvent\n@@ -343,17 +343,17 @@ billing_agent_tool = billing_agent.as_tool(\n )\n ```\n \n-예상할 내용:\n+기대할 수 있는 것:\n \n-- 이벤트 타입은 `StreamEvent[\"type\"]`을 반영합니다: `raw_response_event`, `run_item_stream_event`, `agent_updated_stream_event`\n-- `on_stream`을 제공하면 중첩 에이전트가 자동으로 스트리밍 모드에서 실행되며, 최종 출력을 반환하기 전에 스트림을 소진합니다\n+- 이벤트 타입은 `StreamEvent[\"type\"]` 을 반영합니다: `raw_response_event`, `run_item_stream_event`, `agent_updated_stream_event`\n+- `on_stream` 을 제공하면 중첩 에이전트가 자동으로 스트리밍 모드로 실행되고, 최종 출력을 반환하기 전에 스트림을 소모합니다\n - 핸들러는 동기 또는 비동기일 수 있으며, 각 이벤트는 도착 순서대로 전달됩니다\n-- 도구가 모델의 tool call을 통해 호출된 경우 `tool_call_id`가 존재하며, 직접 호출된 경우 `None`일 수 있습니다\n-- 완전한 실행 가능한 샘플은 `examples/agent_patterns/agents_as_tools_streaming.py`를 참고하세요\n+- 모델의 도구 호출을 통해 도구가 호출된 경우 `tool_call_id` 가 제공됩니다. 직접 호출의 경우 `None` 일 수 있습니다\n+- 전체 실행 가능한 샘플은 `examples/agent_patterns/agents_as_tools_streaming.py` 를 참고하세요\n \n ### 조건부 도구 활성화\n \n-런타임에서 `is_enabled` 매개변수를 사용해 에이전트 도구를 조건부로 활성화 또는 비활성화할 수 있습니다. 이를 통해 컨텍스트, 사용자 선호도 또는 런타임 조건에 따라 LLM에 제공할 수 있는 도구를 동적으로 필터링할 수 있습니다.\n+런타임에 `is_enabled` 매개변수를 사용해 에이전트 도구를 조건부로 활성화하거나 비활성화할 수 있습니다. 이를 통해 컨텍스트, 사용자 선호도 또는 런타임 조건에 따라 LLM 에서 사용할 수 있는 도구를 동적으로 필터링할 수 있습니다.\n \n ```python\n import asyncio\n@@ -408,26 +408,26 @@ async def main():\n asyncio.run(main())\n ```\n \n-`is_enabled` 매개변수는 다음을 허용합니다:\n+`is_enabled` 매개변수는 다음을 받을 수 있습니다:\n \n-- **Boolean 값**: `True`(항상 활성) 또는 `False`(항상 비활성)\n-- **호출 가능한 함수**: `(context, agent)`를 받아 boolean을 반환하는 함수\n-- **비동기 함수**: 복잡한 조건 로직을 위한 async 함수\n+- **불리언 값**: `True`(항상 활성) 또는 `False`(항상 비활성)\n+- **호출 가능한 함수**: `(context, agent)` 를 받아 불리언을 반환하는 함수\n+- **비동기 함수**: 복잡한 조건부 로직을 위한 비동기 함수\n \n-비활성화된 도구는 런타임에서 LLM에 완전히 숨겨지므로 다음과 같은 경우에 유용합니다:\n+비활성화된 도구는 런타임에 LLM 에서 완전히 숨겨지므로 다음에 유용합니다:\n \n-- 사용자 권한에 따른 기능 게이팅\n-- 환경별 도구 가용성(개발 vs 운영)\n+- 사용자 권한 기반 기능 게이팅\n+- 환경별 도구 가용성(dev vs prod)\n - 서로 다른 도구 구성을 A/B 테스트\n-- 런타임 상태에 따른 동적 도구 필터링\n+- 런타임 상태 기반 동적 도구 필터링\n \n-## 함수 도구의 오류 처리\n+## 함수 도구에서의 오류 처리\n \n-`@function_tool`로 함수 도구를 만들 때 `failure_error_function`을 전달할 수 있습니다. 이는 도구 호출이 크래시할 경우 LLM에 오류 응답을 제공하는 함수입니다.\n+`@function_tool` 로 함수 도구를 생성할 때 `failure_error_function` 을 전달할 수 있습니다. 이는 도구 호출이 크래시할 경우 LLM 에 오류 응답을 제공하는 함수입니다.\n \n-- 기본적으로(즉, 아무 것도 전달하지 않으면) 오류가 발생했음을 LLM에 알리는 `default_tool_error_function`이 실행됩니다\n-- 자체 오류 함수를 전달하면 해당 함수가 대신 실행되어 그 응답이 LLM에 전송됩니다\n-- 명시적으로 `None`을 전달하면 도구 호출 오류가 재발생(re-raise)되어 직접 처리할 수 있습니다. 모델이 잘못된 JSON을 생성한 경우 `ModelBehaviorError`, 코드가 크래시한 경우 `UserError` 등이 될 수 있습니다\n+- 기본값(즉, 아무 것도 전달하지 않은 경우)으로, 오류가 발생했음을 LLM 에 알리는 `default_tool_error_function` 이 실행됩니다.\n+- 사용자 정의 오류 함수를 전달하면, 해당 함수가 대신 실행되어 LLM 에 응답을 보냅니다.\n+- 명시적으로 `None` 을 전달하면, 도구 호출 오류가 재발생되어 호출 측에서 처리해야 합니다. 모델이 잘못된 JSON 을 생성한 경우 `ModelBehaviorError`, 사용자 코드가 크래시한 경우 `UserError` 등이 될 수 있습니다.\n \n ```python\n from agents import function_tool, RunContextWrapper",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Ftools.md",
        "sha": "7045fa3c52e31509a66f7d278f421923317ad542",
        "status": "modified"
      },
      {
        "additions": 74,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Ftracing.md",
        "changes": 136,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fko%2Ftracing.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 62,
        "filename": "docs/ko/tracing.md",
        "patch": "@@ -4,52 +4,52 @@ search:\n ---\n # 트레이싱\n \n-Agents SDK에는 트레이싱이 내장되어 있어 에이전트 실행 중 발생하는 이벤트에 대한 포괄적인 기록을 수집합니다: LLM 생성, 도구 호출, 핸드오프, 가드레일, 그리고 사용자 정의 이벤트까지 포함합니다. [Traces 대시보드](https://platform.openai.com/traces)를 사용하면 개발 및 운영 환경에서 워크플로를 디버그하고, 시각화하며, 모니터링할 수 있습니다.\n+Agents SDK에는 에이전트 실행 중 발생하는 이벤트의 포괄적인 기록을 수집하는 트레이싱이 기본 내장되어 있습니다. 여기에는 LLM 생성, 도구 호출, 핸드오프, 가드레일, 사용자 정의 이벤트까지 포함됩니다. [Traces 대시보드](https://platform.openai.com/traces)를 사용하면 개발 및 프로덕션 환경에서 워크플로를 디버그, 시각화, 모니터링할 수 있습니다.\n \n !!!note\n \n     트레이싱은 기본적으로 활성화되어 있습니다. 트레이싱을 비활성화하는 방법은 두 가지입니다:\n \n-    1. 환경 변수 `OPENAI_AGENTS_DISABLE_TRACING=1` 설정으로 전역 트레이싱을 비활성화할 수 있습니다\n-    2. 단일 실행에 대해 [`agents.run.RunConfig.tracing_disabled`][] 를 `True` 로 설정하여 트레이싱을 비활성화할 수 있습니다\n+    1. 환경 변수 `OPENAI_AGENTS_DISABLE_TRACING=1` 을 설정하여 전역으로 비활성화\n+    2. 단일 실행에 대해서만 [`agents.run.RunConfig.tracing_disabled`][] 를 `True` 로 설정하여 비활성화\n \n-***OpenAI의 API를 사용하는 Zero Data Retention (ZDR) 정책 하의 조직에서는 트레이싱을 사용할 수 없습니다.***\n+***OpenAI의 API를 사용하면서 Zero Data Retention(제로 데이터 보존, ZDR) 정책을 적용하는 조직의 경우 트레이싱을 사용할 수 없습니다.***\n \n ## 트레이스와 스팬\n \n--   **트레이스(Traces)** 는 하나의 \"워크플로\"에 대한 단일 엔드 투 엔드 작업을 나타냅니다. 스팬으로 구성됩니다. 트레이스에는 다음 속성이 있습니다:\n-    -   `workflow_name`: 논리적 워크플로 또는 앱 이름입니다. 예: \"Code generation\" 또는 \"Customer service\"\n-    -   `trace_id`: 트레이스의 고유 ID입니다. 전달하지 않으면 자동 생성됩니다. 형식은 `trace_<32_alphanumeric>` 이어야 합니다\n-    -   `group_id`: 선택적 그룹 ID로, 동일한 대화에서 나온 여러 트레이스를 연결합니다. 예를 들어 채팅 스레드 ID를 사용할 수 있습니다\n-    -   `disabled`: True이면 트레이스가 기록되지 않습니다\n-    -   `metadata`: 트레이스에 대한 선택적 메타데이터\n--   **스팬(Spans)** 은 시작 및 종료 시간이 있는 작업을 나타냅니다. 스팬에는 다음이 포함됩니다:\n-    -   `started_at` 및 `ended_at` 타임스탬프\n-    -   속한 트레이스를 나타내는 `trace_id`\n-    -   이 스팬의 부모 스팬(있는 경우)을 가리키는 `parent_id`\n-    -   스팬에 대한 정보인 `span_data`. 예를 들어 `AgentSpanData` 는 에이전트 정보, `GenerationSpanData` 는 LLM 생성 정보 등을 포함합니다\n+- **트레이스(Traces)** 는 하나의 \"워크플로\"에 대한 단일 엔드 투 엔드 작업을 나타냅니다. 트레이스는 스팬으로 구성됩니다. 트레이스에는 다음 속성이 있습니다:\n+    - `workflow_name`: 논리적 워크플로 또는 앱의 이름입니다. 예: \"Code generation\" 또는 \"Customer service\"\n+    - `trace_id`: 트레이스의 고유 ID입니다. 전달하지 않으면 자동 생성됩니다. 형식은 `trace_<32_alphanumeric>` 이어야 합니다\n+    - `group_id`: 동일한 대화에서 나온 여러 트레이스를 연결하기 위한 선택적 그룹 ID입니다. 예를 들어 채팅 스레드 ID를 사용할 수 있습니다\n+    - `disabled`: True 인 경우 트레이스가 기록되지 않습니다\n+    - `metadata`: 트레이스에 대한 선택적 메타데이터\n+- **스팬(Spans)** 은 시작 및 종료 시간이 있는 작업을 나타냅니다. 스팬에는 다음이 있습니다:\n+    - `started_at` 및 `ended_at` 타임스탬프\n+    - 소속 트레이스를 나타내는 `trace_id`\n+    - (있는 경우) 이 스팬의 부모 스팬을 가리키는 `parent_id`\n+    - 스팬에 대한 정보인 `span_data`. 예를 들어, `AgentSpanData` 는 에이전트에 대한 정보를, `GenerationSpanData` 는 LLM 생성에 대한 정보를 포함합니다\n \n ## 기본 트레이싱\n \n 기본적으로 SDK는 다음을 트레이싱합니다:\n \n--   전체 `Runner.{run, run_sync, run_streamed}()` 는 `trace()` 로 래핑됩니다\n--   에이전트가 실행될 때마다 `agent_span()` 으로 래핑됩니다\n--   LLM 생성은 `generation_span()` 으로 래핑됩니다\n--   함수 도구 호출은 각각 `function_span()` 으로 래핑됩니다\n--   가드레일은 `guardrail_span()` 으로 래핑됩니다\n--   핸드오프는 `handoff_span()` 으로 래핑됩니다\n--   오디오 입력(음성-텍스트 변환)은 `transcription_span()` 으로 래핑됩니다\n--   오디오 출력(텍스트-음성 변환)은 `speech_span()` 으로 래핑됩니다\n--   관련 오디오 스팬은 `speech_group_span()` 아래에 부모로 설정될 수 있습니다\n+- 전체 `Runner.{run, run_sync, run_streamed}()` 가 `trace()` 로 래핑됨\n+- 에이전트가 실행될 때마다 `agent_span()` 으로 래핑됨\n+- LLM 생성이 `generation_span()` 으로 래핑됨\n+- 함수 도구 호출이 각각 `function_span()` 으로 래핑됨\n+- 가드레일이 `guardrail_span()` 으로 래핑됨\n+- 핸드오프가 `handoff_span()` 으로 래핑됨\n+- 오디오 입력(음성 → 텍스트)이 `transcription_span()` 으로 래핑됨\n+- 오디오 출력(텍스트 → 음성)이 `speech_span()` 으로 래핑됨\n+- 관련 오디오 스팬은 `speech_group_span()` 아래에 부모-자식 관계로 묶일 수 있음\n \n-기본적으로 트레이스 이름은 \"Agent workflow\" 입니다. `trace` 를 사용하여 이 이름을 설정할 수 있으며, 또는 [`RunConfig`][agents.run.RunConfig] 로 이름 및 기타 속성을 구성할 수 있습니다.\n+기본적으로 트레이스 이름은 \"Agent workflow\"입니다. `trace` 를 사용해 이 이름을 설정할 수 있으며, 또는 [`RunConfig`][agents.run.RunConfig] 로 이름과 기타 속성을 구성할 수 있습니다.\n \n-또한 [사용자 정의 트레이스 프로세서](#custom-tracing-processors)를 설정하여 트레이스를 다른 대상지로 전송할 수 있습니다(기본 백엔드 대체 또는 보조 대상지로 전송).\n+또한 [사용자 정의 트레이스 프로세서](#custom-tracing-processors)를 설정해 다른 대상지로 트레이스를 전송할 수 있습니다(기본 대상지 대체 또는 추가 대상지로 전송).\n \n ## 상위 수준 트레이스\n \n-때로는 여러 번의 `run()` 호출을 하나의 트레이스에 포함하고 싶을 수 있습니다. 이 경우 전체 코드를 `trace()` 로 감싸면 됩니다.\n+때로는 `run()` 여러 호출을 하나의 트레이스에 포함시키고 싶을 수 있습니다. 전체 코드를 `trace()` 로 감싸면 됩니다.\n \n ```python\n from agents import Agent, Runner, trace\n@@ -64,46 +64,46 @@ async def main():\n         print(f\"Rating: {second_result.final_output}\")\n ```\n \n-1. `Runner.run` 에 대한 두 번의 호출이 `with trace()` 로 감싸져 있으므로, 개별 실행이 두 개의 트레이스를 생성하는 대신 전체 트레이스의 일부가 됩니다.\n+1. `with trace()` 로 `Runner.run` 두 호출을 감쌌기 때문에, 개별 실행이 두 개의 트레이스를 생성하는 대신 전체 트레이스의 일부가 됩니다.\n \n ## 트레이스 생성\n \n-[`trace()`][agents.tracing.trace] 함수를 사용해 트레이스를 생성할 수 있습니다. 트레이스는 시작과 종료가 필요합니다. 이를 수행하는 방법은 두 가지입니다:\n+[`trace()`][agents.tracing.trace] 함수를 사용해 트레이스를 생성할 수 있습니다. 트레이스는 시작과 종료가 필요합니다. 방법은 두 가지입니다:\n \n-1. **권장**: 컨텍스트 매니저로 사용합니다. 예: `with trace(...) as my_trace`. 적절한 시점에 트레이스를 자동으로 시작하고 종료합니다\n+1. 권장: 컨텍스트 매니저로 사용합니다. 예: `with trace(...) as my_trace`. 적절한 시점에 자동으로 시작하고 종료합니다\n 2. 수동으로 [`trace.start()`][agents.tracing.Trace.start] 와 [`trace.finish()`][agents.tracing.Trace.finish] 를 호출할 수도 있습니다\n \n-현재 트레이스는 파이썬의 [`contextvar`](https://docs.python.org/3/library/contextvars.html) 를 통해 추적됩니다. 이는 자동으로 동시성에서 작동함을 의미합니다. 트레이스를 수동으로 시작/종료하는 경우, 현재 트레이스를 업데이트하기 위해 `start()`/`finish()` 에 `mark_as_current` 및 `reset_current` 를 전달해야 합니다.\n+현재 트레이스는 Python [`contextvar`](https://docs.python.org/3/library/contextvars.html)를 통해 추적됩니다. 즉, 자동으로 동시성을 지원합니다. 트레이스를 수동으로 시작/종료하는 경우, 현재 트레이스를 업데이트하려면 `start()`/`finish()` 에 `mark_as_current` 와 `reset_current` 를 전달해야 합니다.\n \n ## 스팬 생성\n \n-여러 [`*_span()`][agents.tracing.create] 메서드를 사용하여 스팬을 생성할 수 있습니다. 일반적으로 스팬을 수동으로 생성할 필요는 없습니다. 사용자 정의 스팬 정보를 추적하기 위한 [`custom_span()`][agents.tracing.custom_span] 함수가 제공됩니다.\n+여러 [`*_span()`][agents.tracing.create] 메서드를 사용해 스팬을 생성할 수 있습니다. 일반적으로 스팬을 수동으로 생성할 필요는 없습니다. 사용자 정의 스팬 정보를 추적하기 위해 [`custom_span()`][agents.tracing.custom_span] 함수가 제공됩니다.\n \n-스팬은 자동으로 현재 트레이스의 일부가 되며, 파이썬 [`contextvar`](https://docs.python.org/3/library/contextvars.html) 를 통해 추적되는 가장 가까운 현재 스팬 아래로 중첩됩니다.\n+스팬은 자동으로 현재 트레이스의 일부가 되며, Python [`contextvar`](https://docs.python.org/3/library/contextvars.html) 로 추적되는 가장 가까운 현재 스팬 아래에 중첩됩니다.\n \n ## 민감한 데이터\n \n 일부 스팬은 잠재적으로 민감한 데이터를 캡처할 수 있습니다.\n \n `generation_span()` 은 LLM 생성의 입력/출력을 저장하고, `function_span()` 은 함수 호출의 입력/출력을 저장합니다. 민감한 데이터가 포함될 수 있으므로, [`RunConfig.trace_include_sensitive_data`][agents.run.RunConfig.trace_include_sensitive_data] 를 통해 해당 데이터 캡처를 비활성화할 수 있습니다.\n \n-마찬가지로, 오디오 스팬은 기본적으로 입력 및 출력 오디오에 대해 base64로 인코딩된 PCM 데이터를 포함합니다. [`VoicePipelineConfig.trace_include_sensitive_audio_data`][agents.voice.pipeline_config.VoicePipelineConfig.trace_include_sensitive_audio_data] 를 구성하여 이 오디오 데이터 캡처를 비활성화할 수 있습니다.\n+마찬가지로, 오디오 스팬은 기본적으로 입력 및 출력 오디오에 대해 base64 로 인코딩된 PCM 데이터를 포함합니다. [`VoicePipelineConfig.trace_include_sensitive_audio_data`][agents.voice.pipeline_config.VoicePipelineConfig.trace_include_sensitive_audio_data] 를 구성하여 이 오디오 데이터 캡처를 비활성화할 수 있습니다.\n \n-## 맞춤형 트레이싱 프로세서\n+## 사용자 정의 트레이싱 프로세서\n \n 트레이싱의 상위 수준 아키텍처는 다음과 같습니다:\n \n--   초기화 시, 트레이스를 생성할 책임이 있는 전역 [`TraceProvider`][agents.tracing.setup.TraceProvider] 를 생성합니다\n--   `TraceProvider` 를 [`BatchTraceProcessor`][agents.tracing.processors.BatchTraceProcessor] 로 구성하고, 이는 트레이스/스팬을 배치로 [`BackendSpanExporter`][agents.tracing.processors.BackendSpanExporter] 에 전송하며, 이 Exporter는 스팬과 트레이스를 OpenAI 백엔드로 배치 전송합니다\n+- 초기화 시, 트레이스를 생성하는 역할을 하는 전역 [`TraceProvider`][agents.tracing.setup.TraceProvider] 를 생성합니다\n+- `TraceProvider` 를 [`BatchTraceProcessor`][agents.tracing.processors.BatchTraceProcessor] 로 구성하고, 이 프로세서는 트레이스/스팬을 배치로 [`BackendSpanExporter`][agents.tracing.processors.BackendSpanExporter] 에 전송합니다. Exporter 는 스팬과 트레이스를 OpenAI 백엔드로 배치 전송합니다\n \n-기본 설정을 사용자 정의하여 대체 또는 추가 백엔드로 트레이스를 보내거나 Exporter 동작을 수정하려면 두 가지 옵션이 있습니다:\n+기본 설정을 사용자 정의하여, 대체 또는 추가 백엔드로 트레이스를 전송하거나 exporter 동작을 수정하려면 두 가지 옵션이 있습니다:\n \n-1. [`add_trace_processor()`][agents.tracing.add_trace_processor] 는 트레이스와 스팬이 준비될 때 이를 수신하는 **추가** 트레이스 프로세서를 추가할 수 있게 합니다. 이를 통해 OpenAI 백엔드로 트레이스를 전송하는 것 외에 자체 처리를 수행할 수 있습니다\n-2. [`set_trace_processors()`][agents.tracing.set_trace_processors] 는 기본 프로세서를 사용자 정의 트레이스 프로세서로 **대체** 할 수 있게 합니다. 이 경우 OpenAI 백엔드로 트레이스가 전송되지 않으며, 이를 수행하는 `TracingProcessor` 를 포함해야 합니다\n+1. [`add_trace_processor()`][agents.tracing.add_trace_processor] 를 사용해 **추가** 트레이스 프로세서를 등록하면, 준비된 트레이스와 스팬을 이 프로세서도 수신합니다. 이를 통해 OpenAI 백엔드로 전송하는 것과 별도로 자체 처리를 수행할 수 있습니다\n+2. [`set_trace_processors()`][agents.tracing.set_trace_processors] 를 사용해 기본 프로세서를 **교체** 하여 자체 트레이스 프로세서를 사용할 수 있습니다. 이 경우 OpenAI 백엔드로 트레이스가 전송되지 않으며, 그렇게 하는 `TracingProcessor` 를 포함해야 합니다\n \n-## 비 OpenAI 모델 트레이싱\n+## OpenAI가 아닌 모델과의 트레이싱\n \n-트레이싱을 비활성화하지 않고도 OpenAI Traces 대시보드에서 무료 트레이싱을 활성화하기 위해 OpenAI API 키를 비 OpenAI 모델과 함께 사용할 수 있습니다.\n+OpenAI의 API 키를 비 OpenAI 모델과 함께 사용하여, 트레이싱을 비활성화하지 않고도 OpenAI Traces 대시보드에서 무료 트레이싱을 활성화할 수 있습니다.\n \n ```python\n import os\n@@ -124,28 +124,40 @@ agent = Agent(\n )\n ```\n \n+단일 실행에 대해서만 다른 트레이싱 키가 필요하다면, 전역 exporter 를 변경하지 말고 `RunConfig` 를 통해 전달하세요.\n+\n+```python\n+from agents import Runner, RunConfig\n+\n+await Runner.run(\n+    agent,\n+    input=\"Hello\",\n+    run_config=RunConfig(tracing={\"api_key\": \"sk-tracing-123\"}),\n+)\n+```\n+\n ## 참고\n - OpenAI Traces 대시보드에서 무료 트레이스를 확인하세요.\n \n ## 외부 트레이싱 프로세서 목록\n \n--   [Weights & Biases](https://weave-docs.wandb.ai/guides/integrations/openai_agents)\n--   [Arize-Phoenix](https://docs.arize.com/phoenix/tracing/integrations-tracing/openai-agents-sdk)\n--   [Future AGI](https://docs.futureagi.com/future-agi/products/observability/auto-instrumentation/openai_agents)\n--   [MLflow (self-hosted/OSS)](https://mlflow.org/docs/latest/tracing/integrations/openai-agent)\n--   [MLflow (Databricks hosted)](https://docs.databricks.com/aws/en/mlflow/mlflow-tracing#-automatic-tracing)\n--   [Braintrust](https://braintrust.dev/docs/guides/traces/integrations#openai-agents-sdk)\n--   [Pydantic Logfire](https://logfire.pydantic.dev/docs/integrations/llms/openai/#openai-agents)\n--   [AgentOps](https://docs.agentops.ai/v1/integrations/agentssdk)\n--   [Scorecard](https://docs.scorecard.io/docs/documentation/features/tracing#openai-agents-sdk-integration)\n--   [Keywords AI](https://docs.keywordsai.co/integration/development-frameworks/openai-agent)\n--   [LangSmith](https://docs.smith.langchain.com/observability/how_to_guides/trace_with_openai_agents_sdk)\n--   [Maxim AI](https://www.getmaxim.ai/docs/observe/integrations/openai-agents-sdk)\n--   [Comet Opik](https://www.comet.com/docs/opik/tracing/integrations/openai_agents)\n--   [Langfuse](https://langfuse.com/docs/integrations/openaiagentssdk/openai-agents)\n--   [Langtrace](https://docs.langtrace.ai/supported-integrations/llm-frameworks/openai-agents-sdk)\n--   [Okahu-Monocle](https://github.com/monocle2ai/monocle)\n--   [Galileo](https://v2docs.galileo.ai/integrations/openai-agent-integration#openai-agent-integration)\n--   [Portkey AI](https://portkey.ai/docs/integrations/agents/openai-agents)\n--   [LangDB AI](https://docs.langdb.ai/getting-started/working-with-agent-frameworks/working-with-openai-agents-sdk)\n--   [Agenta](https://docs.agenta.ai/observability/integrations/openai-agents)\n\\ No newline at end of file\n+- [Weights & Biases](https://weave-docs.wandb.ai/guides/integrations/openai_agents)\n+- [Arize-Phoenix](https://docs.arize.com/phoenix/tracing/integrations-tracing/openai-agents-sdk)\n+- [Future AGI](https://docs.futureagi.com/future-agi/products/observability/auto-instrumentation/openai_agents)\n+- [MLflow (self-hosted/OSS)](https://mlflow.org/docs/latest/tracing/integrations/openai-agent)\n+- [MLflow (Databricks hosted)](https://docs.databricks.com/aws/en/mlflow/mlflow-tracing#-automatic-tracing)\n+- [Braintrust](https://braintrust.dev/docs/guides/traces/integrations#openai-agents-sdk)\n+- [Pydantic Logfire](https://logfire.pydantic.dev/docs/integrations/llms/openai/#openai-agents)\n+- [AgentOps](https://docs.agentops.ai/v1/integrations/agentssdk)\n+- [Scorecard](https://docs.scorecard.io/docs/documentation/features/tracing#openai-agents-sdk-integration)\n+- [Keywords AI](https://docs.keywordsai.co/integration/development-frameworks/openai-agent)\n+- [LangSmith](https://docs.smith.langchain.com/observability/how_to_guides/trace_with_openai_agents_sdk)\n+- [Maxim AI](https://www.getmaxim.ai/docs/observe/integrations/openai-agents-sdk)\n+- [Comet Opik](https://www.comet.com/docs/opik/tracing/integrations/openai_agents)\n+- [Langfuse](https://langfuse.com/docs/integrations/openaiagentssdk/openai-agents)\n+- [Langtrace](https://docs.langtrace.ai/supported-integrations/llm-frameworks/openai-agents-sdk)\n+- [Okahu-Monocle](https://github.com/monocle2ai/monocle)\n+- [Galileo](https://v2docs.galileo.ai/integrations/openai-agent-integration#openai-agent-integration)\n+- [Portkey AI](https://portkey.ai/docs/integrations/agents/openai-agents)\n+- [LangDB AI](https://docs.langdb.ai/getting-started/working-with-agent-frameworks/working-with-openai-agents-sdk)\n+- [Agenta](https://docs.agenta.ai/observability/integrations/openai-agents)\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Ftracing.md",
        "sha": "ac3db00609ccf010b744fe3200f4fc42036c4412",
        "status": "modified"
      },
      {
        "additions": 21,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Fusage.md",
        "changes": 42,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fko%2Fusage.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 21,
        "filename": "docs/ko/usage.md",
        "patch": "@@ -4,22 +4,22 @@ search:\n ---\n # 사용량\n \n-Agents SDK는 각 실행마다 토큰 사용량을 자동으로 추적합니다. 실행 컨텍스트에서 이를 확인하고 비용 모니터링, 제한 적용 또는 분석 기록에 활용할 수 있습니다.\n+Agents SDK는 각 실행마다 토큰 사용량을 자동으로 추적합니다. 실행 컨텍스트에서 접근하여 비용 모니터링, 한도 적용, 분석 기록에 사용할 수 있습니다.\n \n-## 추적되는 항목\n+## 추적 항목\n \n - **requests**: 수행된 LLM API 호출 수\n-- **input_tokens**: 전송된 입력 토큰 총량\n-- **output_tokens**: 수신된 출력 토큰 총량\n+- **input_tokens**: 전송된 총 입력 토큰 수\n+- **output_tokens**: 수신된 총 출력 토큰 수\n - **total_tokens**: 입력 + 출력\n-- **request_usage_entries**: 요청별 사용량 상세 목록\n+- **request_usage_entries**: 요청별 사용량 세부 목록\n - **details**:\n   - `input_tokens_details.cached_tokens`\n   - `output_tokens_details.reasoning_tokens`\n \n-## 실행에서 사용량 접근\n+## 실행에서의 사용량 접근\n \n-`Runner.run(...)` 이후, `result.context_wrapper.usage`를 통해 사용량에 접근합니다.\n+`Runner.run(...)` 이후에는 `result.context_wrapper.usage`로 사용량에 접근합니다.\n \n ```python\n result = await Runner.run(agent, \"What's the weather in Tokyo?\")\n@@ -31,11 +31,11 @@ print(\"Output tokens:\", usage.output_tokens)\n print(\"Total tokens:\", usage.total_tokens)\n ```\n \n-사용량은 실행 중 발생한 모든 모델 호출(도구 호출 및 핸드오프 포함)을 기준으로 집계됩니다.\n+사용량은 실행 중 발생한 모든 모델 호출(도구 호출과 핸드오프 포함)에 걸쳐 집계됩니다.\n \n-### LiteLLM 모델에서 사용량 활성화\n+### LiteLLM 모델에서의 사용량 활성화\n \n-LiteLLM 공급자는 기본적으로 사용량 메트릭을 보고하지 않습니다. [`LitellmModel`](models/litellm.md)을 사용할 때, 에이전트에 `ModelSettings(include_usage=True)`를 전달하여 LiteLLM 응답이 `result.context_wrapper.usage`에 반영되도록 합니다.\n+LiteLLM 공급자는 기본적으로 사용량 메트릭을 보고하지 않습니다. [`LitellmModel`](models/litellm.md)을 사용할 때, 에이전트에 `ModelSettings(include_usage=True)`를 전달하면 LiteLLM 응답이 `result.context_wrapper.usage`에 채워집니다.\n \n ```python\n from agents import Agent, ModelSettings, Runner\n@@ -53,7 +53,7 @@ print(result.context_wrapper.usage.total_tokens)\n \n ## 요청별 사용량 추적\n \n-SDK는 상세 비용 계산 및 컨텍스트 윈도우 소비 모니터링에 유용하도록 각 API 요청의 사용량을 `request_usage_entries`에 자동으로 기록합니다.\n+SDK는 `request_usage_entries`에서 각 API 요청의 사용량을 자동으로 추적하며, 상세 비용 계산과 컨텍스트 윈도우 소모 모니터링에 유용합니다.\n \n ```python\n result = await Runner.run(agent, \"What's the weather in Tokyo?\")\n@@ -62,9 +62,9 @@ for i, request in enumerate(result.context_wrapper.usage.request_usage_entries):\n     print(f\"Request {i + 1}: {request.input_tokens} in, {request.output_tokens} out\")\n ```\n \n-## 세션에서 사용량 접근\n+## 세션에서의 사용량 접근\n \n-`Session`(예: `SQLiteSession`)을 사용할 때, `Runner.run(...)`의 각 호출은 해당 실행에 대한 사용량을 반환합니다. 세션은 컨텍스트 유지를 위해 대화 기록을 보존하지만, 각 실행의 사용량은 독립적입니다.\n+`Session`(예: `SQLiteSession`)을 사용할 때, 각 `Runner.run(...)` 호출은 해당 실행에 대한 사용량을 반환합니다. 세션은 컨텍스트 유지를 위해 대화 기록을 보존하지만, 각 실행의 사용량은 서로 독립적입니다.\n \n ```python\n session = SQLiteSession(\"my_conversation\")\n@@ -76,11 +76,11 @@ second = await Runner.run(agent, \"Can you elaborate?\", session=session)\n print(second.context_wrapper.usage.total_tokens)  # Usage for second run\n ```\n \n-세션은 실행 간 대화 컨텍스트를 보존하지만, 각 `Runner.run()` 호출에서 반환되는 사용량 메트릭은 해당 실행만을 나타냅니다. 세션에서는 이전 메시지가 각 실행의 입력으로 다시 제공될 수 있으며, 이는 이후 턴의 입력 토큰 수에 영향을 줍니다.\n+세션은 실행 간 대화 컨텍스트를 보존하지만, 각 `Runner.run()` 호출이 반환하는 사용량 메트릭은 해당 실행만을 나타냅니다. 세션에서는 이전 메시지가 각 실행의 입력으로 다시 제공될 수 있으며, 이는 이후 턴의 입력 토큰 수에 영향을 줍니다.\n \n-## 훅에서 사용량 활용\n+## 훅에서의 사용량 활용\n \n-`RunHooks`를 사용하는 경우, 각 훅에 전달되는 `context` 객체에 `usage`가 포함됩니다. 이를 통해 주요 라이프사이클 시점에 사용량을 로깅할 수 있습니다.\n+`RunHooks`를 사용하는 경우, 각 훅에 전달되는 `context` 객체에 `usage`가 포함됩니다. 이를 통해 수명주기 핵심 시점에 사용량을 로깅할 수 있습니다.\n \n ```python\n class MyHooks(RunHooks):\n@@ -89,11 +89,11 @@ class MyHooks(RunHooks):\n         print(f\"{agent.name} → {u.requests} requests, {u.total_tokens} total tokens\")\n ```\n \n-## API 레퍼런스\n+## API 참고\n \n 자세한 API 문서는 다음을 참조하세요:\n \n--   [`Usage`][agents.usage.Usage] - 사용량 추적 데이터 구조\n--   [`RequestUsage`][agents.usage.RequestUsage] - 요청별 사용량 상세\n--   [`RunContextWrapper`][agents.run.RunContextWrapper] - 실행 컨텍스트에서 사용량 접근\n--   [`RunHooks`][agents.run.RunHooks] - 사용량 추적 라이프사이클에 훅 연결\n\\ No newline at end of file\n+- [`Usage`][agents.usage.Usage] - 사용량 추적 데이터 구조\n+- [`RequestUsage`][agents.usage.RequestUsage] - 요청별 사용량 상세\n+- [`RunContextWrapper`][agents.run.RunContextWrapper] - 실행 컨텍스트에서 사용량 접근\n+- [`RunHooks`][agents.run.RunHooks] - 사용량 추적 수명주기에 훅 연결\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Fusage.md",
        "sha": "89d3fc029271894c8cbdded1abd1386312b09e0d",
        "status": "modified"
      },
      {
        "additions": 19,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Fvisualization.md",
        "changes": 38,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fko%2Fvisualization.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 19,
        "filename": "docs/ko/visualization.md",
        "patch": "@@ -4,24 +4,24 @@ search:\n ---\n # 에이전트 시각화\n \n-에이전트 시각화는 **Graphviz**를 사용하여 에이전트와 그 관계를 구조적으로 표현한 그래프를 생성합니다. 이는 애플리케이션 내에서 에이전트, 도구, 핸드오프가 어떻게 상호작용하는지 이해하는 데 유용합니다.\n+에이전트 시각화는 **Graphviz**를 사용해 에이전트와 그 관계의 구조적 그래프 표현을 생성합니다. 이는 애플리케이션 내에서 에이전트, 도구, 핸드오프가 어떻게 상호작용하는지 이해하는 데 유용합니다.\n \n ## 설치\n \n-선택적 `viz` 종속성 그룹을 설치하세요:\n+선택적 `viz` 의존성 그룹을 설치하세요:\n \n ```bash\n pip install \"openai-agents[viz]\"\n ```\n \n ## 그래프 생성\n \n-`draw_graph` 함수를 사용하여 에이전트 시각화를 생성할 수 있습니다. 이 함수는 다음과 같은 방향 그래프를 생성합니다:\n+`draw_graph` 함수를 사용해 에이전트 시각화를 생성할 수 있습니다. 이 함수는 다음과 같은 방향 그래프를 생성합니다:\n \n-- **에이전트**는 노란색 상자로 표시됩니다.\n-- **MCP 서버**는 회색 상자로 표시됩니다.\n-- **도구**는 초록색 타원으로 표시됩니다.\n-- **핸드오프**는 한 에이전트에서 다른 에이전트로 향하는 방향 간선으로 표시됩니다.\n+- **에이전트**는 노란색 상자로 표시\n+- **MCP 서버**는 회색 상자로 표시\n+- **도구**는 녹색 타원으로 표시\n+- **핸드오프**는 한 에이전트에서 다른 에이전트로 향하는 방향 간선으로 표시\n \n ### 사용 예시\n \n@@ -69,40 +69,40 @@ draw_graph(triage_agent)\n \n ![Agent Graph](../assets/images/graph.png)\n \n-이는 **triage agent**의 구조와 하위 에이전트 및 도구와의 연결을 시각적으로 표현한 그래프를 생성합니다.\n+이는 **triage agent**의 구조와 하위 에이전트 및 도구와의 연결을 시각적으로 나타내는 그래프를 생성합니다.\n \n \n ## 시각화 이해\n \n 생성된 그래프에는 다음이 포함됩니다:\n \n-- 진입점을 나타내는 **시작 노드** (`__start__`)\n-- 노란색 채우기의 **직사각형**으로 표시되는 에이전트\n-- 초록색 채우기의 **타원**으로 표시되는 도구\n-- 회색 채우기의 **직사각형**으로 표시되는 MCP 서버\n+- 진입점을 나타내는 **시작 노드**(`__start__`)\n+- 노란색 채우기의 **직사각형**으로 표시된 에이전트\n+- 녹색 채우기의 **타원**으로 표시된 도구\n+- 회색 채우기의 **직사각형**으로 표시된 MCP 서버\n - 상호작용을 나타내는 방향 간선:\n   - 에이전트 간 핸드오프는 **실선 화살표**\n   - 도구 호출은 **점선 화살표**\n-  - MCP 서버 호출은 **대시선 화살표**\n-- 실행 종료 지점을 나타내는 **끝 노드** (`__end__`)\n+  - MCP 서버 호출은 **파선 화살표**\n+- 실행 종료 지점을 나타내는 **종료 노드**(`__end__`)\n \n-**참고:** MCP 서버는 최근 버전의\n-`agents` 패키지에서 렌더링됩니다 (**v0.2.8**에서 확인됨). 시각화에 MCP 상자가 보이지 않는 경우 최신 릴리스로 업그레이드하세요.\n+**참고:** MCP 서버는 최신 버전의\n+`agents` 패키지에서 렌더링됩니다(**v0.2.8**에서 확인됨). 시각화에서 MCP 상자가 보이지 않는다면 최신 릴리스로 업그레이드하세요.\n \n ## 그래프 커스터마이징\n \n ### 그래프 표시\n-기본적으로 `draw_graph`는 그래프를 인라인으로 표시합니다. 그래프를 별도 창에서 표시하려면 다음을 작성하세요:\n+기본적으로 `draw_graph`는 그래프를 인라인으로 표시합니다. 그래프를 별도 창으로 표시하려면 다음을 사용하세요:\n \n ```python\n draw_graph(triage_agent).view()\n ```\n \n ### 그래프 저장\n-기본적으로 `draw_graph`는 그래프를 인라인으로 표시합니다. 파일로 저장하려면 파일명을 지정하세요:\n+기본적으로 `draw_graph`는 그래프를 인라인으로 표시합니다. 파일로 저장하려면 파일 이름을 지정하세요:\n \n ```python\n draw_graph(triage_agent, filename=\"agent_graph\")\n ```\n \n-이렇게 하면 작업 디렉터리에 `agent_graph.png`가 생성됩니다.\n\\ No newline at end of file\n+작업 디렉터리에 `agent_graph.png`가 생성됩니다.\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Fvisualization.md",
        "sha": "c8cf656ede56dff9f0e7548543847cfb573655d1",
        "status": "modified"
      },
      {
        "additions": 13,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Fvoice%2Fpipeline.md",
        "changes": 26,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fko%2Fvoice%2Fpipeline.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 13,
        "filename": "docs/ko/voice/pipeline.md",
        "patch": "@@ -4,7 +4,7 @@ search:\n ---\n # 파이프라인과 워크플로\n \n-[`VoicePipeline`][agents.voice.pipeline.VoicePipeline]은 에이전트형 워크플로를 음성 앱으로 손쉽게 전환할 수 있게 해 주는 클래스입니다. 실행할 워크플로를 전달하면, 파이프라인이 입력 오디오를 음성 인식하고, 오디오 종료를 감지하며, 적절한 시점에 워크플로를 호출하고, 워크플로 출력 결과를 다시 오디오로 변환하는 작업을 처리합니다.\n+[`VoicePipeline`][agents.voice.pipeline.VoicePipeline] 클래스는 에이전트 워크플로를 음성 앱으로 손쉽게 전환할 수 있게 해줍니다. 실행할 워크플로를 전달하면, 파이프라인이 입력 오디오 전사, 오디오 종료 시점 감지, 적절한 타이밍에 워크플로 호출, 워크플로 출력을 다시 오디오로 변환하는 작업을 처리합니다\n \n ```mermaid\n graph LR\n@@ -36,25 +36,25 @@ graph LR\n \n 파이프라인을 생성할 때 다음을 설정할 수 있습니다:\n \n-1. 매번 새로운 오디오가 전사될 때 실행되는 코드인 [`workflow`][agents.voice.workflow.VoiceWorkflowBase]\n-2. 사용되는 [`speech-to-text`][agents.voice.model.STTModel] 및 [`text-to-speech`][agents.voice.model.TTSModel] 모델\n-3. 다음과 같은 항목을 구성할 수 있는 [`config`][agents.voice.pipeline_config.VoicePipelineConfig]\n-    - 모델 이름을 실제 모델에 매핑하는 모델 프로바이더\n-    - 트레이싱: 트레이싱 비활성화 여부, 오디오 파일 업로드 여부, 워크플로 이름, 트레이스 ID 등\n-    - TTS 및 STT 모델의 설정: 프롬프트, 언어, 사용하는 데이터 타입 등\n+1. 새 오디오가 전사될 때마다 실행되는 코드인 [`workflow`][agents.voice.workflow.VoiceWorkflowBase]\n+2. 사용할 [`speech-to-text`][agents.voice.model.STTModel] 및 [`text-to-speech`][agents.voice.model.TTSModel] 모델\n+3. 다음과 같은 항목을 설정할 수 있는 [`config`][agents.voice.pipeline_config.VoicePipelineConfig]\n+    - 모델 공급자로, 모델 이름을 실제 모델에 매핑할 수 있음\n+    - 트레이싱으로, 트레이싱 비활성화 여부, 오디오 파일 업로드 여부, 워크플로 이름, 트레이스 ID 등\n+    - TTS 및 STT 모델의 프롬프트, 언어, 사용되는 데이터 타입 등의 설정\n \n ## 파이프라인 실행\n \n-파이프라인은 [`run()`][agents.voice.pipeline.VoicePipeline.run] 메서드로 실행할 수 있으며, 두 가지 형태의 오디오 입력을 전달할 수 있습니다:\n+파이프라인은 [`run()`][agents.voice.pipeline.VoicePipeline.run] 메서드를 통해 실행하며, 오디오 입력을 두 가지 형태로 전달할 수 있습니다:\n \n-1. 전체 오디오 전사가 있을 때 결과만 생성하고자 할 경우 [`AudioInput`][agents.voice.input.AudioInput]을 사용합니다. 이는 화자가 말을 마치는 시점을 감지할 필요가 없는 경우에 유용합니다. 예를 들어, 사전 녹음된 오디오가 있거나, 사용자가 발화를 마치는 시점이 명확한 푸시투토크 앱에서 유용합니다.\n-2. 사용자가 말을 마치는 시점을 감지해야 할 수 있는 경우 [`StreamedAudioInput`][agents.voice.input.StreamedAudioInput]을 사용합니다. 감지되는 대로 오디오 청크를 푸시할 수 있으며, 음성 파이프라인은 \"activity detection\"이라고 하는 프로세스를 통해 적절한 시점에 에이전트 워크플로를 자동으로 실행합니다.\n+1. [`AudioInput`][agents.voice.input.AudioInput] 은 전체 오디오 발화가 준비되어 있고 그 결과만 생성하면 되는 경우에 사용합니다. 이는 화자가 발화를 마쳤는지 감지할 필요가 없는 상황, 예를 들어 사전 녹음된 오디오나 푸시투토크 앱처럼 사용자의 발화 종료가 명확한 경우에 유용합니다\n+2. [`StreamedAudioInput`][agents.voice.input.StreamedAudioInput] 은 사용자의 발화 종료를 감지해야 할 수 있는 경우에 사용합니다. 오디오 청크를 감지되는 대로 푸시할 수 있으며, 음성 파이프라인이 \"activity detection\" 과정을 통해 적절한 시점에 에이전트 워크플로를 자동으로 실행합니다\n \n ## 결과\n \n-음성 파이프라인 실행 결과는 [`StreamedAudioResult`][agents.voice.result.StreamedAudioResult]입니다. 이는 발생하는 이벤트를 스트리밍할 수 있게 해 주는 객체입니다. 다음과 같은 여러 종류의 [`VoiceStreamEvent`][agents.voice.events.VoiceStreamEvent]가 있습니다:\n+음성 파이프라인 실행 결과는 [`StreamedAudioResult`][agents.voice.result.StreamedAudioResult] 입니다. 이는 이벤트가 발생하는 대로 스트리밍할 수 있는 객체입니다. [`VoiceStreamEvent`][agents.voice.events.VoiceStreamEvent] 는 다음과 같은 종류가 있습니다:\n \n-1. 오디오 청크를 포함하는 [`VoiceStreamEventAudio`][agents.voice.events.VoiceStreamEventAudio]\n+1. 오디오 청크를 담는 [`VoiceStreamEventAudio`][agents.voice.events.VoiceStreamEventAudio]\n 2. 턴 시작/종료와 같은 라이프사이클 이벤트를 알려주는 [`VoiceStreamEventLifecycle`][agents.voice.events.VoiceStreamEventLifecycle]\n 3. 오류 이벤트인 [`VoiceStreamEventError`][agents.voice.events.VoiceStreamEventError]\n \n@@ -76,4 +76,4 @@ async for event in result.stream():\n \n ### 인터럽션(중단 처리)\n \n-Agents SDK는 현재 [`StreamedAudioInput`][agents.voice.input.StreamedAudioInput]에 대한 내장 인터럽션(중단 처리) 지원을 제공하지 않습니다. 대신 감지된 각 턴마다 워크플로의 별도 실행을 트리거합니다. 애플리케이션 내부에서 인터럽션을 처리하려면 [`VoiceStreamEventLifecycle`][agents.voice.events.VoiceStreamEventLifecycle] 이벤트를 구독하면 됩니다. `turn_started`는 새로운 턴이 전사되어 처리가 시작되었음을 나타냅니다. `turn_ended`는 해당 턴의 모든 오디오가 전송된 후 트리거됩니다. 이러한 이벤트를 사용해 모델이 턴을 시작할 때 화자의 마이크를 음소거하고, 해당 턴과 관련된 오디오를 모두 플러시한 후 음소거를 해제할 수 있습니다.\n\\ No newline at end of file\n+Agents SDK 는 현재 [`StreamedAudioInput`][agents.voice.input.StreamedAudioInput] 에 대해 내장된 인터럽션(중단 처리) 기능을 지원하지 않습니다. 대신 감지된 각 턴에 대해 워크플로를 별도로 실행합니다. 애플리케이션 내에서 중단 처리를 하고 싶다면 [`VoiceStreamEventLifecycle`][agents.voice.events.VoiceStreamEventLifecycle] 이벤트를 청취할 수 있습니다. `turn_started` 는 새 턴이 전사되어 처리가 시작됨을 나타냅니다. `turn_ended` 는 해당 턴의 모든 오디오가 전송된 후에 트리거됩니다. 이러한 이벤트를 사용해 모델이 턴을 시작할 때 화자의 마이크를 음소거하고, 해당 턴에 대한 관련 오디오를 모두 전송한 뒤 음소거를 해제할 수 있습니다\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Fvoice%2Fpipeline.md",
        "sha": "56d090821e82ee702373477264a30a652f27592b",
        "status": "modified"
      },
      {
        "additions": 9,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Fvoice%2Fquickstart.md",
        "changes": 18,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fko%2Fvoice%2Fquickstart.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 9,
        "filename": "docs/ko/voice/quickstart.md",
        "patch": "@@ -6,19 +6,19 @@ search:\n \n ## 사전 준비\n \n-Agents SDK의 기본 [빠른 시작 지침](../quickstart.md)을 따라 가상 환경을 설정했는지 확인하세요. 그런 다음, SDK에서 선택적인 음성 관련 종속성을 설치하세요:\n+Agents SDK의 기본 [빠른 시작 지침](../quickstart.md)을 따라 가상 환경을 설정했는지 확인하세요. 그런 다음 SDK에서 선택적 음성 의존성을 설치하세요:\n \n ```bash\n pip install 'openai-agents[voice]'\n ```\n \n ## 개념\n \n-핵심 개념은 [`VoicePipeline`][agents.voice.pipeline.VoicePipeline]이며, 이는 3단계 프로세스입니다:\n+핵심 개념은 [`VoicePipeline`][agents.voice.pipeline.VoicePipeline]이며, 3단계 프로세스입니다:\n \n-1. 음성을 텍스트로 변환하기 위해 음성-텍스트 모델을 실행합니다.\n-2. 보통 에이전트 워크플로우인 여러분의 코드를 실행해 결과를 생성합니다.\n-3. 결과 텍스트를 다시 음성으로 변환하기 위해 텍스트-음성 모델을 실행합니다.\n+1. 음성을 텍스트로 변환하기 위해 음성 인식 모델을 실행\n+2. 일반적으로 에이전트형 워크플로인 코드를 실행해 결과 생성\n+3. 결과 텍스트를 다시 음성으로 변환하기 위해 음성 합성 모델을 실행\n \n ```mermaid\n graph LR\n@@ -48,7 +48,7 @@ graph LR\n \n ## 에이전트\n \n-먼저 에이전트를 설정해 보겠습니다. 이 SDK로 에이전트를 만들어 본 적이 있다면 익숙하게 느껴질 것입니다. 에이전트 몇 개와 핸드오프, 그리고 하나의 도구를 사용합니다.\n+먼저 에이전트를 몇 개 설정해 보겠습니다. 이 SDK로 에이전트를 만들어 본 적이 있다면 익숙할 것입니다. 에이전트 몇 개, 핸드오프, 그리고 도구 하나를 사용합니다.\n \n ```python\n import asyncio\n@@ -92,7 +92,7 @@ agent = Agent(\n \n ## 음성 파이프라인\n \n-워크플로우로 [`SingleAgentVoiceWorkflow`][agents.voice.workflow.SingleAgentVoiceWorkflow]를 사용해 간단한 음성 파이프라인을 설정하겠습니다.\n+워크플로로 [`SingleAgentVoiceWorkflow`][agents.voice.workflow.SingleAgentVoiceWorkflow]를 사용하여 간단한 음성 파이프라인을 설정하겠습니다.\n \n ```python\n from agents.voice import SingleAgentVoiceWorkflow, VoicePipeline\n@@ -124,7 +124,7 @@ async for event in result.stream():\n \n ```\n \n-## 모두 통합\n+## 전체 통합\n \n ```python\n import asyncio\n@@ -195,4 +195,4 @@ if __name__ == \"__main__\":\n     asyncio.run(main())\n ```\n \n-이 예제를 실행하면 에이전트가 직접 말합니다! 직접 에이전트와 대화할 수 있는 데모는 [examples/voice/static](https://github.com/openai/openai-agents-python/tree/main/examples/voice/static)에서 확인하세요.\n\\ No newline at end of file\n+이 예제를 실행하면 에이전트가 직접 말해 줍니다! 직접 에이전트와 대화해 볼 수 있는 데모는 [examples/voice/static](https://github.com/openai/openai-agents-python/tree/main/examples/voice/static)에서 확인하세요.\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Fvoice%2Fquickstart.md",
        "sha": "b3602762d2cb8cfa69ff68c5d5fa8504d27d0700",
        "status": "modified"
      },
      {
        "additions": 8,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Fvoice%2Ftracing.md",
        "changes": 16,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fko%2Fvoice%2Ftracing.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 8,
        "filename": "docs/ko/voice/tracing.md",
        "patch": "@@ -4,15 +4,15 @@ search:\n ---\n # 트레이싱\n \n-[에이전트가 트레이싱되는 방식](../tracing.md)과 마찬가지로, 음성 파이프라인도 자동으로 트레이싱됩니다.\n+[에이전트 트레이싱 방식](../tracing.md)과 마찬가지로, 음성 파이프라인도 자동으로 트레이싱됩니다.\n \n-위의 트레이싱 문서에서 기본 트레이싱 정보를 확인할 수 있으며, 추가로 [`VoicePipelineConfig`][agents.voice.pipeline_config.VoicePipelineConfig]를 통해 파이프라인의 트레이싱을 구성할 수 있습니다.\n+기본적인 트레이싱 정보는 위 문서를 참고하시되, 추가로 [`VoicePipelineConfig`][agents.voice.pipeline_config.VoicePipelineConfig]를 통해 파이프라인의 트레이싱을 구성할 수 있습니다.\n \n-주요 트레이싱 관련 필드는 다음과 같습니다:\n+트레이싱과 관련된 핵심 필드는 다음과 같습니다:\n \n--   [`tracing_disabled`][agents.voice.pipeline_config.VoicePipelineConfig.tracing_disabled]: 트레이싱 비활성화 여부를 제어합니다. 기본값은 트레이싱 활성화입니다.\n--   [`trace_include_sensitive_data`][agents.voice.pipeline_config.VoicePipelineConfig.trace_include_sensitive_data]: 오디오 전사와 같은 민감할 수 있는 데이터 포함 여부를 제어합니다. 이는 음성 파이프라인에만 적용되며, 워크플로 내부에서 발생하는 사항에는 적용되지 않습니다.\n--   [`trace_include_sensitive_audio_data`][agents.voice.pipeline_config.VoicePipelineConfig.trace_include_sensitive_audio_data]: 오디오 데이터 포함 여부를 제어합니다.\n--   [`workflow_name`][agents.voice.pipeline_config.VoicePipelineConfig.workflow_name]: 트레이스 워크플로의 이름입니다.\n--   [`group_id`][agents.voice.pipeline_config.VoicePipelineConfig.group_id]: 여러 트레이스를 연결할 수 있게 하는 트레이스의 `group_id`입니다.\n+-   [`tracing_disabled`][agents.voice.pipeline_config.VoicePipelineConfig.tracing_disabled]: 트레이싱 비활성화 여부를 제어합니다. 기본적으로 트레이싱은 활성화되어 있습니다.\n+-   [`trace_include_sensitive_data`][agents.voice.pipeline_config.VoicePipelineConfig.trace_include_sensitive_data]: 오디오 전사와 같은 잠재적으로 민감한 데이터 포함 여부를 제어합니다. 이는 음성 파이프라인에만 적용되며, Workflow 내부에서 일어나는 작업에는 적용되지 않습니다.\n+-   [`trace_include_sensitive_audio_data`][agents.voice.pipeline_config.VoicePipelineConfig.trace_include_sensitive_audio_data]: 트레이스에 오디오 데이터를 포함할지 여부를 제어합니다.\n+-   [`workflow_name`][agents.voice.pipeline_config.VoicePipelineConfig.workflow_name]: 트레이스 워크플로 이름입니다.\n+-   [`group_id`][agents.voice.pipeline_config.VoicePipelineConfig.group_id]: 여러 트레이스를 연결할 수 있도록 하는 트레이스의 `group_id` 입니다.\n -   [`trace_metadata`][agents.voice.pipeline_config.VoicePipelineConfig.tracing_disabled]: 트레이스에 포함할 추가 메타데이터입니다.\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fko%2Fvoice%2Ftracing.md",
        "sha": "3f287695d533f235e02c088fd48bf1e705fa1cbc",
        "status": "modified"
      },
      {
        "additions": 32,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Fagents.md",
        "changes": 64,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fzh%2Fagents.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 32,
        "filename": "docs/zh/agents.md",
        "patch": "@@ -4,16 +4,16 @@ search:\n ---\n # 智能体\n \n-智能体是应用中的核心构建块。一个智能体是经过配置的指令和工具的大型语言模型（LLM）。\n+智能体是应用中的核心构建单元。一个智能体是经过 instructions 和 tools 配置的大型语言模型（LLM）。\n \n ## 基本配置\n \n-你最常配置的智能体属性包括：\n+你最常为智能体配置的属性包括：\n \n-- `name`: 标识智能体的必填字符串。\n-- `instructions`: 也称为开发者消息或系统提示词（system prompt）。\n-- `model`: 要使用的 LLM，以及可选的 `model_settings` 用于配置如 temperature、top_p 等模型调参。\n-- `tools`: 智能体为完成任务可使用的工具。\n+- `name`：标识智能体的必填字符串。\n+- `instructions`：也称为开发者消息或系统提示词（system prompt）。\n+- `model`：指定要使用的 LLM，并可选通过 `model_settings` 配置如 temperature、top_p 等模型调参。\n+- `tools`：智能体为完成任务可调用的工具。\n \n ```python\n from agents import Agent, ModelSettings, function_tool\n@@ -33,7 +33,7 @@ agent = Agent(\n \n ## 上下文\n \n-智能体在其 `context` 类型上是泛型的。Context 是一种依赖注入工具：它是你创建并传递给 `Runner.run()` 的对象，会传递给每个智能体、工具、任务转移等，用作本次运行所需依赖与状态的集合。你可以提供任意 Python 对象作为 context。\n+智能体在其 `context` 类型上是泛型的。Context 是一种依赖注入工具：你创建一个对象并传给 `Runner.run()`，它会被传递给每个智能体、工具、任务转移等，用作本次运行的依赖与状态的集合。你可以提供任意 Python 对象作为 context。\n \n ```python\n @dataclass\n@@ -52,7 +52,7 @@ agent = Agent[UserContext](\n \n ## 输出类型\n \n-默认情况下，智能体产生纯文本（即 `str`）输出。如果你希望智能体产生特定类型的输出，可以使用 `output_type` 参数。常见选择是使用 [Pydantic](https://docs.pydantic.dev/) 对象，但我们支持任何可以被 Pydantic [TypeAdapter](https://docs.pydantic.dev/latest/api/type_adapter/) 包装的类型——dataclasses、list、TypedDict 等。\n+默认情况下，智能体生成纯文本（即 `str`）输出。若你希望智能体产出特定类型的结果，可使用 `output_type` 参数。常见做法是使用 [Pydantic](https://docs.pydantic.dev/) 对象，但我们支持任何可以由 Pydantic [TypeAdapter](https://docs.pydantic.dev/latest/api/type_adapter/) 包装的类型——如 dataclasses、list、TypedDict 等。\n \n ```python\n from pydantic import BaseModel\n@@ -73,20 +73,20 @@ agent = Agent(\n \n !!! note\n \n-    当你传入 `output_type` 时，这会指示模型使用 [structured outputs](https://platform.openai.com/docs/guides/structured-outputs) 而不是常规的纯文本响应。\n+    当你传入 `output_type` 时，这会指示模型使用 [structured outputs](https://platform.openai.com/docs/guides/structured-outputs) 而非普通纯文本响应。\n \n ## 多智能体系统设计模式\n \n-设计多智能体系统的方法很多，但我们常见的两种广泛适用的模式是：\n+设计多智能体系统的方法很多，但我们常见的两种通用模式是：\n \n-1. 管理器（智能体作为工具）：一个中心管理者/编排者将专业化的子智能体作为工具调用，并保持对对话的控制。\n-2. 任务转移：对等智能体将控制权交给接管对话的专业智能体。这是去中心化的。\n+1. 管理者（智能体作为工具）：中心管理者/编排器将专业子智能体作为工具调用，并始终掌控对话。\n+2. 任务转移：对等智能体将控制权移交给一个专业智能体，由其接管对话。这是去中心化的。\n \n-详见[我们的智能体构建实用指南](https://cdn.openai.com/business-guides-and-resources/a-practical-guide-to-building-agents.pdf)。\n+详见[构建智能体的实用指南](https://cdn.openai.com/business-guides-and-resources/a-practical-guide-to-building-agents.pdf)。\n \n-### 管理器（智能体作为工具）\n+### 管理者（智能体作为工具）\n \n-`customer_facing_agent` 处理所有用户交互，并调用作为工具暴露的专业化子智能体。更多内容参见 [tools](tools.md#agents-as-tools) 文档。\n+`customer_facing_agent` 负责所有用户交互，并调用以工具形式暴露的专业子智能体。详见[工具](tools.md#agents-as-tools)文档。\n \n ```python\n from agents import Agent\n@@ -115,7 +115,7 @@ customer_facing_agent = Agent(\n \n ### 任务转移\n \n-任务转移是智能体可以委派的子智能体。当发生任务转移时，被委派的智能体会接收对话历史并接管对话。该模式支持模块化、专长化、擅长单一任务的智能体。更多内容参见 [handoffs](handoffs.md) 文档。\n+任务转移是智能体可委派的子智能体。当发生任务转移时，被委派的智能体会接收对话历史并接管对话。该模式支持模块化、专精于单一任务的智能体。详见[任务转移](handoffs.md)文档。\n \n ```python\n from agents import Agent\n@@ -134,9 +134,9 @@ triage_agent = Agent(\n )\n ```\n \n-## 动态指令\n+## 动态 instructions\n \n-在大多数情况下，你可以在创建智能体时提供指令。不过，你也可以通过函数提供动态指令。该函数会接收智能体和上下文，并且必须返回提示词。支持常规和 `async` 函数。\n+多数情况下，你可在创建智能体时提供 instructions。不过，你也可以通过函数动态提供 instructions。该函数会接收智能体与 context，并且必须返回提示词。同步与 `async` 函数均可。\n \n ```python\n def dynamic_instructions(\n@@ -151,17 +151,17 @@ agent = Agent[UserContext](\n )\n ```\n \n-## 生命周期事件（hooks）\n+## 生命周期事件（钩子）\n \n-有时你希望观察智能体的生命周期。例如，你可能希望记录事件，或在某些事件发生时预取数据。你可以通过 `hooks` 属性挂接智能体生命周期。继承 [`AgentHooks`][agents.lifecycle.AgentHooks] 类，并重写你感兴趣的方法。\n+有时你需要观察智能体的生命周期。例如，你可能希望记录事件，或在特定事件发生时预取数据。你可以通过 `hooks` 属性挂接到智能体生命周期。继承 [`AgentHooks`][agents.lifecycle.AgentHooks] 类，并重写你感兴趣的方法。\n \n ## 安全防护措施\n \n-安全防护措施允许你在智能体运行的同时并行地对用户输入进行检查/验证，并在智能体产生输出后对其进行检查。例如，你可以筛查用户输入与智能体输出的相关性。更多内容参见 [guardrails](guardrails.md) 文档。\n+安全防护措施允许你在智能体运行的同时对用户输入进行检查/校验，并在产生输出后对其进行检查。例如，你可以同时筛查用户输入与智能体输出的相关性。详见[安全防护措施](guardrails.md)文档。\n \n ## 克隆/复制智能体\n \n-通过在智能体上使用 `clone()` 方法，你可以复制一个智能体，并可选地修改任意属性。\n+通过在智能体上使用 `clone()` 方法，你可以复制一个智能体，并可选地更改任意属性。\n \n ```python\n pirate_agent = Agent(\n@@ -178,12 +178,12 @@ robot_agent = pirate_agent.clone(\n \n ## 强制使用工具\n \n-提供工具列表并不总意味着 LLM 会使用某个工具。你可以通过设置 [`ModelSettings.tool_choice`][agents.model_settings.ModelSettings.tool_choice] 来强制使用工具。可用取值为：\n+提供工具列表并不总能让 LLM 实际使用工具。你可以通过设置 [`ModelSettings.tool_choice`][agents.model_settings.ModelSettings.tool_choice] 来强制工具使用。可用值为：\n \n 1. `auto`，允许 LLM 自行决定是否使用工具。\n-2. `required`，要求 LLM 使用某个工具（但它可以智能地决定使用哪个工具）。\n-3. `none`，要求 LLM 不使用工具。\n-4. 设置特定字符串，例如 `my_tool`，要求 LLM 使用该特定工具。\n+2. `required`，要求 LLM 必须使用工具（但可智能选择具体工具）。\n+3. `none`，要求 LLM 不得使用工具。\n+4. 指定某个字符串，例如 `my_tool`，要求 LLM 使用该特定工具。\n \n ```python\n from agents import Agent, Runner, function_tool, ModelSettings\n@@ -203,10 +203,10 @@ agent = Agent(\n \n ## 工具使用行为\n \n-`Agent` 配置中的 `tool_use_behavior` 参数控制如何处理工具输出：\n+`Agent` 配置中的 `tool_use_behavior` 参数控制工具输出的处理方式：\n \n-- `\"run_llm_again\"`：默认值。工具运行后，LLM 处理结果以生成最终响应。\n-- `\"stop_on_first_tool\"`：首次工具调用的输出即作为最终响应，不再经过 LLM 处理。\n+- `\"run_llm_again\"`：默认值。工具运行后，LLM 会处理其结果以生成最终响应。\n+- `\"stop_on_first_tool\"`：首次工具调用的输出将作为最终响应，不再进行后续 LLM 处理。\n \n ```python\n from agents import Agent, Runner, function_tool, ModelSettings\n@@ -224,7 +224,7 @@ agent = Agent(\n )\n ```\n \n-- `StopAtTools(stop_at_tool_names=[...])`：若调用了任一指定工具则停止，使用其输出作为最终响应。\n+- `StopAtTools(stop_at_tool_names=[...])`：若调用了任一指定工具则停止，并使用其输出作为最终响应。\n \n ```python\n from agents import Agent, Runner, function_tool\n@@ -248,7 +248,7 @@ agent = Agent(\n )\n ```\n \n-- `ToolsToFinalOutputFunction`：自定义函数，用于处理工具结果并决定是停止还是继续由 LLM 处理。\n+- `ToolsToFinalOutputFunction`：自定义函数，用于处理工具结果并决定是停止还是继续交由 LLM。\n \n ```python\n from agents import Agent, Runner, function_tool, FunctionToolResult, RunContextWrapper\n@@ -286,4 +286,4 @@ agent = Agent(\n \n !!! note\n \n-    为防止无限循环，框架会在一次工具调用后自动将 `tool_choice` 重置为 \"auto\"。该行为可通过 [`agent.reset_tool_choice`][agents.agent.Agent.reset_tool_choice] 配置。出现无限循环的原因是工具结果会被送回 LLM，而由于设置了 `tool_choice`，LLM 又会生成另一次工具调用，如此反复。\n\\ No newline at end of file\n+    为防止无限循环，框架会在一次工具调用后自动将 `tool_choice` 重置为 \"auto\"。可通过 [`agent.reset_tool_choice`][agents.agent.Agent.reset_tool_choice] 配置此行为。出现无限循环的原因是工具结果会发送回 LLM，而由于 `tool_choice` 的设置，LLM 会再次生成工具调用，如此往复。\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Fagents.md",
        "sha": "8a7ae8fea1d76e5d4df6160c9927e665392f3a9a",
        "status": "modified"
      },
      {
        "additions": 24,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Fconfig.md",
        "changes": 36,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fzh%2Fconfig.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 12,
        "filename": "docs/zh/config.md",
        "patch": "@@ -2,19 +2,19 @@\n search:\n   exclude: true\n ---\n-# 配置 SDK\n+# SDK 配置\n \n ## API 密钥与客户端\n \n-默认情况下，SDK 在被导入后会立即从环境变量 `OPENAI_API_KEY` 中读取用于 LLM 请求与追踪（tracing）的密钥。如果你无法在应用启动前设置该环境变量，可以使用 [set_default_openai_key()][agents.set_default_openai_key] 函数来设置密钥。\n+默认情况下，SDK 在导入后会立即从环境变量 `OPENAI_API_KEY` 中读取密钥，用于 LLM 请求和追踪。如果你无法在应用启动前设置该环境变量，可以使用 [set_default_openai_key()][agents.set_default_openai_key] 函数来设置密钥。\n \n ```python\n from agents import set_default_openai_key\n \n set_default_openai_key(\"sk-...\")\n ```\n \n-或者，你也可以配置要使用的 OpenAI 客户端。默认情况下，SDK 会基于环境变量中的 API 密钥或上述设置的默认密钥创建一个 `AsyncOpenAI` 实例。你可以使用 [set_default_openai_client()][agents.set_default_openai_client] 函数进行修改。\n+或者，你也可以配置要使用的 OpenAI 客户端。默认情况下，SDK 会创建一个 `AsyncOpenAI` 实例，使用环境变量中的 API 密钥或上面设置的默认密钥。你可以通过 [set_default_openai_client()][agents.set_default_openai_client] 函数进行更改。\n \n ```python\n from openai import AsyncOpenAI\n@@ -24,7 +24,7 @@ custom_client = AsyncOpenAI(base_url=\"...\", api_key=\"...\")\n set_default_openai_client(custom_client)\n ```\n \n-最后，你也可以自定义所使用的 OpenAI API。默认使用 OpenAI Responses API。你可以通过 [set_default_openai_api()][agents.set_default_openai_api] 函数改为使用 Chat Completions API。\n+最后，你还可以自定义所使用的 OpenAI API。默认情况下，我们使用 OpenAI Responses API。你可以通过 [set_default_openai_api()][agents.set_default_openai_api] 函数覆盖为使用 Chat Completions API。\n \n ```python\n from agents import set_default_openai_api\n@@ -34,15 +34,27 @@ set_default_openai_api(\"chat_completions\")\n \n ## 追踪\n \n-追踪默认启用。默认情况下，它会使用上文提到的 OpenAI API 密钥（即环境变量或你设置的默认密钥）。你可以使用 [`set_tracing_export_api_key`][agents.set_tracing_export_api_key] 函数专门设置用于追踪的 API 密钥。\n+追踪默认启用。它默认使用上文的 OpenAI API 密钥（即环境变量或你设置的默认密钥）。你可以通过 [`set_tracing_export_api_key`][agents.set_tracing_export_api_key] 函数专门设置用于追踪的 API 密钥。\n \n ```python\n from agents import set_tracing_export_api_key\n \n set_tracing_export_api_key(\"sk-...\")\n ```\n \n-你也可以使用 [`set_tracing_disabled()`][agents.set_tracing_disabled] 函数完全禁用追踪。\n+你也可以在每次运行时设置一个追踪 API 密钥，而无需更改全局导出器。\n+\n+```python\n+from agents import Runner, RunConfig\n+\n+await Runner.run(\n+    agent,\n+    input=\"Hello\",\n+    run_config=RunConfig(tracing={\"api_key\": \"sk-tracing-123\"}),\n+)\n+```\n+\n+你还可以通过 [`set_tracing_disabled()`][agents.set_tracing_disabled] 函数完全禁用追踪。\n \n ```python\n from agents import set_tracing_disabled\n@@ -52,17 +64,17 @@ set_tracing_disabled(True)\n \n ## 调试日志\n \n-该 SDK 提供两个未配置任何 handler 的 Python 日志记录器。默认情况下，这意味着警告与错误会输出到 `stdout`，而其他日志会被抑制。\n+该 SDK 提供了两个未设置任何处理器的 Python 日志记录器。默认情况下，这意味着警告和错误会发送到 `stdout`，但其他日志会被抑制。\n \n-要启用详细日志，请使用 [`enable_verbose_stdout_logging()`][agents.enable_verbose_stdout_logging] 函数。\n+如需启用详细日志，请使用 [`enable_verbose_stdout_logging()`][agents.enable_verbose_stdout_logging] 函数。\n \n ```python\n from agents import enable_verbose_stdout_logging\n \n enable_verbose_stdout_logging()\n ```\n \n-或者，你也可以通过添加 handlers、filters、formatters 等来自定义日志。更多信息可参阅 [Python 日志指南](https://docs.python.org/3/howto/logging.html)。\n+或者，你可以通过添加处理器、过滤器、格式化器等自定义日志。更多内容见 [Python logging guide](https://docs.python.org/3/howto/logging.html)。\n \n ```python\n import logging\n@@ -83,15 +95,15 @@ logger.addHandler(logging.StreamHandler())\n \n ### 日志中的敏感数据\n \n-某些日志可能包含敏感数据（例如，用户数据）。如果你希望禁止记录这些数据，请设置以下环境变量。\n+某些日志可能包含敏感数据（例如，用户数据）。若要禁止记录这些数据，请设置以下环境变量。\n \n-要禁用记录 LLM 的输入与输出：\n+要禁用记录 LLM 的输入和输出：\n \n ```bash\n export OPENAI_AGENTS_DONT_LOG_MODEL_DATA=1\n ```\n \n-要禁用记录工具的输入与输出：\n+要禁用记录工具的输入和输出：\n \n ```bash\n export OPENAI_AGENTS_DONT_LOG_TOOL_DATA=1",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Fconfig.md",
        "sha": "35a5793766925e6cefa19aa0bb9d56799d736fc6",
        "status": "modified"
      },
      {
        "additions": 28,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Fcontext.md",
        "changes": 56,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fzh%2Fcontext.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 28,
        "filename": "docs/zh/context.md",
        "patch": "@@ -4,30 +4,30 @@ search:\n ---\n # 上下文管理\n \n-“上下文”一词含义广泛。你可能关心的上下文主要有两类：\n+“上下文”是一个含义广泛的术语。通常你会关心两类主要的上下文：\n \n-1. 代码本地可用的上下文：这是在工具函数运行时、`on_handoff` 等回调、生命周期钩子中可能需要的数据和依赖。\n-2. LLM 可用的上下文：这是 LLM 在生成回复时可见的数据。\n+1. 代码本地可用的上下文：这是工具函数运行时、`on_handoff` 等回调、生命周期钩子等所需的数据与依赖。\n+2. LLM 可用的上下文：这是 LLM 在生成响应时能够看到的数据。\n \n ## 本地上下文\n \n-这通过 [`RunContextWrapper`][agents.run_context.RunContextWrapper] 类以及其中的 [`context`][agents.run_context.RunContextWrapper.context] 属性来表示。工作方式如下：\n+这通过 [`RunContextWrapper`][agents.run_context.RunContextWrapper] 类及其内部的 [`context`][agents.run_context.RunContextWrapper.context] 属性来表示。其工作方式为：\n \n-1. 创建任意你想要的 Python 对象。常见做法是使用 dataclass 或 Pydantic 对象。\n-2. 将该对象传给各种运行方法（例如 `Runner.run(..., **context=whatever**)`）。\n-3. 你所有的工具调用、生命周期钩子等都会接收到一个包装对象 `RunContextWrapper[T]`，其中 `T` 表示你的上下文对象类型，你可以通过 `wrapper.context` 访问。\n+1. 你创建任意 Python 对象。常见做法是使用 dataclass 或 Pydantic 对象。\n+2. 将该对象传递给各类运行方法（例如 `Runner.run(..., **context=whatever**)`）。\n+3. 你的所有工具调用、生命周期钩子等都会接收一个包装对象 `RunContextWrapper[T]`，其中 `T` 表示你的上下文对象类型，可通过 `wrapper.context` 访问。\n \n-需要注意的最重要的一点：对于一次给定的智能体运行，所有智能体、工具函数、生命周期等都必须使用相同类型的上下文。\n+需要格外注意的**最重要**一点：某次智能体运行中的每个智能体、工具函数、生命周期等，必须使用相同_类型_的上下文。\n \n-你可以将上下文用于以下场景：\n+你可以将上下文用于：\n \n--  该次运行的情境化数据（例如用户名/uid 或关于用户的其他信息）\n--  依赖项（例如日志记录器对象、数据获取器等）\n--  帮助函数\n+- 运行的情境化数据（例如用户名/uid 或其他关于用户的信息）\n+- 依赖项（例如日志记录器对象、数据获取器等）\n+- 帮助函数\n \n !!! danger \"注意\"\n \n-    该上下文对象并不会发送给 LLM。它纯粹是一个本地对象，你可以读取、写入并在其上调用方法。\n+    上下文对象**不会**发送给 LLM。它纯粹是一个本地对象，你可以读取、写入并在其上调用方法。\n \n ```python\n import asyncio\n@@ -66,17 +66,17 @@ if __name__ == \"__main__\":\n     asyncio.run(main())\n ```\n \n-1. 这是上下文对象。我们这里使用了 dataclass，但你可以使用任何类型。\n-2. 这是一个工具。你可以看到它接收 `RunContextWrapper[UserInfo]`。工具实现会从上下文中读取。\n-3. 我们在智能体上标注了泛型 `UserInfo`，以便类型检查器能捕获错误（例如，如果我们尝试传入一个接收不同上下文类型的工具）。\n-4. 将上下文传递给 `run` 函数。\n+1. 这是上下文对象。这里使用了 dataclass，但你可以使用任何类型。\n+2. 这是一个工具。你可以看到它接收 `RunContextWrapper[UserInfo]`。工具实现会从上下文中读取数据。\n+3. 我们用泛型 `UserInfo` 标注智能体，以便类型检查器能捕获错误（例如，如果我们尝试传入一个使用不同上下文类型的工具）。\n+4. 通过 `run` 函数传入上下文。\n 5. 智能体正确调用工具并获取年龄。\n \n ---\n \n-### 高级：`ToolContext`\n+### 进阶：`ToolContext`\n \n-在某些情况下，你可能希望访问关于正在执行的工具的额外元数据——例如其名称、调用 ID 或原始参数字符串。  \n+在某些情况下，你可能希望访问正在执行的工具的额外元数据——例如其名称、调用 ID 或原始参数字符串。  \n 为此，你可以使用扩展自 `RunContextWrapper` 的 [`ToolContext`][agents.tool_context.ToolContext] 类。\n \n ```python\n@@ -106,22 +106,22 @@ agent = Agent(\n ```\n \n `ToolContext` 提供与 `RunContextWrapper` 相同的 `.context` 属性，  \n-并额外包含针对当前工具调用的字段：\n+并额外包含与当前工具调用相关的字段：\n \n-- `tool_name` – 正在调用的工具名称  \n+- `tool_name` – 被调用工具的名称  \n - `tool_call_id` – 此次工具调用的唯一标识符  \n-- `tool_arguments` – 传给工具的原始参数字符串  \n+- `tool_arguments` – 传递给工具的原始参数字符串  \n \n-当你在执行期间需要工具级元数据时，请使用 `ToolContext`。  \n+当你在执行过程中需要工具层级元数据时，使用 `ToolContext`。  \n 对于智能体与工具之间的一般上下文共享，`RunContextWrapper` 已经足够。\n \n ---\n \n ## 智能体/LLM 上下文\n \n-当调用 LLM 时，它能看到的唯一数据来自对话历史。这意味着如果你希望让一些新数据对 LLM 可见，你必须以一种方式将其纳入该历史中。常见方式包括：\n+当调用 LLM 时，它能看到的**唯一**数据来自对话历史。因此，如果你希望让 LLM 获取新的数据，必须以使其出现在该历史中的方式提供。有几种方法：\n \n-1. 将其添加到智能体的 `instructions`。这也被称为“系统提示词”或“开发者消息”。系统提示词可以是静态字符串，也可以是接收上下文并输出字符串的动态函数。这对于始终有用的信息很常见（例如用户名或当前日期）。\n-2. 在调用 `Runner.run` 函数时将其添加到 `input`。这与 `instructions` 策略类似，但允许你放置更处于[指挥链](https://cdn.openai.com/spec/model-spec-2024-05-08.html#follow-the-chain-of-command)更低位置的消息。\n-3. 通过 工具调用 暴露。这对按需上下文很有用——LLM 决定何时需要某些数据，并可调用工具以获取该数据。\n-4. 使用 文件检索 或 网络检索。这些是能够从文件或数据库（文件检索）或从网络（网络检索）中获取相关数据的特殊工具。这对于将回复“锚定”在相关上下文数据上很有用。\n\\ No newline at end of file\n+1. 将其添加到智能体的 `instructions`。这也被称为“系统提示词”或“开发者消息”。系统提示词可以是静态字符串，也可以是接收上下文并输出字符串的动态函数。这是对总是有用的信息（例如用户名或当前日期）常用的策略。\n+2. 在调用 `Runner.run` 函数时添加到 `input` 中。这与 `instructions` 的策略类似，但允许你将消息放在[指令链](https://cdn.openai.com/spec/model-spec-2024-05-08.html#follow-the-chain-of-command)的更低位置。\n+3. 通过 工具调用 暴露。这对于_按需_上下文很有用——LLM 会在需要某些数据时自行决定，并调用工具获取该数据。\n+4. 使用检索或 网络检索。它们是能够从文件或数据库（检索）或从网络（网络检索）中获取相关数据的特殊工具。这有助于使响应基于相关的上下文数据。\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Fcontext.md",
        "sha": "fc49db155fd4c4282116a8400777944ea1d3e753",
        "status": "modified"
      },
      {
        "additions": 39,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Fexamples.md",
        "changes": 78,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fzh%2Fexamples.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 39,
        "filename": "docs/zh/examples.md",
        "patch": "@@ -4,58 +4,58 @@ search:\n ---\n # 代码示例\n \n-在[repo](https://github.com/openai/openai-agents-python/tree/main/examples)的 examples 区域查看该 SDK 的多种示例实现。这些代码示例按不同类别组织，以展示不同的模式与能力。\n+在[仓库](https://github.com/openai/openai-agents-python/tree/main/examples)的 examples 目录中查看多种 SDK 的示例实现。这些示例按多个目录组织，以展示不同的模式和能力。\n \n ## 目录\n \n--   **[agent_patterns](https://github.com/openai/openai-agents-python/tree/main/examples/agent_patterns):**\n-    本目录中的代码示例展示了常见的智能体设计模式，例如：\n+-   **[智能体模式 (agent_patterns)](https://github.com/openai/openai-agents-python/tree/main/examples/agent_patterns):**\n+    此目录中的示例展示常见的智能体设计模式，例如：\n \n     -   确定性工作流\n     -   将智能体作为工具\n-    -   智能体并行执行\n+    -   并行智能体执行\n     -   条件式工具使用\n     -   输入/输出安全防护措施\n-    -   以 LLM 作为裁判\n+    -   LLM 作为评审\n     -   路由\n     -   流式传输安全防护措施\n \n--   **[basic](https://github.com/openai/openai-agents-python/tree/main/examples/basic):**\n-    这些代码示例展示了 SDK 的基础能力，例如：\n+-   **[基础 (basic)](https://github.com/openai/openai-agents-python/tree/main/examples/basic):**\n+    这些示例展示 SDK 的基础能力，例如：\n \n-    -   Hello World 代码示例（默认模型、GPT-5、开源权重模型）\n+    -   Hello World 代码示例（默认模型、GPT-5、开放权重模型）\n     -   智能体生命周期管理\n     -   动态 system prompt\n-    -   流式传输输出（文本、items、函数调用参数）\n-    -   提示词模板\n+    -   流式传输输出（文本、条目、函数调用参数）\n+    -   提示模板\n     -   文件处理（本地与远程、图像与 PDF）\n     -   用量追踪\n     -   非严格输出类型\n-    -   先前响应 ID 的用法\n+    -   先前响应 ID 的使用\n \n--   **[customer_service](https://github.com/openai/openai-agents-python/tree/main/examples/customer_service):**\n-    航空公司的客服系统示例。\n+-   **[客户服务 (customer_service)](https://github.com/openai/openai-agents-python/tree/main/examples/customer_service):**\n+    航空公司的客户服务系统示例。\n \n--   **[financial_research_agent](https://github.com/openai/openai-agents-python/tree/main/examples/financial_research_agent):**\n-    一个金融研究智能体，展示了借助智能体与工具进行金融数据分析的结构化研究工作流。\n+-   **[金融研究智能体 (financial_research_agent)](https://github.com/openai/openai-agents-python/tree/main/examples/financial_research_agent):**\n+    一个金融研究智能体，展示使用智能体与工具进行金融数据分析的结构化研究工作流。\n \n--   **[handoffs](https://github.com/openai/openai-agents-python/tree/main/examples/handoffs):**\n-    查看带消息过滤的智能体任务转移的实用代码示例。\n+-   **[任务转移 (handoffs)](https://github.com/openai/openai-agents-python/tree/main/examples/handoffs):**\n+    查看带消息过滤的智能体任务转移的实用示例。\n \n--   **[hosted_mcp](https://github.com/openai/openai-agents-python/tree/main/examples/hosted_mcp):**\n-    展示如何使用托管的 MCP（Model Context Protocol）连接器和审批的代码示例。\n+-   **[托管 MCP (hosted_mcp)](https://github.com/openai/openai-agents-python/tree/main/examples/hosted_mcp):**\n+    展示如何使用托管的 MCP (Model Context Protocol) 连接器与审批的示例。\n \n--   **[mcp](https://github.com/openai/openai-agents-python/tree/main/examples/mcp):**\n-    学习如何使用 MCP（Model Context Protocol）构建智能体，包括：\n+-   **[MCP (mcp)](https://github.com/openai/openai-agents-python/tree/main/examples/mcp):**\n+    学习如何使用 MCP (Model Context Protocol) 构建智能体，包括：\n \n     -   文件系统代码示例\n     -   Git 代码示例\n-    -   MCP 提示词服务代码示例\n-    -   SSE（Server-Sent Events）代码示例\n+    -   MCP 提示服务代码示例\n+    -   SSE (Server-Sent Events) 代码示例\n     -   可流式传输的 HTTP 代码示例\n \n--   **[memory](https://github.com/openai/openai-agents-python/tree/main/examples/memory):**\n-    展示智能体的不同内存实现，包括：\n+-   **[记忆 (memory)](https://github.com/openai/openai-agents-python/tree/main/examples/memory):**\n+    展示智能体的不同记忆实现，包括：\n \n     -   SQLite 会话存储\n     -   高级 SQLite 会话存储\n@@ -64,30 +64,30 @@ search:\n     -   加密会话存储\n     -   OpenAI 会话存储\n \n--   **[model_providers](https://github.com/openai/openai-agents-python/tree/main/examples/model_providers):**\n-    了解如何在 SDK 中使用非 OpenAI 模型，包括自定义提供方和 LiteLLM 集成。\n+-   **[模型提供方 (model_providers)](https://github.com/openai/openai-agents-python/tree/main/examples/model_providers):**\n+    了解如何在 SDK 中使用非 OpenAI 模型，包括自定义提供方与 LiteLLM 集成。\n \n--   **[realtime](https://github.com/openai/openai-agents-python/tree/main/examples/realtime):**\n-    展示如何使用 SDK 构建实时体验的代码示例，包括：\n+-   **[实时 (realtime)](https://github.com/openai/openai-agents-python/tree/main/examples/realtime):**\n+    展示如何使用 SDK 构建实时体验的示例，包括：\n \n     -   Web 应用\n     -   命令行界面\n     -   Twilio 集成\n \n--   **[reasoning_content](https://github.com/openai/openai-agents-python/tree/main/examples/reasoning_content):**\n-    展示如何处理推理内容与 structured outputs 的代码示例。\n+-   **[推理内容 (reasoning_content)](https://github.com/openai/openai-agents-python/tree/main/examples/reasoning_content):**\n+    展示如何处理推理内容与 structured outputs 的示例。\n \n--   **[research_bot](https://github.com/openai/openai-agents-python/tree/main/examples/research_bot):**\n-    简单的深度研究克隆，展示复杂的多智能体研究工作流。\n+-   **[研究机器人 (research_bot)](https://github.com/openai/openai-agents-python/tree/main/examples/research_bot):**\n+    简单的 deep research 克隆，展示复杂的多智能体研究工作流。\n \n--   **[tools](https://github.com/openai/openai-agents-python/tree/main/examples/tools):**\n-    学习如何实现由OpenAI托管的工具，例如：\n+-   **[工具 (tools)](https://github.com/openai/openai-agents-python/tree/main/examples/tools):**\n+    了解如何实现由OpenAI托管的工具，例如：\n \n-    -   网络检索与带筛选的网络检索\n+    -   网络检索与带筛选条件的网络检索\n     -   文件检索\n-    -   Code interpreter\n+    -   Code Interpreter\n     -   计算机操作\n     -   图像生成\n \n--   **[voice](https://github.com/openai/openai-agents-python/tree/main/examples/voice):**\n-    查看语音智能体的代码示例，使用我们的 TTS 和 STT 模型，包括流式传输语音代码示例。\n\\ No newline at end of file\n+-   **[语音 (voice)](https://github.com/openai/openai-agents-python/tree/main/examples/voice):**\n+    查看语音智能体示例，使用我们的 TTS 和 STT 模型，包括流式语音代码示例。\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Fexamples.md",
        "sha": "d578af794151b2be42d6992f7f72b3c245663c9d",
        "status": "modified"
      },
      {
        "additions": 21,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Fguardrails.md",
        "changes": 42,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fzh%2Fguardrails.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 21,
        "filename": "docs/zh/guardrails.md",
        "patch": "@@ -4,9 +4,9 @@ search:\n ---\n # 安全防护措施\n \n-安全防护措施使你能够对用户输入和智能体输出进行检查与验证。比如，假设你有一个使用非常智能（因此也更慢/更昂贵）模型来处理客户请求的智能体。你不希望恶意用户让该模型帮他们做数学作业。因此，你可以使用一个快速/廉价的模型来运行安全防护措施。如果安全防护措施检测到恶意使用，它可以立即抛出错误并阻止昂贵模型运行，从而节省时间和成本（当使用阻塞式安全防护措施时；对于并行安全防护措施，安全防护措施完成前昂贵模型可能已开始运行。详见下文“执行模式”）。\n+安全防护措施使你能够对用户输入和智能体输出进行检查和验证。比如，你有一个智能体使用一个非常智能（因此也更慢/更昂贵）的模型来处理客户请求。你不希望恶意用户要求模型帮助他们完成数学作业。因此，你可以用一个快速/廉价的模型运行一层安全防护措施。如果检测到恶意使用，它可以立即抛出错误并阻止昂贵模型运行，从而节省时间和金钱（**在使用阻塞式安全防护措施时；对于并行安全防护措施，昂贵模型可能会在防护措施完成前就已开始运行。详见下文“执行模式”**）。\n \n-安全防护措施分为两类：\n+安全防护措施有两种类型：\n \n 1. 输入安全防护措施运行于初始用户输入\n 2. 输出安全防护措施运行于最终智能体输出\n@@ -16,42 +16,42 @@ search:\n 输入安全防护措施分三步运行：\n \n 1. 首先，安全防护措施接收与智能体相同的输入。\n-2. 接着，运行安全防护措施函数以生成一个 [`GuardrailFunctionOutput`][agents.guardrail.GuardrailFunctionOutput]，随后将其包装为 [`InputGuardrailResult`][agents.guardrail.InputGuardrailResult]\n-3. 最后，我们检查 [`.tripwire_triggered`][agents.guardrail.GuardrailFunctionOutput.tripwire_triggered] 是否为 true。若为 true，则抛出 [`InputGuardrailTripwireTriggered`][agents.exceptions.InputGuardrailTripwireTriggered] 异常，你可以据此向用户作出适当响应或处理该异常。\n+2. 接着，运行安全防护函数以生成一个 [`GuardrailFunctionOutput`][agents.guardrail.GuardrailFunctionOutput]，然后将其封装为 [`InputGuardrailResult`][agents.guardrail.InputGuardrailResult]\n+3. 最后，我们检查 [`.tripwire_triggered`][agents.guardrail.GuardrailFunctionOutput.tripwire_triggered] 是否为 true。若为 true，则抛出 [`InputGuardrailTripwireTriggered`][agents.exceptions.InputGuardrailTripwireTriggered] 异常，以便你适当回复用户或处理异常。\n \n !!! Note\n \n-    输入安全防护措施旨在作用于用户输入，因此仅当该智能体是第一个智能体时，其安全防护措施才会运行。你可能会想，为什么 `guardrails` 属性在智能体上，而不是传给 `Runner.run`？这是因为安全防护措施通常与具体智能体相关——不同智能体会运行不同的安全防护措施，因此将代码放在一起更有利于可读性。\n+    输入安全防护措施旨在运行于用户输入，因此只有当某个智能体是*第一个*智能体时，它的安全防护措施才会运行。你可能会问，为什么 `guardrails` 属性在智能体上，而不是传给 `Runner.run`？这是因为安全防护措施通常与具体的智能体相关——你会为不同智能体运行不同的防护措施，因此将代码与智能体放在一起有助于可读性。\n \n ### 执行模式\n \n 输入安全防护措施支持两种执行模式：\n \n-- **并行执行**（默认，`run_in_parallel=True`）：安全防护措施与智能体执行并发运行。由于二者同时开始，这带来最佳时延。但如果安全防护措施失败，智能体在被取消前可能已经消耗了 tokens 并执行了工具。\n+- **并行执行**（默认，`run_in_parallel=True`）：安全防护措施与智能体执行并发运行。由于二者同时开始，这能提供最佳时延。但如果防护失败，智能体在被取消前可能已经消耗了 tokens 并执行了工具。\n \n-- **阻塞执行**（`run_in_parallel=False`）：安全防护措施在智能体启动之前运行并完成。如果触发了安全防护措施的触发线，智能体将不会执行，从而避免 token 消耗与工具执行。这非常适合成本优化，并在你希望避免工具调用潜在副作用时使用。\n+- **阻塞执行**（`run_in_parallel=False`）：安全防护措施在智能体开始前运行并完成。若触发绊线，智能体将不会执行，从而避免 token 消耗与工具执行。这对于优化成本以及避免工具调用潜在副作用非常理想。\n \n ## 输出安全防护措施\n \n 输出安全防护措施分三步运行：\n \n-1. 首先，安全防护措施接收由智能体生成的输出。\n-2. 接着，运行安全防护措施函数以生成一个 [`GuardrailFunctionOutput`][agents.guardrail.GuardrailFunctionOutput]，随后将其包装为 [`OutputGuardrailResult`][agents.guardrail.OutputGuardrailResult]\n-3. 最后，我们检查 [`.tripwire_triggered`][agents.guardrail.GuardrailFunctionOutput.tripwire_triggered] 是否为 true。若为 true，则抛出 [`OutputGuardrailTripwireTriggered`][agents.exceptions.OutputGuardrailTripwireTriggered] 异常，你可以据此向用户作出适当响应或处理该异常。\n+1. 首先，安全防护措施接收智能体产生的输出。\n+2. 接着，运行安全防护函数以生成一个 [`GuardrailFunctionOutput`][agents.guardrail.GuardrailFunctionOutput]，然后将其封装为 [`OutputGuardrailResult`][agents.guardrail.OutputGuardrailResult]\n+3. 最后，我们检查 [`.tripwire_triggered`][agents.guardrail.GuardrailFunctionOutput.tripwire_triggered] 是否为 true。若为 true，则抛出 [`OutputGuardrailTripwireTriggered`][agents.exceptions.OutputGuardrailTripwireTriggered] 异常，以便你适当回复用户或处理异常。\n \n !!! Note\n \n-    输出安全防护措施旨在作用于最终的智能体输出，因此仅当该智能体是最后一个智能体时，其安全防护措施才会运行。与输入安全防护措施类似，我们这样做是因为安全防护措施通常与具体智能体相关——不同智能体会运行不同的安全防护措施，因此将代码放在一起更有利于可读性。\n+    输出安全防护措施旨在运行于最终智能体输出，因此只有当某个智能体是*最后一个*智能体时，它的安全防护措施才会运行。与输入安全防护措施类似，我们这样设计是因为安全防护措施通常与具体的智能体相关——你会为不同智能体运行不同的防护措施，因此将代码与智能体放在一起有助于可读性。\n \n-    输出安全防护措施总是在智能体完成后运行，因此不支持 `run_in_parallel` 参数。\n+    输出安全防护措施总是在智能体完成后才运行，因此不支持 `run_in_parallel` 参数。\n \n-## 触发线\n+## 绊线\n \n-如果输入或输出未通过安全防护措施，安全防护措施可以通过触发线来发出信号。一旦我们发现某个安全防护措施触发了触发线，我们会立即抛出 `{Input,Output}GuardrailTripwireTriggered` 异常并停止智能体执行。\n+如果输入或输出未通过安全防护措施，安全防护措施可以通过绊线来发出信号。一旦我们发现某个安全防护措施触发了绊线，就会立即抛出 `{Input,Output}GuardrailTripwireTriggered` 异常并停止智能体执行。\n \n-## 安全防护措施实现\n+## 实现安全防护措施\n \n-你需要提供一个函数来接收输入，并返回一个 [`GuardrailFunctionOutput`][agents.guardrail.GuardrailFunctionOutput]。在此示例中，我们将通过在底层运行一个智能体来实现。\n+你需要提供一个接收输入并返回 [`GuardrailFunctionOutput`][agents.guardrail.GuardrailFunctionOutput] 的函数。在下面的例子中，我们会在底层运行一个智能体来完成此事。\n \n ```python\n from pydantic import BaseModel\n@@ -104,12 +104,12 @@ async def main():\n         print(\"Math homework guardrail tripped\")\n ```\n \n-1. 我们将在安全防护措施函数中使用此智能体。\n-2. 这是接收智能体输入/上下文并返回结果的安全防护措施函数。\n-3. 我们可以在安全防护措施结果中包含额外信息。\n+1. 我们会在安全防护函数中使用这个智能体。\n+2. 这是接收智能体输入/上下文并返回结果的安全防护函数。\n+3. 我们可以在安全防护结果中包含额外信息。\n 4. 这是定义工作流的实际智能体。\n \n-输出安全防护措施与此类似。\n+输出安全防护措施与之类似。\n \n ```python\n from pydantic import BaseModel\n@@ -164,5 +164,5 @@ async def main():\n \n 1. 这是实际智能体的输出类型。\n 2. 这是安全防护措施的输出类型。\n-3. 这是接收智能体输出并返回结果的安全防护措施函数。\n+3. 这是接收智能体输出并返回结果的安全防护函数。\n 4. 这是定义工作流的实际智能体。\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Fguardrails.md",
        "sha": "ca56b6bb2b75bfee8661cb36ed8f7f0cb909ed86",
        "status": "modified"
      },
      {
        "additions": 22,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Fhandoffs.md",
        "changes": 44,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fzh%2Fhandoffs.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 22,
        "filename": "docs/zh/handoffs.md",
        "patch": "@@ -2,21 +2,21 @@\n search:\n   exclude: true\n ---\n-# 任务转移\n+# Handoffs\n \n-任务转移允许一个智能体将任务委派给另一个智能体。这在不同智能体各自专长不同领域的场景中特别有用。例如，一个客服应用可能有专门处理订单状态、退款、常见问题等任务的智能体。\n+Handoffs 允许一个智能体将任务委派给另一个智能体。这在不同智能体各自专长不同领域的场景中特别有用。例如，一个客服应用可能有专门处理订单状态、退款、常见问题等任务的智能体。\n \n-对 LLM 而言，任务转移以工具的形式呈现。所以，如果有一个转移到名为 `Refund Agent` 的智能体，对应的工具将被命名为 `transfer_to_refund_agent`。\n+对 LLM 而言，Handoffs 被表示为工具。因此，如果要将任务转移给名为 `Refund Agent` 的智能体，对应的工具名将是 `transfer_to_refund_agent`。\n \n-## 创建任务转移\n+## 创建 handoff\n \n-所有智能体都有一个 [`handoffs`][agents.agent.Agent.handoffs] 参数，可以直接接收一个 `Agent`，或接收一个用于自定义任务转移的 `Handoff` 对象。\n+所有智能体都有一个 [`handoffs`][agents.agent.Agent.handoffs] 参数，它可以直接接收一个 `Agent`，也可以接收一个自定义 Handoff 的 `Handoff` 对象。\n \n-你可以使用 Agents SDK 提供的 [`handoff()`][agents.handoffs.handoff] 函数创建任务转移。该函数允许你指定要转移到的智能体，并可选地提供覆盖项和输入过滤器。\n+你可以使用 Agents SDK 提供的 [`handoff()`][agents.handoffs.handoff] 函数创建一个 handoff。该函数允许你指定要转移的目标智能体，并可选设置覆盖项与输入过滤器。\n \n ### 基本用法\n \n-以下展示如何创建一个简单的任务转移：\n+如下创建一个简单的 handoff：\n \n ```python\n from agents import Agent, handoff\n@@ -30,17 +30,17 @@ triage_agent = Agent(name=\"Triage agent\", handoffs=[billing_agent, handoff(refun\n \n 1. 你可以直接使用智能体（如 `billing_agent`），也可以使用 `handoff()` 函数。\n \n-### 通过 `handoff()` 函数自定义任务转移\n+### 通过 `handoff()` 函数自定义 handoff\n \n [`handoff()`][agents.handoffs.handoff] 函数允许你进行自定义。\n \n-- `agent`: 要转移到的智能体。\n-- `tool_name_override`: 默认使用 `Handoff.default_tool_name()` 函数，生成 `transfer_to_<agent_name>`。你可以覆盖此名称。\n-- `tool_description_override`: 覆盖 `Handoff.default_tool_description()` 提供的默认工具描述。\n-- `on_handoff`: 任务转移被调用时执行的回调函数。当你得知即将发生任务转移时，可用于立即启动一些数据获取等操作。该函数接收智能体上下文，并可选地接收 LLM 生成的输入。输入数据由 `input_type` 参数控制。\n-- `input_type`: 任务转移期望的输入类型（可选）。\n-- `input_filter`: 用于过滤下一个智能体接收到的输入。详见下文。\n-- `is_enabled`: 是否启用该任务转移。可以是布尔值或返回布尔值的函数，从而允许在运行时动态启用或禁用任务转移。\n+-   `agent`: 这是将接收任务的智能体。\n+-   `tool_name_override`: 默认使用 `Handoff.default_tool_name()` 函数，解析为 `transfer_to_<agent_name>`。你可以覆盖它。\n+-   `tool_description_override`: 覆盖来自 `Handoff.default_tool_description()` 的默认工具描述。\n+-   `on_handoff`: handoff 被调用时执行的回调函数。可用于在确定触发 handoff 时立即启动数据获取等操作。该函数会接收智能体上下文，并可选接收 LLM 生成的输入。输入数据由 `input_type` 参数控制。\n+-   `input_type`: handoff 期望的输入类型（可选）。\n+-   `input_filter`: 用于过滤下一个智能体接收的输入。详见下文。\n+-   `is_enabled`: handoff 是否启用。可以是布尔值或返回布尔值的函数，从而在运行时动态启用或禁用 handoff。\n \n ```python\n from agents import Agent, handoff, RunContextWrapper\n@@ -58,9 +58,9 @@ handoff_obj = handoff(\n )\n ```\n \n-## 任务转移输入\n+## Handoff 输入\n \n-在某些情况下，你希望 LLM 在调用任务转移时提供一些数据。例如，设想转移到一个“升级处理智能体”。你可能希望提供一个原因，以便记录。\n+在某些情况下，你希望 LLM 在调用 handoff 时提供一些数据。例如，想象一个“升级处理智能体（Escalation agent）”的 handoff。你可能希望提供一个原因，便于记录。\n \n ```python\n from pydantic import BaseModel\n@@ -84,11 +84,11 @@ handoff_obj = handoff(\n \n ## 输入过滤器\n \n-当发生任务转移时，就好像新的智能体接管了对话，并可以看到全部先前的对话历史。如果你想改变这一点，可以设置 [`input_filter`][agents.handoffs.Handoff.input_filter]。输入过滤器是一个函数，它通过 [`HandoffInputData`][agents.handoffs.HandoffInputData] 接收已有输入，并且必须返回一个新的 `HandoffInputData`。\n+当发生 handoff 时，新智能体会接管对话，并可看到整个此前的对话历史。如果你想改变这一行为，可以设置一个 [`input_filter`][agents.handoffs.Handoff.input_filter]。输入过滤器是一个函数，它通过 [`HandoffInputData`][agents.handoffs.HandoffInputData] 接收现有输入，并必须返回一个新的 `HandoffInputData`。\n \n-默认情况下，运行器现在会将先前的对话记录折叠为一条助理总结消息（参见 [`RunConfig.nest_handoff_history`][agents.run.RunConfig.nest_handoff_history]）。该总结位于一个 `<CONVERSATION HISTORY>` 块中，当同一次运行中发生多次任务转移时，该块会不断追加新轮次。你可以通过 [`RunConfig.handoff_history_mapper`][agents.run.RunConfig.handoff_history_mapper] 提供你自己的映射函数，在不编写完整 `input_filter` 的情况下替换生成的消息。该默认行为仅在任务转移和运行都未提供显式 `input_filter` 时生效，因此已自定义负载的现有代码（包括本仓库中的 code examples）将保持当前行为不变。你也可以通过向 [`handoff(...)`][agents.handoffs.handoff] 传入 `nest_handoff_history=True` 或 `False` 覆盖单次任务转移的嵌套行为，这会设置 [`Handoff.nest_handoff_history`][agents.handoffs.Handoff.nest_handoff_history]。如果你只需要更改生成总结的包裹文本，可在运行智能体之前调用 [`set_conversation_history_wrappers`][agents.handoffs.set_conversation_history_wrappers]（以及可选的 [`reset_conversation_history_wrappers`][agents.handoffs.reset_conversation_history_wrappers]）。\n+默认情况下，runner 现在会将先前的对话记录折叠为单个助理总结消息（参见 [`RunConfig.nest_handoff_history`][agents.run.RunConfig.nest_handoff_history]）。当同一次运行中发生多次 handoff 时，该总结会出现在一个不断追加新轮次的 `<CONVERSATION HISTORY>` 块中。你可以通过 [`RunConfig.handoff_history_mapper`][agents.run.RunConfig.handoff_history_mapper] 提供自定义映射函数，以替换生成的消息，而无需编写完整的 `input_filter`。该默认行为仅在 handoff 与运行都未提供显式的 `input_filter` 时生效，因此已自定义负载的现有代码（包括本仓库中的 code examples）无需变更即可保持当前行为。你可以在单个 handoff 上通过向 [`handoff(...)`][agents.handoffs.handoff] 传入 `nest_handoff_history=True` 或 `False` 来覆盖嵌套行为，这会设置 [`Handoff.nest_handoff_history`][agents.handoffs.Handoff.nest_handoff_history]。如果你只需更改生成总结的包装文本，请在运行智能体之前调用 [`set_conversation_history_wrappers`][agents.handoffs.set_conversation_history_wrappers]（以及可选的 [`reset_conversation_history_wrappers`][agents.handoffs.reset_conversation_history_wrappers]）。\n \n-一些常见模式（例如从历史中移除所有工具调用）已在 [`agents.extensions.handoff_filters`][] 中为你实现。\n+一些常见模式（例如从历史记录中移除所有工具调用）已在 [`agents.extensions.handoff_filters`][] 中为你实现。\n \n ```python\n from agents import Agent, handoff\n@@ -102,11 +102,11 @@ handoff_obj = handoff(\n )\n ```\n \n-1. 当调用 `FAQ agent` 时，这会自动从历史中移除所有工具。\n+1. 当调用 `FAQ agent` 时，这将自动从历史中移除所有工具。\n \n ## 推荐提示词\n \n-为确保 LLM 正确理解任务转移，我们建议在你的智能体中包含有关任务转移的信息。我们在 [`agents.extensions.handoff_prompt.RECOMMENDED_PROMPT_PREFIX`][] 中提供了一个建议的前缀，或者你可以调用 [`agents.extensions.handoff_prompt.prompt_with_handoff_instructions`][] 将推荐数据自动添加到你的提示词中。\n+为确保 LLM 正确理解 handoffs，我们建议在你的智能体中包含关于 handoffs 的信息。我们在 [`agents.extensions.handoff_prompt.RECOMMENDED_PROMPT_PREFIX`][] 中提供了一个建议前缀，或者你可以调用 [`agents.extensions.handoff_prompt.prompt_with_handoff_instructions`][] 将推荐内容自动添加到你的提示词中。\n \n ```python\n from agents import Agent",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Fhandoffs.md",
        "sha": "80f5ee58dae2a0fc84fab64e9c353d38098fdc43",
        "status": "modified"
      },
      {
        "additions": 19,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Findex.md",
        "changes": 38,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fzh%2Findex.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 19,
        "filename": "docs/zh/index.md",
        "patch": "@@ -4,31 +4,31 @@ search:\n ---\n # OpenAI Agents SDK\n \n-[OpenAI Agents SDK](https://github.com/openai/openai-agents-python) 让你以轻量、易用、抽象极少的方式构建智能体 AI 应用。它是我们此前用于智能体实验项目 [Swarm](https://github.com/openai/swarm/tree/main) 的面向生产的升级版。Agents SDK 仅包含一小组基本组件：\n+[OpenAI Agents SDK](https://github.com/openai/openai-agents-python) 使你能够以轻量、易用、低抽象的方式构建智能体应用。它是我们此前面向智能体的实验项目 [Swarm](https://github.com/openai/swarm/tree/main) 的面向生产级升级版本。Agents SDK 提供了一小组基础组件：\n \n--   **智能体（Agents）**：配备 instructions 和 tools 的 LLM\n--   **任务转移（Handoffs）**：允许智能体将特定任务委派给其他智能体\n--   **安全防护措施（Guardrails）**：支持对智能体输入与输出进行验证\n--   **会话（Sessions）**：在多次智能体运行间自动维护对话历史\n+-   **智能体**：基于 LLM，并配备 instructions 和 tools\n+-   **任务转移**：允许智能体将特定任务委派给其他智能体\n+-   **安全防护措施**：用于对智能体的输入与输出进行验证\n+-   **会话**：在多次运行中自动维护对话历史\n \n-结合 Python，这些基本组件足以表达工具与智能体之间的复杂关系，让你无需陡峭学习曲线即可构建真实世界应用。此外，SDK 内置 **追踪（tracing）**，可视化与调试智能体流程，对其进行评测，甚至为你的应用微调模型。\n+结合 Python，这些基础组件足以表达工具与智能体之间的复杂关系，让你无需陡峭学习曲线即可构建真实世界应用。此外，SDK 内置 **追踪**，可视化并调试智能体流程，还能对其进行评估，甚至为你的应用微调模型。\n \n-## 为什么使用 Agents SDK\n+## 使用 Agents SDK 的理由\n \n-该 SDK 遵循两大设计原则：\n+该 SDK 的设计遵循两条原则：\n \n-1. 功能足够有用，但基本组件足够少，便于快速上手。\n-2. 开箱即用且好用，同时支持你精确自定义行为。\n+1. 功能足够有用，但基础组件足够少，上手快速。\n+2. 开箱即用效果佳，同时可精细定制行为。\n \n-SDK 的主要特性包括：\n+主要特性包括：\n \n--   智能体循环：内置循环处理调用工具、将结果回传给 LLM，并循环直至 LLM 完成。\n--   Python 优先：利用语言内建特性编排与串联智能体，而无需学习新抽象。\n--   任务转移：在多个智能体间进行协调与委派的强大能力。\n--   安全防护措施：与智能体并行执行输入校验，校验失败时可提前中断。\n--   会话：跨智能体运行自动管理对话历史，免去手动状态管理。\n--   工具调用（Function tools）：将任意 Python 函数变为工具，自动生成模式（schema）并通过 Pydantic 驱动进行验证。\n--   追踪：内置追踪，可视化、调试与监控工作流，并可使用 OpenAI 的评测、微调与蒸馏工具套件。\n+-   智能体循环：内置循环，负责调用工具、将结果返回给 LLM，并在 LLM 完成前持续迭代。\n+-   Python 优先：使用语言原生特性来编排与串联智能体，而无需学习新的抽象。\n+-   任务转移：在多个智能体之间进行协调与委派的强大能力。\n+-   安全防护措施：与智能体并行执行输入校验与检查，失败时提前中断。\n+-   会话：跨多次运行自动管理对话历史，免去手动管理状态。\n+-   工具调用：将任意 Python 函数变为工具，自动生成模式，并通过 Pydantic 驱动的校验。\n+-   追踪：内置追踪，可视化、调试与监控工作流，并可使用 OpenAI 的评估、微调与蒸馏工具套件。\n \n ## 安装\n \n@@ -51,7 +51,7 @@ print(result.final_output)\n # Infinite loop's dance.\n ```\n \n-(_If running this, ensure you set the `OPENAI_API_KEY` environment variable_)\n+(_如果要运行此示例，请确保已设置 `OPENAI_API_KEY` 环境变量_)\n \n ```bash\n export OPENAI_API_KEY=sk-...",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Findex.md",
        "sha": "4f1b8d5a3dceccf3320844b056b767368c98d1d2",
        "status": "modified"
      },
      {
        "additions": 51,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Fmcp.md",
        "changes": 102,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fzh%2Fmcp.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 51,
        "filename": "docs/zh/mcp.md",
        "patch": "@@ -4,34 +4,32 @@ search:\n ---\n # Model context protocol (MCP)\n \n-[Model context protocol](https://modelcontextprotocol.io/introduction)（MCP）标准化了应用如何向语言模型暴露工具和上下文。来自官方文档：\n+[Model context protocol](https://modelcontextprotocol.io/introduction)（MCP）标准化了应用如何向语言模型暴露工具与上下文。官方文档中写道：\n \n-> MCP is an open protocol that standardizes how applications provide context to LLMs. Think of MCP like a USB-C port for AI\n-> applications. Just as USB-C provides a standardized way to connect your devices to various peripherals and accessories, MCP\n-> provides a standardized way to connect AI models to different data sources and tools.\n+> MCP 是一个开放协议，用于标准化应用如何向 LLM 提供上下文。可以把 MCP 看作 AI 应用的 USB‑C 接口。就像 USB‑C 提供标准化方式将设备连接到各种外设与配件一样，MCP 提供标准化方式将 AI 模型连接到不同的数据源与工具。\n \n-Agents Python SDK 支持多种 MCP 传输方式。这样你可以复用现有的 MCP 服务或自行构建，以向智能体暴露基于文件系统、HTTP 或连接器的工具。\n+Agents Python SDK 支持多种 MCP 传输方式。你可以复用现有 MCP 服务，或自行构建，以向智能体暴露文件系统、HTTP 或由连接器驱动的工具。\n \n-## 选择 MCP 集成\n+## Choosing an MCP integration\n \n-在将 MCP 服务接入智能体之前，先决定工具调用应在何处执行，以及可达的传输方式。下表总结了 Python SDK 支持的选项。\n+在将 MCP 服务接入智能体之前，请先决定工具调用应在哪执行，以及你可达的传输方式。下表总结了 Python SDK 支持的选项。\n \n-| 你的需求                                                                            | 推荐选项                                             |\n-| ------------------------------------------------------------------------------------ | ---------------------------------------------------- |\n-| 让 OpenAI 的 Responses API 代表模型调用可公开访问的 MCP 服务                         | **托管 MCP 服务工具**，通过 [`HostedMCPTool`][agents.tool.HostedMCPTool] |\n-| 连接你本地或远程运行的可流式传输的 HTTP 服务                                         | **Streamable HTTP MCP 服务**，通过 [`MCPServerStreamableHttp`][agents.mcp.server.MCPServerStreamableHttp] |\n-| 与实现了基于 HTTP 的 Server-Sent Events 的服务通信                                   | **HTTP with SSE MCP 服务**，通过 [`MCPServerSse`][agents.mcp.server.MCPServerSse] |\n-| 启动本地进程并通过 stdin/stdout 通信                                                 | **stdio MCP 服务**，通过 [`MCPServerStdio`][agents.mcp.server.MCPServerStdio] |\n+| 你的需求                                                                             | 推荐选项                                              |\n+| ------------------------------------------------------------------------------------ | ----------------------------------------------------- |\n+| 让 OpenAI 的 Responses API 代表模型调用一个可公网访问的 MCP 服务                     | **Hosted MCP server tools**，通过 [`HostedMCPTool`][agents.tool.HostedMCPTool] |\n+| 连接你在本地或远程运行的 Streamable HTTP 服务                                        | **Streamable HTTP MCP servers**，通过 [`MCPServerStreamableHttp`][agents.mcp.server.MCPServerStreamableHttp] |\n+| 与实现了带 Server‑Sent Events 的 HTTP 的服务通信                                     | **HTTP with SSE MCP servers**，通过 [`MCPServerSse`][agents.mcp.server.MCPServerSse] |\n+| 启动本地进程并通过 stdin/stdout 通信                                                 | **stdio MCP servers**，通过 [`MCPServerStdio`][agents.mcp.server.MCPServerStdio] |\n \n-以下各节将逐一介绍每种选项、如何配置，以及何时优先选择某种传输方式。\n+下文将逐一介绍各选项、如何配置，以及何时优先选择某种传输方式。\n \n-## 1. 托管 MCP 服务工具\n+## 1. Hosted MCP server tools\n \n-托管工具将整个工具调用往返流程托管在 OpenAI 的基础设施内。你的代码无需列举与调用工具，[`HostedMCPTool`][agents.tool.HostedMCPTool] 会将服务标签（以及可选的连接器元数据）转发给 Responses API。模型会列出远程服务的工具并直接调用，无需额外回调到你的 Python 进程。托管工具目前可用于支持 Responses API 的托管 MCP 集成的 OpenAI 模型。\n+Hosted 工具将整个工具往返流程交由 OpenAI 基础设施处理。你的代码无需列出并调用工具，[`HostedMCPTool`][agents.tool.HostedMCPTool] 会将服务标签（以及可选的连接器元数据）转发给 Responses API。模型会列出远程服务的工具并直接调用，无需回调到你的 Python 进程。Hosted 工具目前适用于支持 Responses API 的 hosted MCP 集成的 OpenAI 模型。\n \n-### 基础托管 MCP 工具\n+### Basic hosted MCP tool\n \n-在智能体的 `tools` 列表中添加一个 [`HostedMCPTool`][agents.tool.HostedMCPTool] 即可创建托管工具。`tool_config` 字典与发送到 REST API 的 JSON 一致：\n+通过在智能体的 `tools` 列表中添加一个 [`HostedMCPTool`][agents.tool.HostedMCPTool] 来创建 hosted 工具。`tool_config` 字典与通过 REST API 发送的 JSON 一致：\n \n ```python\n import asyncio\n@@ -59,11 +57,11 @@ async def main() -> None:\n asyncio.run(main())\n ```\n \n-托管服务会自动暴露其工具；你无需将其添加到 `mcp_servers`。\n+Hosted 服务会自动暴露其工具；你无需将其添加到 `mcp_servers`。\n \n-### 托管 MCP 结果的流式传输\n+### Streaming hosted MCP results\n \n-托管工具以与工具调用完全相同的方式支持流式传输。将 `stream=True` 传给 `Runner.run_streamed`，即可在模型仍在处理时消费增量 MCP 输出：\n+Hosted 工具支持与工具调用相同方式的流式传输。向 `Runner.run_streamed` 传入 `stream=True`，即可在模型仍在工作时消费增量 MCP 输出：\n \n ```python\n result = Runner.run_streamed(agent, \"Summarise this repository's top languages\")\n@@ -73,9 +71,9 @@ async for event in result.stream_events():\n print(result.final_output)\n ```\n \n-### 可选的审批流程\n+### Optional approval flows\n \n-如果某个服务可以执行敏感操作，你可以在每次工具执行前要求人工或程序化审批。在 `tool_config` 中配置 `require_approval`，可传入单一策略（`\"always\"`、`\"never\"`）或按工具名映射到策略的字典。若要在 Python 内做出决策，提供一个 `on_approval_request` 回调。\n+如果服务可以执行敏感操作，你可以在每次工具执行前要求人工或程序化审批。在 `tool_config` 中配置 `require_approval`，可传入单一策略（`\"always\"`、`\"never\"`）或映射各工具名到策略的字典。若要在 Python 中做决策，提供一个 `on_approval_request` 回调。\n \n ```python\n from agents import MCPToolApprovalFunctionResult, MCPToolApprovalRequest\n@@ -103,11 +101,11 @@ agent = Agent(\n )\n ```\n \n-该回调可为同步或异步；每当模型需要审批数据以继续运行时都会被调用。\n+该回调可以是同步或异步的，只要模型需要审批数据以继续运行，就会被调用。\n \n-### 基于连接器的托管服务\n+### Connector-backed hosted servers\n \n-托管 MCP 也支持 OpenAI 连接器。无需指定 `server_url`，改为提供 `connector_id` 和访问令牌。Responses API 将处理认证，并由托管服务暴露连接器的工具。\n+Hosted MCP 也支持 OpenAI connectors。无需提供 `server_url`，改为提供 `connector_id` 和访问令牌。Responses API 负责认证，Hosted 服务会暴露该连接器的工具。\n \n ```python\n import os\n@@ -123,12 +121,13 @@ HostedMCPTool(\n )\n ```\n \n-完整可运行的托管工具示例（包含流式传输、审批与连接器）位于\n+完整可运行的 hosted 工具示例——包括流式传输、审批与连接器——参见\n [`examples/hosted_mcp`](https://github.com/openai/openai-agents-python/tree/main/examples/hosted_mcp)。\n \n-## 2. Streamable HTTP MCP 服务\n+## 2. Streamable HTTP MCP servers\n \n-当你希望自行管理网络连接时，使用 [`MCPServerStreamableHttp`][agents.mcp.server.MCPServerStreamableHttp]。当你可控传输层，或希望在自有基础设施内运行服务同时保持低延迟时，可流式传输的 HTTP 服务是理想选择。\n+当你希望自行管理网络连接时，使用\n+[`MCPServerStreamableHttp`][agents.mcp.server.MCPServerStreamableHttp]。当你可控传输方式，或希望在自有基础设施中运行服务以保持低延迟时，Streamable HTTP 服务非常理想。\n \n ```python\n import asyncio\n@@ -167,12 +166,13 @@ asyncio.run(main())\n \n - `client_session_timeout_seconds` 控制 HTTP 读取超时。\n - `use_structured_content` 切换是否优先使用 `tool_result.structured_content` 而非文本输出。\n-- `max_retry_attempts` 与 `retry_backoff_seconds_base` 为 `list_tools()` 与 `call_tool()` 增加自动重试。\n+- `max_retry_attempts` 与 `retry_backoff_seconds_base` 为 `list_tools()` 和 `call_tool()` 添加自动重试。\n - `tool_filter` 允许仅暴露工具子集（见[工具过滤](#tool-filtering)）。\n \n-## 3. HTTP with SSE MCP 服务\n+## 3. HTTP with SSE MCP servers\n \n-如果 MCP 服务实现了 HTTP with SSE 传输方式，实例化 [`MCPServerSse`][agents.mcp.server.MCPServerSse]。除传输方式外，其 API 与 Streamable HTTP 服务一致。\n+如果 MCP 服务实现了带 SSE 的 HTTP 传输，实例化\n+[`MCPServerSse`][agents.mcp.server.MCPServerSse]。除传输方式外，其 API 与 Streamable HTTP 服务相同。\n \n ```python\n \n@@ -199,9 +199,9 @@ async with MCPServerSse(\n     print(result.final_output)\n ```\n \n-## 4. stdio MCP 服务\n+## 4. stdio MCP servers\n \n-对于作为本地子进程运行的 MCP 服务，使用 [`MCPServerStdio`][agents.mcp.server.MCPServerStdio]。SDK 会启动进程、保持管道打开，并在上下文管理器退出时自动关闭。该选项适用于快速概念验证或服务仅以命令行入口暴露的场景。\n+对于以本地子进程运行的 MCP 服务，使用 [`MCPServerStdio`][agents.mcp.server.MCPServerStdio]。SDK 会启动进程、保持管道打开，并在上下文管理器退出时自动关闭。该选项适用于快速原型或服务仅以命令行入口暴露的场景。\n \n ```python\n from pathlib import Path\n@@ -227,11 +227,11 @@ async with MCPServerStdio(\n     print(result.final_output)\n ```\n \n-## 工具过滤\n+## Tool filtering\n \n-每个 MCP 服务均支持工具过滤，以便你仅暴露智能体所需的功能。过滤可在构建时设置，或按运行时动态指定。\n+每个 MCP 服务都支持工具过滤，以仅暴露智能体所需的函数。过滤可在构造时进行，或在每次运行时动态进行。\n \n-### 静态工具过滤\n+### Static tool filtering\n \n 使用 [`create_static_tool_filter`][agents.mcp.create_static_tool_filter] 配置简单的允许/阻止列表：\n \n@@ -251,11 +251,11 @@ filesystem_server = MCPServerStdio(\n )\n ```\n \n-当同时提供 `allowed_tool_names` 与 `blocked_tool_names` 时，SDK 会先应用允许列表，然后从剩余集合中移除任何被阻止的工具。\n+当同时提供 `allowed_tool_names` 与 `blocked_tool_names` 时，SDK 会先应用允许列表，然后从剩余集合中移除被阻止的工具。\n \n-### 动态工具过滤\n+### Dynamic tool filtering\n \n-若需更复杂的逻辑，传入一个可调用对象，该对象接收一个 [`ToolFilterContext`][agents.mcp.ToolFilterContext]。该可调用对象可为同步或异步，并在应暴露该工具时返回 `True`。\n+对于更复杂的逻辑，传入一个可调用对象，该对象接收 [`ToolFilterContext`][agents.mcp.ToolFilterContext]。该可调用对象可为同步或异步，返回 `True` 表示应暴露该工具。\n \n ```python\n from pathlib import Path\n@@ -279,14 +279,14 @@ async with MCPServerStdio(\n     ...\n ```\n \n-过滤上下文会暴露当前的 `run_context`、请求工具的 `agent`，以及 `server_name`。\n+过滤上下文会提供当前的 `run_context`、请求工具的 `agent`，以及 `server_name`。\n \n-## 提示词\n+## Prompts\n \n-MCP 服务还可以提供动态生成智能体指令的提示词。支持提示词的服务将暴露两个方法：\n+MCP 服务还可以提供动态生成智能体 instructions 的 prompts。支持 prompts 的服务会暴露两个方法：\n \n-- `list_prompts()` 枚举可用的提示词模板。\n-- `get_prompt(name, arguments)` 获取具体提示词，可选传入参数。\n+- `list_prompts()` 枚举可用的提示模板。\n+- `get_prompt(name, arguments)` 获取具体提示，可选带参数。\n \n ```python\n from agents import Agent\n@@ -304,21 +304,21 @@ agent = Agent(\n )\n ```\n \n-## 缓存\n+## Caching\n \n-每次智能体运行都会对每个 MCP 服务调用 `list_tools()`。远程服务可能引入明显延迟，因此所有 MCP 服务类都提供 `cache_tools_list` 选项。仅在你确信工具定义不会频繁变化时将其设为 `True`。若之后需要强制刷新，调用服务实例的 `invalidate_tools_cache()`。\n+每次智能体运行都会对每个 MCP 服务调用 `list_tools()`。远程服务可能带来明显延迟，因此所有 MCP 服务类都暴露了 `cache_tools_list` 选项。仅在你确信工具定义不频繁变化时将其设为 `True`。若需后续强制刷新列表，在服务实例上调用 `invalidate_tools_cache()`。\n \n-## 追踪\n+## Tracing\n \n-[追踪](./tracing.md)会自动捕获 MCP 活动，包括：\n+[Tracing](./tracing.md) 会自动捕获 MCP 活动，包括：\n \n 1. 调用 MCP 服务以列出工具。\n 2. 工具调用中的 MCP 相关信息。\n \n ![MCP Tracing Screenshot](../assets/images/mcp-tracing.jpg)\n \n-## 延伸阅读\n+## Further reading\n \n - [Model Context Protocol](https://modelcontextprotocol.io/) – 规范与设计指南。\n - [examples/mcp](https://github.com/openai/openai-agents-python/tree/main/examples/mcp) – 可运行的 stdio、SSE 与 Streamable HTTP 示例。\n-- [examples/hosted_mcp](https://github.com/openai/openai-agents-python/tree/main/examples/hosted_mcp) – 完整的托管 MCP 演示，包含审批与连接器。\n\\ No newline at end of file\n+- [examples/hosted_mcp](https://github.com/openai/openai-agents-python/tree/main/examples/hosted_mcp) – 完整的 hosted MCP 演示，包括审批与连接器。\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Fmcp.md",
        "sha": "55bc14d6faa406ecfe656201e3ba12b791feaa9c",
        "status": "modified"
      },
      {
        "additions": 39,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Fmodels%2Findex.md",
        "changes": 78,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fzh%2Fmodels%2Findex.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 39,
        "filename": "docs/zh/models/index.md",
        "patch": "@@ -6,18 +6,18 @@ search:\n \n Agents SDK 开箱即用地支持两种 OpenAI 模型用法：\n \n-- **推荐**：[`OpenAIResponsesModel`][agents.models.openai_responses.OpenAIResponsesModel]，使用新的 [Responses API](https://platform.openai.com/docs/api-reference/responses) 调用 OpenAI API。\n-- [`OpenAIChatCompletionsModel`][agents.models.openai_chatcompletions.OpenAIChatCompletionsModel]，使用 [Chat Completions API](https://platform.openai.com/docs/api-reference/chat) 调用 OpenAI API。\n+-   **推荐**：[`OpenAIResponsesModel`][agents.models.openai_responses.OpenAIResponsesModel]，通过全新的 [Responses API](https://platform.openai.com/docs/api-reference/responses) 调用 OpenAI API。\n+-   [`OpenAIChatCompletionsModel`][agents.models.openai_chatcompletions.OpenAIChatCompletionsModel]，通过 [Chat Completions API](https://platform.openai.com/docs/api-reference/chat) 调用 OpenAI API。\n \n ## OpenAI 模型\n \n-当你在初始化 `Agent` 时未指定模型，将使用默认模型。当前默认是为兼容性与低延迟而设定的 [`gpt-4.1`](https://platform.openai.com/docs/models/gpt-4.1)。如果你有权限，我们建议将你的智能体设置为 [`gpt-5.2`](https://platform.openai.com/docs/models/gpt-5.2) 以获得更高质量，同时保留显式的 `model_settings`。\n+当你在初始化 `Agent` 时没有指定模型时，将使用默认模型。当前默认模型为兼容性和低延迟考虑所选的 [`gpt-4.1`](https://platform.openai.com/docs/models/gpt-4.1)。如果你有访问权限，建议将你的智能体设置为 [`gpt-5.2`](https://platform.openai.com/docs/models/gpt-5.2)，以获得更高质量，同时保留显式的 `model_settings`。\n \n-如果你想切换到其他模型，如 [`gpt-5.2`](https://platform.openai.com/docs/models/gpt-5.2)，请参照下一节的步骤。\n+如果你想切换到其他模型，如 [`gpt-5.2`](https://platform.openai.com/docs/models/gpt-5.2)，请按照下一节的步骤进行。\n \n ### 默认 OpenAI 模型\n \n-如果希望对所有未设置自定义模型的智能体始终使用某个特定模型，请在运行你的智能体之前设置 `OPENAI_DEFAULT_MODEL` 环境变量。\n+如果你希望在所有未设置自定义模型的智能体中统一使用某个特定模型，请在运行你的智能体之前设置 `OPENAI_DEFAULT_MODEL` 环境变量。\n \n ```bash\n export OPENAI_DEFAULT_MODEL=gpt-5\n@@ -26,9 +26,9 @@ python3 my_awesome_agent.py\n \n #### GPT-5 模型\n \n-当你以这种方式使用任一 GPT-5 推理模型（[`gpt-5`](https://platform.openai.com/docs/models/gpt-5)、[`gpt-5-mini`](https://platform.openai.com/docs/models/gpt-5-mini) 或 [`gpt-5-nano`](https://platform.openai.com/docs/models/gpt-5-nano)）时，SDK 会默认应用合理的 `ModelSettings`。具体来说，它会将 `reasoning.effort` 和 `verbosity` 都设置为 `\"low\"`。如果你希望自行构建这些设置，可调用 `agents.models.get_default_model_settings(\"gpt-5\")`。\n+当你以上述方式使用任一 GPT-5 推理模型（[`gpt-5`](https://platform.openai.com/docs/models/gpt-5)、[`gpt-5-mini`](https://platform.openai.com/docs/models/gpt-5-mini) 或 [`gpt-5-nano`](https://platform.openai.com/docs/models/gpt-5-nano)）时，SDK 会默认应用合理的 `ModelSettings`。具体而言，它会将 `reasoning.effort` 和 `verbosity` 都设置为 `\"low\"`。如果你想自行构建这些设置，请调用 `agents.models.get_default_model_settings(\"gpt-5\")`。\n \n-若需更低延迟或满足特定需求，你可以选择不同的模型和设置。要为默认模型调整推理强度，请传入你自己的 `ModelSettings`：\n+为了获得更低的延迟或满足特定需求，你可以选择不同的模型和设置。若要调整默认模型的推理强度，请传入你自己的 `ModelSettings`：\n \n ```python\n from openai.types.shared import Reasoning\n@@ -44,21 +44,21 @@ my_agent = Agent(\n )\n ```\n \n-特别是为了更低延迟，使用 [`gpt-5-mini`](https://platform.openai.com/docs/models/gpt-5-mini) 或 [`gpt-5-nano`](https://platform.openai.com/docs/models/gpt-5-nano) 且设置 `reasoning.effort=\"minimal\"` 往往会比默认设置更快返回响应。不过，Responses API 中的一些内置工具（例如 文件检索 与 图像生成）不支持 `\"minimal\"` 推理强度，这也是本 Agents SDK 默认使用 `\"low\"` 的原因。\n+如需进一步降低延迟，将 [`gpt-5-mini`](https://platform.openai.com/docs/models/gpt-5-mini) 或 [`gpt-5-nano`](https://platform.openai.com/docs/models/gpt-5-nano) 与 `reasoning.effort=\"minimal\"` 搭配使用，通常会比默认设置更快返回响应。但请注意，Responses API 中的一些内置工具（例如文件检索和图像生成）不支持 `\"minimal\"` 推理强度，因此本 Agents SDK 的默认值为 `\"low\"`。\n \n #### 非 GPT-5 模型\n \n-如果你传入非 GPT-5 的模型名且未提供自定义 `model_settings`，SDK 会回退到与任意模型兼容的通用 `ModelSettings`。\n+如果你传入的是非 GPT-5 的模型名称且没有自定义 `model_settings`，SDK 会回退到兼容任意模型的通用 `ModelSettings`。\n \n ## 非 OpenAI 模型\n \n-你可以通过 [LiteLLM 集成](../litellm.md) 使用大多数其他非 OpenAI 模型。首先，安装 litellm 依赖组：\n+你可以通过 [LiteLLM 集成](./litellm.md)使用大多数其他非 OpenAI 模型。首先，安装 litellm 依赖组：\n \n ```bash\n pip install \"openai-agents[litellm]\"\n ```\n \n-然后，使用任一[受支持的模型](https://docs.litellm.ai/docs/providers)，并添加 `litellm/` 前缀：\n+然后，使用带有 `litellm/` 前缀的任意[受支持模型](https://docs.litellm.ai/docs/providers)：\n \n ```python\n claude_agent = Agent(model=\"litellm/anthropic/claude-3-5-sonnet-20240620\", ...)\n@@ -67,29 +67,29 @@ gemini_agent = Agent(model=\"litellm/gemini/gemini-2.5-flash-preview-04-17\", ...)\n \n ### 使用非 OpenAI 模型的其他方式\n \n-你可以再通过 3 种方式集成其他 LLM 提供方（code examples 见[此处](https://github.com/openai/openai-agents-python/tree/main/examples/model_providers/)）：\n+你还可以通过另外 3 种方式集成其他 LLM 提供商（示例见[此处](https://github.com/openai/openai-agents-python/tree/main/examples/model_providers/)）：\n \n-1. [`set_default_openai_client`][agents.set_default_openai_client] 适用于希望全局使用一个 `AsyncOpenAI` 实例作为 LLM 客户端的场景。适用于 LLM 提供方具备 OpenAI 兼容的 API 端点，并可设置 `base_url` 和 `api_key` 的情况。可参见可配置示例：[examples/model_providers/custom_example_global.py](https://github.com/openai/openai-agents-python/tree/main/examples/model_providers/custom_example_global.py)。\n-2. [`ModelProvider`][agents.models.interface.ModelProvider] 作用于 `Runner.run` 层级。这允许你在一次运行中指定“为所有智能体使用自定义模型提供方”。可参见可配置示例：[examples/model_providers/custom_example_provider.py](https://github.com/openai/openai-agents-python/tree/main/examples/model_providers/custom_example_provider.py)。\n-3. [`Agent.model`][agents.agent.Agent.model] 允许你在特定的 Agent 实例上指定模型。这使你可以为不同智能体混合搭配不同的提供方。可参见可配置示例：[examples/model_providers/custom_example_agent.py](https://github.com/openai/openai-agents-python/tree/main/examples/model_providers/custom_example_agent.py)。使用大多数可用模型的简便方式是通过 [LiteLLM 集成](../litellm.md)。\n+1. [`set_default_openai_client`][agents.set_default_openai_client] 适用于你希望全局使用一个 `AsyncOpenAI` 实例作为 LLM 客户端的场景。适用于 LLM 提供商拥有 OpenAI 兼容 API 端点，且你可以设置 `base_url` 和 `api_key` 的情况。可在 [examples/model_providers/custom_example_global.py](https://github.com/openai/openai-agents-python/tree/main/examples/model_providers/custom_example_global.py) 查看可配置示例。\n+2. [`ModelProvider`][agents.models.interface.ModelProvider] 作用于 `Runner.run` 层级。这允许你在一次运行中为所有智能体指定“使用自定义模型提供商”。可在 [examples/model_providers/custom_example_provider.py](https://github.com/openai/openai-agents-python/tree/main/examples/model_providers/custom_example_provider.py) 查看可配置示例。\n+3. [`Agent.model`][agents.agent.Agent.model] 允许你在特定的 Agent 实例上指定模型。这样你可以为不同智能体混搭不同的提供商。可在 [examples/model_providers/custom_example_agent.py](https://github.com/openai/openai-agents-python/tree/main/examples/model_providers/custom_example_agent.py) 查看可配置示例。使用大多数现有模型的简便方式是通过 [LiteLLM 集成](./litellm.md)。\n \n-在你没有来自 `platform.openai.com` 的 API key 时，建议通过 `set_tracing_disabled()` 禁用追踪，或设置一个[不同的追踪进程](../tracing.md)。\n+在你没有来自 `platform.openai.com` 的 API key 的情况下，我们建议通过 `set_tracing_disabled()` 禁用追踪，或设置[不同的追踪进程](../tracing.md)。\n \n !!! note\n \n-    在这些示例中，我们使用 Chat Completions API/模型，因为大多数 LLM 提供方尚不支持 Responses API。如果你的 LLM 提供方支持，建议使用 Responses。\n+    在这些示例中，我们使用 Chat Completions API/模型，因为大多数 LLM 提供商尚不支持 Responses API。如果你的 LLM 提供商支持，我们推荐使用 Responses。\n \n-## 模型的混合搭配\n+## 模型混搭\n \n-在单个工作流内，你可能希望为不同智能体使用不同模型。例如，你可以用更小更快的模型做分诊，而将更大更强的模型用于复杂任务。在配置 [`Agent`][agents.Agent] 时，你可以通过以下方式之一选择特定模型：\n+在单个工作流中，你可能希望为每个智能体使用不同的模型。例如，你可以使用更小、更快的模型进行分诊，同时为复杂任务使用更大、更强的模型。在配置 [`Agent`][agents.Agent] 时，你可以通过以下任一方式选择特定模型：\n \n-1. 直接传入模型名称。\n-2. 传入任意模型名称 + 一个可以将该名称映射到 Model 实例的 [`ModelProvider`][agents.models.interface.ModelProvider]。\n+1. 传入模型名称。\n+2. 传入任意模型名称 + 一个可将该名称映射为 Model 实例的 [`ModelProvider`][agents.models.interface.ModelProvider]。\n 3. 直接提供一个 [`Model`][agents.models.interface.Model] 实现。\n \n !!!note\n \n-    虽然我们的 SDK 同时支持 [`OpenAIResponsesModel`][agents.models.openai_responses.OpenAIResponsesModel] 和 [`OpenAIChatCompletionsModel`][agents.models.openai_chatcompletions.OpenAIChatCompletionsModel] 两种形态，但我们建议在每个工作流中使用单一模型形态，因为这两种形态支持的功能和工具不同。如果你的工作流确实需要混合使用模型形态，请确保你使用的所有功能在两者上都可用。\n+    虽然我们的 SDK 同时支持 [`OpenAIResponsesModel`][agents.models.openai_responses.OpenAIResponsesModel] 和 [`OpenAIChatCompletionsModel`][agents.models.openai_chatcompletions.OpenAIChatCompletionsModel] 两种形态，但我们建议在每个工作流中使用单一模型形态，因为两种形态支持的特性和工具集不同。如果你的工作流确实需要混搭不同模型形态，请确保你所使用的全部特性在两种形态中都可用。\n \n ```python\n from agents import Agent, Runner, AsyncOpenAI, OpenAIChatCompletionsModel\n@@ -122,10 +122,10 @@ async def main():\n     print(result.final_output)\n ```\n \n-1. 直接设置一个 OpenAI 模型名称。\n-2. 提供一个 [`Model`][agents.models.interface.Model] 实现。\n+1.  直接设置一个 OpenAI 模型的名称。\n+2.  提供一个 [`Model`][agents.models.interface.Model] 实现。\n \n-当你希望进一步配置某个智能体所用模型时，可以传入 [`ModelSettings`][agents.models.interface.ModelSettings]，它提供诸如 temperature 等可选的模型配置参数。\n+当你希望进一步配置某个智能体所用的模型时，可以传入 [`ModelSettings`][agents.models.interface.ModelSettings]，它提供如 temperature 等可选的模型配置参数。\n \n ```python\n from agents import Agent, ModelSettings\n@@ -138,7 +138,7 @@ english_agent = Agent(\n )\n ```\n \n-此外，当你使用 OpenAI 的 Responses API 时，[还有一些其他可选参数](https://platform.openai.com/docs/api-reference/responses/create)（例如 `user`、`service_tier` 等）。如果它们不在顶层可用，你可以使用 `extra_args` 来传入它们。\n+此外，当你使用 OpenAI 的 Responses API 时，[还有一些其他可选参数](https://platform.openai.com/docs/api-reference/responses/create)（例如 `user`、`service_tier` 等）。如果它们不在顶层可用，你可以使用 `extra_args` 进行传递。\n \n ```python\n from agents import Agent, ModelSettings\n@@ -154,39 +154,39 @@ english_agent = Agent(\n )\n ```\n \n-## 使用其他 LLM 提供方的常见问题\n+## 使用其他 LLM 提供商的常见问题\n \n ### 追踪客户端错误 401\n \n-如果你遇到与追踪相关的错误，这是因为追踪会上传到 OpenAI 服务，而你没有 OpenAI API key。你有三种方式解决：\n+如果你遇到与追踪相关的错误，这是因为追踪数据会上传到 OpenAI 服务，而你没有 OpenAI 的 API key。你有三种方式解决：\n \n 1. 完全禁用追踪：[`set_tracing_disabled(True)`][agents.set_tracing_disabled]。\n-2. 为追踪设置一个 OpenAI key：[`set_tracing_export_api_key(...)`][agents.set_tracing_export_api_key]。该 API key 仅用于上传追踪数据，且必须来自 [platform.openai.com](https://platform.openai.com/)。\n+2. 为追踪设置一个 OpenAI key：[`set_tracing_export_api_key(...)`][agents.set_tracing_export_api_key]。该 API key 仅用于上传追踪，且必须来自 [platform.openai.com](https://platform.openai.com/)。\n 3. 使用非 OpenAI 的追踪进程。参见[追踪文档](../tracing.md#custom-tracing-processors)。\n \n ### Responses API 支持\n \n-SDK 默认使用 Responses API，但大多数其他 LLM 提供方尚不支持。因此你可能会看到 404 或类似问题。要解决，你有两种选择：\n+SDK 默认使用 Responses API，但大多数其他 LLM 提供商尚未支持。因此你可能会看到 404 或类似问题。要解决，你有两个选项：\n \n-1. 调用 [`set_default_openai_api(\"chat_completions\")`][agents.set_default_openai_api]。当你通过环境变量设置了 `OPENAI_API_KEY` 和 `OPENAI_BASE_URL` 时有效。\n-2. 使用 [`OpenAIChatCompletionsModel`][agents.models.openai_chatcompletions.OpenAIChatCompletionsModel]。code examples 见[此处](https://github.com/openai/openai-agents-python/tree/main/examples/model_providers/)。\n+1. 调用 [`set_default_openai_api(\"chat_completions\")`][agents.set_default_openai_api]。当你通过环境变量设置了 `OPENAI_API_KEY` 和 `OPENAI_BASE_URL` 时，这将生效。\n+2. 使用 [`OpenAIChatCompletionsModel`][agents.models.openai_chatcompletions.OpenAIChatCompletionsModel]。示例见[这里](https://github.com/openai/openai-agents-python/tree/main/examples/model_providers/)。\n \n ### Structured outputs 支持\n \n-一些模型提供方不支持 [structured outputs](https://platform.openai.com/docs/guides/structured-outputs)。这有时会导致类似如下的错误：\n+有些模型提供商不支持 [structured outputs](https://platform.openai.com/docs/guides/structured-outputs)。这有时会导致类似如下的错误：\n \n ```\n \n BadRequestError: Error code: 400 - {'error': {'message': \"'response_format.type' : value is not one of the allowed values ['text','json_object']\", 'type': 'invalid_request_error'}}\n \n ```\n \n-这是部分模型提供方的不足——它们支持 JSON 输出，但不允许你为输出指定要使用的 `json_schema`。我们正在努力修复此问题，但我们建议依赖那些支持 JSON schema 输出的提供方，否则你的应用常会因为 JSON 格式不正确而出错。\n+这是部分模型提供商的不足——它们支持 JSON 输出，但不允许你为输出指定要使用的 `json_schema`。我们正在努力修复此问题，但我们建议依赖那些支持 JSON schema 输出的提供商，否则你的应用可能会因 JSON 不合规而经常出错。\n \n-## 不同提供方间的模型混用\n+## 跨提供商混用模型\n \n-你需要了解不同模型提供方之间的功能差异，否则可能会遇到错误。例如，OpenAI 支持 structured outputs、多模态输入，以及托管的 文件检索 和 网络检索，但许多其他提供方并不支持这些功能。请注意以下限制：\n+你需要留意不同模型提供商之间的特性差异，否则可能会遇到错误。例如，OpenAI 支持 structured outputs、多模态输入，以及托管的文件检索和网络检索，但许多其他提供商并不支持这些特性。请注意以下限制：\n \n-- 不要向不支持的提供方发送其无法理解的 `tools`\n-- 在调用仅支持文本的模型前，先过滤掉多模态输入\n-- 注意不支持结构化 JSON 输出的提供方偶尔会生成无效的 JSON。\n\\ No newline at end of file\n+-   不要向不支持的提供商发送它们无法理解的 `tools`\n+-   在调用文本-only 的模型前过滤掉多模态输入\n+-   注意不支持结构化 JSON 输出的提供商偶尔会生成无效的 JSON。\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Fmodels%2Findex.md",
        "sha": "add8b83682351e8b3e5bb366654af2530ce93a6a",
        "status": "modified"
      },
      {
        "additions": 8,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Fmodels%2Flitellm.md",
        "changes": 16,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fzh%2Fmodels%2Flitellm.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 8,
        "filename": "docs/zh/models/litellm.md",
        "patch": "@@ -6,13 +6,13 @@ search:\n \n !!! note\n \n-    LiteLLM 集成处于测试阶段。你在使用某些模型提供商（尤其是较小的提供商）时可能会遇到问题。请通过 [Github issues](https://github.com/openai/openai-agents-python/issues) 报告问题，我们会尽快修复。\n+    LiteLLM 集成处于测试阶段。你可能会在部分模型提供方（尤其是较小的提供方）上遇到问题。请通过 [Github issues](https://github.com/openai/openai-agents-python/issues) 报告问题，我们会尽快修复。\n \n-[LiteLLM](https://docs.litellm.ai/docs/) 是一个库，可通过统一接口使用 100+ 个模型。我们在 Agents SDK 中加入了 LiteLLM 集成，让你可以使用任意 AI 模型。\n+[LiteLLM](https://docs.litellm.ai/docs/) 是一个库，可通过统一接口使用 100+ 模型。我们在 Agents SDK 中加入了 LiteLLM 集成，以便你使用任意 AI 模型。\n \n ## 设置\n \n-你需要确保可用 `litellm`。可以通过安装可选的 `litellm` 依赖组来完成：\n+你需要确保可用 `litellm`。可通过安装可选的 `litellm` 依赖组来完成：\n \n ```bash\n pip install \"openai-agents[litellm]\"\n@@ -22,13 +22,13 @@ pip install \"openai-agents[litellm]\"\n \n ## 示例\n \n-这是一个可直接运行的示例。运行后会提示你输入模型名称和 API key。例如，你可以输入：\n+这是一个可直接运行的示例。运行后会提示输入模型名称和 API key。例如，你可以输入：\n \n-- `openai/gpt-4.1` 作为模型，并使用你的 OpenAI API key\n-- `anthropic/claude-3-5-sonnet-20240620` 作为模型，并使用你的 Anthropic API key\n+- `openai/gpt-4.1` 作为模型，并提供你的 OpenAI API key\n+- `anthropic/claude-3-5-sonnet-20240620` 作为模型，并提供你的 Anthropic API key\n - 等等\n \n-有关 LiteLLM 支持的完整模型列表，请参见 [litellm providers 文档](https://docs.litellm.ai/docs/providers)。\n+LiteLLM 支持的完整模型列表请见 [litellm providers docs](https://docs.litellm.ai/docs/providers)。\n \n ```python\n from __future__ import annotations\n@@ -91,4 +91,4 @@ agent = Agent(\n )\n ```\n \n-使用 `include_usage=True` 后，LiteLLM 请求会像内置的 OpenAI 模型一样，通过 `result.context_wrapper.usage` 报告 token 和请求计数。\n\\ No newline at end of file\n+设置 `include_usage=True` 后，LiteLLM 请求会像内置的 OpenAI 模型一样，通过 `result.context_wrapper.usage` 报告 token 和请求计数。\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Fmodels%2Flitellm.md",
        "sha": "3325b5cbe59ddfbe69627f1d4053e5a4a8fceab1",
        "status": "modified"
      },
      {
        "additions": 25,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Fmulti_agent.md",
        "changes": 50,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fzh%2Fmulti_agent.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 25,
        "filename": "docs/zh/multi_agent.md",
        "patch": "@@ -2,40 +2,40 @@\n search:\n   exclude: true\n ---\n-# 编排多个智能体\n+# 多智能体编排\n \n-编排指的是你在应用中组织智能体的流程：哪些智能体运行、以什么顺序运行、以及如何决定下一步做什么。编排智能体主要有两种方式：\n+编排指的是你应用中智能体的流转：哪些智能体运行、按什么顺序运行、以及它们如何决定下一步。编排智能体主要有两种方式：\n \n-1. 让 LLM 做决策：利用 LLM 的智能来规划、推理，并据此决定采取哪些步骤。\n-2. 通过代码进行编排：用你的代码来决定智能体的流程。\n+1. 让 LLM 决策：利用 LLM 的智能进行规划、推理，并据此决定要采取的步骤。\n+2. 通过代码编排：通过你的代码来确定智能体的流程。\n \n-你可以混合使用这些模式。每种方式都有取舍，详见下文。\n+你可以混合使用这些模式。每种方式都有取舍，详述如下。\n \n-## 通过 LLM 编排\n+## 基于 LLM 的编排\n \n-一个智能体是一个配备了 instructions、工具和任务转移 的 LLM。这意味着在给定一个开放式任务时，LLM 可以自主规划如何完成任务，使用工具来采取行动并获取数据，并通过任务转移把子任务委派给子智能体。比如，一个研究型智能体可以配备如下工具：\n+一个智能体是配备了 instructions、tools 和 任务转移 的 LLM。这意味着面对开放式任务时，LLM 可以自主规划如何完成任务：使用工具采取行动并获取数据，并通过任务转移将子任务委派给子智能体。比如，一个研究型智能体可以配备以下工具：\n \n-- 网络检索：在线查找信息\n-- 文件检索与读取：在专有数据与连接中进行搜索\n-- 计算机操作：在计算机上执行操作\n-- 代码执行：进行数据分析\n-- 任务转移：委派给擅长规划、撰写报告等的专业智能体\n+- 网络检索以在线查找信息\n+- 文件检索与读取以搜索专有数据和外部连接\n+- 计算机操作以在计算机上执行动作\n+- 代码执行以进行数据分析\n+- 向擅长规划、报告撰写等的专业智能体进行任务转移\n \n-当任务是开放式、且你希望依赖 LLM 的智能时，这种模式非常适用。关键做法包括：\n+当任务是开放式且你希望依赖 LLM 的智能时，这种模式非常适合。关键做法包括：\n \n-1. 投入打磨高质量提示词。清楚说明可用的工具、如何使用它们，以及必须遵循的参数范围。\n-2. 监控并迭代你的应用。观察问题出现在哪里，并迭代优化你的提示词。\n-3. 允许智能体自省与改进。比如，让其在循环中运行并自我评审；或者提供错误信息，让其据此改进。\n-4. 使用在单一任务上表现卓越的专业智能体，而非期待一个通用智能体在所有方面都很出色。\n-5. 投入到[评测 (evals)](https://platform.openai.com/docs/guides/evals)。这能帮助你训练智能体，逐步提升其完成任务的能力。\n+1. 投入编写优质提示词。清晰说明可用的工具、如何使用它们，以及必须遵循的参数与边界。\n+2. 监控你的应用并迭代改进。找出问题所在，不断改进提示词。\n+3. 允许智能体自省与改进。例如，将其在循环中运行，让其自我批判；或提供错误信息并让其改进。\n+4. 让专门化智能体专注单一任务，而不是让一个通用智能体“面面俱到”。\n+5. 投入 [评测](https://platform.openai.com/docs/guides/evals)。这有助于训练你的智能体提升并更好地完成任务。\n \n-## 通过代码编排\n+## 基于代码的编排\n \n-尽管通过 LLM 编排功能强大，通过代码编排能在速度、成本和性能上使任务更确定且可预测。常见模式包括：\n+尽管基于 LLM 的编排很强大，但通过代码编排可以在速度、成本和性能方面更具确定性和可预测性。常见模式包括：\n \n-- 使用[structured outputs](https://platform.openai.com/docs/guides/structured-outputs)来生成你可以用代码检查的格式良好的数据。比如，你可以让一个智能体把任务分类到几个目录中，然后基于该目录选择下一个智能体。\n-- 将多个智能体串联起来，把上一个的输出转换为下一个的输入。你可以把“撰写博客文章”这样的任务分解为一系列步骤——做研究、写大纲、写正文、评审并改进。\n-- 在一个执行任务的智能体与一个负责评估和反馈的智能体之间使用 `while` 循环运行，直到评估者判定输出满足某些标准。\n-- 并行运行多个智能体，例如通过 Python 基本组件如 `asyncio.gather`。当你有多个彼此不依赖的任务时，这对提升速度很有帮助。\n+- 使用 [structured outputs](https://platform.openai.com/docs/guides/structured-outputs) 生成可由你代码检查的格式良好的数据。例如，你可以让一个智能体将任务分类到若干目录，然后基于该目录选择下一个智能体。\n+- 将一个智能体的输出转换为下一个智能体的输入来串联多个智能体。你可以把撰写博客这样的任务分解为一系列步骤——进行研究、写出大纲、撰写正文、批判性审阅、然后改进。\n+- 让执行任务的智能体与负责评估并提供反馈的智能体在 `while` 循环中配合运行，直到评估者确认输出满足某些标准。\n+- 并行运行多个智能体，例如通过 Python 基本组件如 `asyncio.gather`。当有彼此不依赖的多个任务时，这有助于提升速度。\n \n-我们在[`examples/agent_patterns`](https://github.com/openai/openai-agents-python/tree/main/examples/agent_patterns)中提供了许多 code examples。\n\\ No newline at end of file\n+我们在 [`examples/agent_patterns`](https://github.com/openai/openai-agents-python/tree/main/examples/agent_patterns) 中提供了若干 code examples。\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Fmulti_agent.md",
        "sha": "67308cf74a9d7b17ae49a933a3d293911c2cb630",
        "status": "modified"
      },
      {
        "additions": 19,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Fquickstart.md",
        "changes": 38,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fzh%2Fquickstart.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 19,
        "filename": "docs/zh/quickstart.md",
        "patch": "@@ -2,9 +2,9 @@\n search:\n   exclude: true\n ---\n-# 快速开始\n+# 快速入门\n \n-## 创建项目与虚拟环境\n+## 项目与虚拟环境创建\n \n 你只需执行一次。\n \n@@ -16,7 +16,7 @@ python -m venv .venv\n \n ### 激活虚拟环境\n \n-每次开启新终端会话时都需要执行。\n+每次开启新的终端会话时都需要执行。\n \n ```bash\n source .venv/bin/activate\n@@ -28,15 +28,15 @@ source .venv/bin/activate\n pip install openai-agents # or `uv add openai-agents`, etc\n ```\n \n-### 设置 OpenAI API 密钥\n+### 设置 OpenAI API key\n \n-如果你还没有，请按照[这些说明](https://platform.openai.com/docs/quickstart#create-and-export-an-api-key)创建一个 OpenAI API 密钥。\n+如果你还没有，请按照[这些说明](https://platform.openai.com/docs/quickstart#create-and-export-an-api-key)创建 OpenAI API key。\n \n ```bash\n export OPENAI_API_KEY=sk-...\n ```\n \n-## 创建你的第一个智能体\n+## 第一个智能体创建\n \n 智能体由 instructions、名称和可选配置（例如 `model_config`）定义。\n \n@@ -49,9 +49,9 @@ agent = Agent(\n )\n ```\n \n-## 再添加几个智能体\n+## 更多智能体添加\n \n-其他智能体也可用相同方式定义。`handoff_descriptions` 提供用于确定任务转移路由的额外上下文。\n+可以用同样的方式定义其他智能体。`handoff_descriptions` 提供用于确定任务转移路由的附加上下文。\n \n ```python\n from agents import Agent\n@@ -69,9 +69,9 @@ math_tutor_agent = Agent(\n )\n ```\n \n-## 定义你的任务转移\n+## 任务转移定义\n \n-在每个智能体上，你可以定义一个可供选择的外发任务转移选项清单，以决定如何推动其任务进展。\n+在每个智能体上，你可以定义一组可选的外发任务转移项，智能体可从中选择以决定如何推进其任务。\n \n ```python\n triage_agent = Agent(\n@@ -81,9 +81,9 @@ triage_agent = Agent(\n )\n ```\n \n-## 运行智能体编排\n+## 智能体编排运行\n \n-让我们检查工作流是否运行，以及分诊智能体是否在两个专家智能体之间正确路由。\n+让我们检查工作流是否运行，以及分诊智能体是否在两个专家型智能体之间正确路由。\n \n ```python\n from agents import Runner\n@@ -93,9 +93,9 @@ async def main():\n     print(result.final_output)\n ```\n \n-## 添加安全防护措施\n+## 安全防护措施添加\n \n-你可以定义自定义的安全防护措施，作用于输入或输出。\n+你可以定义自定义的安全防护措施来作用于输入或输出。\n \n ```python\n from agents import GuardrailFunctionOutput, Agent, Runner\n@@ -121,9 +121,9 @@ async def homework_guardrail(ctx, agent, input_data):\n     )\n ```\n \n-## 整体运行\n+## 全部串联\n \n-让我们把它们组合起来，运行完整工作流，使用任务转移和输入安全防护措施。\n+让我们把所有内容串联起来，运行整个工作流，使用任务转移和输入安全防护措施。\n \n ```python\n from agents import Agent, InputGuardrail, GuardrailFunctionOutput, Runner\n@@ -190,14 +190,14 @@ if __name__ == \"__main__\":\n     asyncio.run(main())\n ```\n \n-## 查看你的追踪\n+## 追踪查看\n \n-要回顾智能体运行期间发生的情况，请前往 [OpenAI 控制台中的 Trace 查看器](https://platform.openai.com/traces)查看你的运行追踪。\n+要回顾智能体运行期间发生的情况，请前往 [OpenAI 控制台中的 Trace viewer](https://platform.openai.com/traces) 查看你的智能体运行追踪。\n \n ## 后续步骤\n \n 了解如何构建更复杂的智能体流程：\n \n-- 学习如何配置[智能体](agents.md)。\n+- 了解如何配置[智能体](agents.md)。\n - 了解[运行智能体](running_agents.md)。\n - 了解[工具](tools.md)、[安全防护措施](guardrails.md)和[模型](models/index.md)。\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Fquickstart.md",
        "sha": "d7f96cb9122bf76188ce6715a68c60bb5d19289a",
        "status": "modified"
      },
      {
        "additions": 44,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Frealtime%2Fguide.md",
        "changes": 88,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fzh%2Frealtime%2Fguide.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 44,
        "filename": "docs/zh/realtime/guide.md",
        "patch": "@@ -4,65 +4,65 @@ search:\n ---\n # 指南\n \n-本指南深入介绍如何使用 OpenAI Agents SDK 的实时能力来构建语音增强的 AI 智能体。\n+本指南深入介绍如何使用 OpenAI Agents SDK 的实时功能来构建语音能力的 AI 智能体。\n \n !!! warning \"测试版功能\"\n-实时智能体处于测试阶段。随着我们改进实现，可能会出现不兼容的变更。\n+实时智能体处于测试阶段。随着实现的改进，可能会发生不兼容变更。\n \n-## 概览\n+## 概述\n \n-实时智能体支持对话式流程，能够实时处理音频和文本输入，并以实时音频进行响应。它们与 OpenAI 的 Realtime API 保持持久连接，从而实现低延迟的自然语音对话，并能优雅地处理打断。\n+实时智能体支持对话式流程，实时处理音频与文本输入，并以实时音频进行响应。它们与 OpenAI 的 Realtime API 保持持久连接，实现低延迟、可自然打断的语音对话体验。\n \n ## 架构\n \n ### 核心组件\n \n-实时系统由以下关键组件组成：\n+实时系统由以下关键组件构成：\n \n-- **RealtimeAgent**: 一个智能体，配置了 instructions、tools 和 任务转移。\n-- **RealtimeRunner**: 管理配置。你可以调用 `runner.run()` 获取一个会话。\n-- **RealtimeSession**: 单次交互会话。通常在每次用户开始对话时创建一个，并在对话结束前保持存活。\n-- **RealtimeModel**: 底层模型接口（通常是 OpenAI 的 WebSocket 实现）\n+-   **RealtimeAgent**: 一个智能体，通过 instructions、tools 和 handoffs 进行配置。\n+-   **RealtimeRunner**: 管理配置。你可以调用 `runner.run()` 获取会话。\n+-   **RealtimeSession**: 单次交互会话。通常在每次用户开始对话时创建，并在对话结束前保持存活。\n+-   **RealtimeModel**: 底层模型接口（通常是 OpenAI 的 WebSocket 实现）\n \n ### 会话流程\n \n-一个典型的实时会话遵循以下流程：\n+典型的实时会话流程如下：\n \n-1. 使用 instructions、tools 和 任务转移 创建你的 **RealtimeAgent（们）**。\n-2. 使用智能体和配置选项 **设置 RealtimeRunner**。\n-3. 使用 `await runner.run()` **启动会话**，该调用返回一个 RealtimeSession。\n-4. 使用 `send_audio()` 或 `send_message()` **向会话发送音频或文本消息**。\n-5. **监听事件**，通过迭代会话对象获取事件——包括音频输出、转录、工具调用、任务转移和错误。\n-6. **处理打断**：当用户打断发言时，会自动停止当前音频生成。\n+1. **创建 RealtimeAgent**，并配置 instructions、tools 和 handoffs。\n+2. **设置 RealtimeRunner**，提供智能体与相关配置项\n+3. **启动会话**，使用 `await runner.run()` 获取一个 RealtimeSession。\n+4. **发送音频或文本消息**，使用 `send_audio()` 或 `send_message()`\n+5. **监听事件**，通过遍历会话对象来接收事件——包括音频输出、转写文本、工具调用、任务转移以及错误\n+6. **处理打断**，当用户在智能体说话时开口，会自动停止当前音频生成\n \n 会话会维护对话历史，并管理与实时模型的持久连接。\n \n ## 智能体配置\n \n-RealtimeAgent 的工作方式与常规 Agent 类似，但有一些关键差异。完整 API 详情参见 [`RealtimeAgent`][agents.realtime.agent.RealtimeAgent] API 参考。\n+RealtimeAgent 的工作方式与常规 Agent 类似，但有一些关键差异。完整 API 详情见 [`RealtimeAgent`][agents.realtime.agent.RealtimeAgent] API 参考。\n \n-与常规智能体的主要差异：\n+与常规智能体的主要区别：\n \n-- 模型选择在会话级别配置，而不是在智能体级别。\n-- 不支持 structured outputs（不支持 `outputType`）。\n-- 声音可按智能体配置，但在第一个智能体开始说话后不可更改。\n-- 其他功能（如 tools、任务转移 和 instructions）工作方式相同。\n+-   模型选择在会话级配置，而非智能体级。\n+-   不支持 structured outputs（不支持 `outputType`）。\n+-   可为每个智能体配置语音，但在首个智能体说话后不可更改。\n+-   其他功能如 tools、handoffs 与 instructions 的用法一致。\n \n ## 会话配置\n \n ### 模型设置\n \n-会话配置允许你控制底层实时模型的行为。你可以配置模型名称（例如 `gpt-realtime`）、语音选择（alloy、echo、fable、onyx、nova、shimmer）以及支持的模态（文本和/或音频）。可分别设置输入与输出的音频格式，默认为 PCM16。\n+会话配置允许你控制底层实时模型的行为。你可以配置模型名称（如 `gpt-realtime`）、语音选择（alloy、echo、fable、onyx、nova、shimmer），以及支持的模态（文本和/或音频）。音频格式可分别为输入与输出设置，默认是 PCM16。\n \n ### 音频配置\n \n-音频设置控制会话如何处理语音输入和输出。你可以使用如 Whisper 等模型配置输入音频转录，设置语言偏好，并提供转录提示以提升特定领域术语的准确性。轮次检测设置控制智能体何时开始和停止响应，可配置语音活动检测阈值、静默时长，以及检测语音的前后填充。\n+音频设置控制会话如何处理语音输入与输出。你可以使用如 Whisper 的模型进行输入音频转写，设置语言偏好，并提供转写提示以提升特定领域术语的准确性。轮次检测设置控制智能体何时开始和停止响应，可配置语音活动检测阈值、静音时长以及检测语音两侧的填充。\n \n ## 工具与函数\n \n ### 添加工具\n \n-与常规智能体相同，实时智能体支持在对话中执行的 function tools：\n+与常规智能体相同，实时智能体支持在对话中执行的工具调用：\n \n ```python\n from agents import function_tool\n@@ -90,7 +90,7 @@ agent = RealtimeAgent(\n \n ### 创建任务转移\n \n-任务转移允许在专业化的智能体之间转移对话。\n+任务转移允许在专门化智能体之间转移对话。\n \n ```python\n from agents.realtime import realtime_handoff\n@@ -119,22 +119,22 @@ main_agent = RealtimeAgent(\n \n ## 事件处理\n \n-会话会流式传输事件，你可以通过迭代会话对象进行监听。事件包括音频输出分片、转录结果、工具执行开始与结束、智能体任务转移以及错误。关键事件包括：\n+会话会流式推送事件，你可以通过遍历会话对象进行监听。事件包括音频输出分片、转写结果、工具执行的开始与结束、智能体任务转移以及错误。关键事件包括：\n \n-- **audio**: 来自智能体响应的原始音频数据\n-- **audio_end**: 智能体结束发言\n-- **audio_interrupted**: 用户打断了智能体\n-- **tool_start/tool_end**: 工具执行生命周期\n-- **handoff**: 发生智能体任务转移\n-- **error**: 处理期间发生错误\n+-   **audio**: 来自智能体响应的原始音频数据\n+-   **audio_end**: 智能体完成发声\n+-   **audio_interrupted**: 用户打断了智能体\n+-   **tool_start/tool_end**: 工具执行的生命周期\n+-   **handoff**: 发生了智能体任务转移\n+-   **error**: 处理过程中出现错误\n \n-完整事件详情参见 [`RealtimeSessionEvent`][agents.realtime.events.RealtimeSessionEvent]。\n+完整事件详情见 [`RealtimeSessionEvent`][agents.realtime.events.RealtimeSessionEvent]。\n \n ## 安全防护措施\n \n-实时智能体仅支持输出安全防护措施。为避免实时生成中的性能问题，这些安全防护措施会进行防抖处理并定期运行（而不是每个词都运行）。默认防抖长度为 100 个字符，但可配置。\n+实时智能体仅支持输出安全防护措施。这些防护是“防抖”的，并且定期运行（不会对每个词都执行），以避免实时生成中的性能问题。默认防抖长度为 100 个字符，可配置。\n \n-安全防护措施可以直接附加到 `RealtimeAgent`，或通过会话的 `run_config` 提供。两处提供的安全防护措施会同时运行。\n+安全防护措施可直接附加到 `RealtimeAgent`，或通过会话的 `run_config` 提供。两处提供的防护会共同生效。\n \n ```python\n from agents.guardrail import GuardrailFunctionOutput, OutputGuardrail\n@@ -152,19 +152,19 @@ agent = RealtimeAgent(\n )\n ```\n \n-当安全防护措施被触发时，会生成 `guardrail_tripped` 事件，并可中断智能体当前的响应。防抖行为有助于在安全性与实时性能需求之间取得平衡。与文本智能体不同，实时智能体在安全防护措施被触发时不会抛出异常。\n+当安全防护被触发时，会生成 `guardrail_tripped` 事件，并可打断智能体当前响应。防抖行为有助于在安全性与实时性能要求之间取得平衡。与文本智能体不同，实时智能体在触发安全防护时**不会**抛出 Exception。\n \n ## 音频处理\n \n 使用 [`session.send_audio(audio_bytes)`][agents.realtime.session.RealtimeSession.send_audio] 发送音频到会话，或使用 [`session.send_message()`][agents.realtime.session.RealtimeSession.send_message] 发送文本。\n \n-对于音频输出，监听 `audio` 事件，并通过你偏好的音频库播放音频数据。务必监听 `audio_interrupted` 事件，以在用户打断智能体时立即停止播放并清除任何已排队的音频。\n+对于音频输出，监听 `audio` 事件，并使用你的音频库播放数据。务必监听 `audio_interrupted` 事件，以便在用户打断时立即停止播放并清空任何待播的音频。\n \n ## SIP 集成\n \n-你可以将实时智能体附加到通过 [Realtime Calls API](https://platform.openai.com/docs/guides/realtime-sip) 接入的来电。SDK 提供了 [`OpenAIRealtimeSIPModel`][agents.realtime.openai_realtime.OpenAIRealtimeSIPModel]，它在通过 SIP 协商媒体的同时复用相同的智能体流程。\n+你可以将实时智能体连接到通过 [Realtime Calls API](https://platform.openai.com/docs/guides/realtime-sip) 接入的电话呼入。SDK 提供了 [`OpenAIRealtimeSIPModel`][agents.realtime.openai_realtime.OpenAIRealtimeSIPModel]，在通过 SIP 协商媒体的同时复用相同的智能体流程。\n \n-要使用它，将该模型实例传递给 runner，并在启动会话时提供 SIP 的 `call_id`。调用 ID 由指示来电的 webhook 传递。\n+要使用它，将该模型实例传入 runner，并在启动会话时提供 SIP 的 `call_id`。来电 ID 由指示来电的 webhook 传递。\n \n ```python\n from agents.realtime import RealtimeAgent, RealtimeRunner\n@@ -187,9 +187,9 @@ async with await runner.run(\n         ...\n ```\n \n-当来电方挂断时，SIP 会话结束，实时连接会自动关闭。完整电话示例参见 [`examples/realtime/twilio_sip`](https://github.com/openai/openai-agents-python/tree/main/examples/realtime/twilio_sip)。\n+当主叫挂断时，SIP 会话结束，实时连接会自动关闭。完整电话集成示例见 [`examples/realtime/twilio_sip`](https://github.com/openai/openai-agents-python/tree/main/examples/realtime/twilio_sip)。\n \n-## 模型直接访问\n+## 直接模型访问\n \n 你可以访问底层模型以添加自定义监听器或执行高级操作：\n \n@@ -198,8 +198,8 @@ async with await runner.run(\n session.model.add_listener(my_custom_listener)\n ```\n \n-这将为你提供对 [`RealtimeModel`][agents.realtime.model.RealtimeModel] 接口的直接访问，适用于需要对连接进行更低层控制的高级用例。\n+这使你可以直接访问 [`RealtimeModel`][agents.realtime.model.RealtimeModel] 接口，用于需要更低层连接控制的高级用例。\n \n ## 代码示例\n \n-完整可运行示例请参阅 [examples/realtime 目录](https://github.com/openai/openai-agents-python/tree/main/examples/realtime)，其中包含带有和不带 UI 组件的演示。\n\\ No newline at end of file\n+完整可运行示例请参阅 [examples/realtime 目录](https://github.com/openai/openai-agents-python/tree/main/examples/realtime)，包含带 UI 与不带 UI 的演示。\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Frealtime%2Fguide.md",
        "sha": "c42aa461863251319c9f67ebaa5a8fb45c7ccb04",
        "status": "modified"
      },
      {
        "additions": 14,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Frealtime%2Fquickstart.md",
        "changes": 28,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fzh%2Frealtime%2Fquickstart.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 14,
        "filename": "docs/zh/realtime/quickstart.md",
        "patch": "@@ -4,16 +4,16 @@ search:\n ---\n # 快速开始\n \n-实时智能体通过 OpenAI 的 Realtime API 实现与 AI 智能体的语音对话。本指南将带你创建第一个实时语音智能体。\n+实时智能体使你的 AI 智能体能够通过 OpenAI 的 Realtime API 进行语音对话。本指南将带你创建第一个实时语音智能体。\n \n !!! warning \"测试版功能\"\n-实时智能体目前处于测试阶段。在我们改进实现期间，可能会有不兼容的变更。\n+Realtime agents 处于测试阶段。随着实现的改进，可能会有不兼容的变更。\n \n ## 先决条件\n \n - Python 3.9 或更高版本\n-- OpenAI API 密钥\n-- 对 OpenAI Agents SDK 的基本了解\n+- OpenAI API key\n+- 对 OpenAI Agents SDK 有基本了解\n \n ## 安装\n \n@@ -193,39 +193,39 @@ if __name__ == \"__main__\":\n ### 模型设置\n \n - `model_name`: 从可用的实时模型中选择（例如，`gpt-realtime`）\n-- `voice`: 选择发音人（`alloy`、`echo`、`fable`、`onyx`、`nova`、`shimmer`）\n+- `voice`: 选择音色（`alloy`、`echo`、`fable`、`onyx`、`nova`、`shimmer`）\n - `modalities`: 启用文本或音频（`[\"text\"]` 或 `[\"audio\"]`）\n \n ### 音频设置\n \n - `input_audio_format`: 输入音频格式（`pcm16`、`g711_ulaw`、`g711_alaw`）\n - `output_audio_format`: 输出音频格式\n-- `input_audio_transcription`: 转录配置\n+- `input_audio_transcription`: 转写配置\n \n-### 轮次检测\n+### 回合检测\n \n - `type`: 检测方法（`server_vad`、`semantic_vad`）\n - `threshold`: 语音活动阈值（0.0-1.0）\n-- `silence_duration_ms`: 判定轮次结束的静音时长\n+- `silence_duration_ms`: 判定回合结束的静音时长\n - `prefix_padding_ms`: 语音前的音频填充\n \n ## 后续步骤\n \n-- [进一步了解实时智能体](guide.md)\n-- 在 [examples/realtime](https://github.com/openai/openai-agents-python/tree/main/examples/realtime) 文件夹中查看可运行的示例代码\n+- [深入了解实时智能体](guide.md)\n+- 在 [examples/realtime](https://github.com/openai/openai-agents-python/tree/main/examples/realtime) 文件夹查看可运行的示例\n - 为你的智能体添加工具\n - 在智能体之间实现任务转移\n-- 配置安全防护措施以确保安全\n+- 设置安全防护措施以保障安全\n \n-## 身份验证\n+## 认证\n \n-确保已在环境中设置你的 OpenAI API 密钥：\n+请确保在你的环境中设置了 OpenAI API key：\n \n ```bash\n export OPENAI_API_KEY=\"your-api-key-here\"\n ```\n \n-或在创建会话时直接传入：\n+或者在创建会话时直接传入：\n \n ```python\n session = await runner.run(model_config={\"api_key\": \"your-api-key\"})",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Frealtime%2Fquickstart.md",
        "sha": "df1b8c7b08fb1d96e98e1928dcc097a31a289dec",
        "status": "modified"
      },
      {
        "additions": 17,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Frelease.md",
        "changes": 34,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fzh%2Frelease.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 17,
        "filename": "docs/zh/release.md",
        "patch": "@@ -2,51 +2,51 @@\n search:\n   exclude: true\n ---\n-# 发布流程/更新日志\n+# 发布流程/变更日志\n \n-本项目遵循经轻微修改的语义化版本规范，采用 `0.Y.Z` 形式。前导的 `0` 表示该 SDK 仍在快速演进中。版本号的递增规则如下：\n+本项目采用经轻微修改的语义化版本，格式为 `0.Y.Z`。前导的 `0` 表示该 SDK 仍在快速演进。各部分递增规则如下：\n \n-## 次版本号（`Y`）\n+## 次版本（`Y`）\n \n-对于未标注为 beta 的任何公共接口发生的**破坏性变更**，我们将提升次版本号 `Y`。例如，从 `0.0.x` 到 `0.1.x` 可能包含破坏性变更。\n+对于未标记为 beta 的任何公共接口发生的**破坏性变更**，我们将提升次版本号 `Y`。例如，从 `0.0.x` 升至 `0.1.x` 可能包含破坏性变更。\n \n-如果你不希望引入破坏性变更，建议在你的项目中固定为 `0.0.x` 版本。\n+如果你不希望引入破坏性变更，建议在项目中固定到 `0.0.x` 版本。\n \n-## 修订号（`Z`）\n+## 修订版本（`Z`）\n \n-对于非破坏性变更，我们将提升修订号 `Z`：\n+对于非破坏性变更，我们将递增 `Z`：\n \n - Bug 修复\n - 新功能\n-- 私有接口的变更\n-- beta 功能的更新\n+- 对私有接口的更改\n+- 对 beta 功能的更新\n \n-## 破坏性变更更新日志\n+## 破坏性变更日志\n \n ### 0.6.0\n \n-此版本中，默认的任务转移历史现已封装为单条 assistant 消息，而不再暴露原始的 user/assistant 轮次，从而为下游智能体提供简洁、可预期的概述。\n-- 现有的单消息任务转移记录默认以“For context, here is the conversation so far between the user and the previous agent:”开头，随后是 `<CONVERSATION HISTORY>` 块，方便下游智能体获得清晰标注的概述\n+在该版本中，默认的任务转移历史现在被打包为单条助手消息，而不再暴露原始的用户/助手轮次，为下游智能体提供简洁、可预测的回顾\n+- 现有的单条消息任务转移对话记录默认在 `<CONVERSATION HISTORY>` 区块前以“For context, here is the conversation so far between the user and the previous agent:”开头，使下游智能体获得清晰标注的回顾\n \n ### 0.5.0\n \n-此版本未引入可见的破坏性变更，但包含新功能以及若干重要的底层更新：\n+此版本未引入可见的破坏性变更，但包含新功能以及一些重要的底层更新：\n \n - 为 `RealtimeRunner` 增加了对 [SIP protocol connections](https://platform.openai.com/docs/guides/realtime-sip) 的支持\n - 大幅修订了 `Runner#run_sync` 的内部逻辑，以兼容 Python 3.14\n \n ### 0.4.0\n \n-此版本中，[openai](https://pypi.org/project/openai/) 包的 v1.x 版本不再受支持。请搭配本 SDK 使用 openai v2.x。\n+在该版本中，[openai](https://pypi.org/project/openai/) 包的 v1.x 版本不再受支持。请配合本 SDK 使用 openai v2.x。\n \n ### 0.3.0\n \n-此版本中，Realtime API 支持迁移至 gpt-realtime 模型及其 API 接口（GA 版本）。\n+在该版本中，Realtime API 的支持迁移到 gpt-realtime 模型及其 API 接口（GA 版本）。\n \n ### 0.2.0\n \n-此版本中，若干原本接收 `Agent` 作为参数的场景，现在改为接收 `AgentBase`。例如 MCP 服务中的 `list_tools()` 调用。此变更纯属类型层面，你仍将收到 `Agent` 对象。要更新，只需将类型错误中出现的 `Agent` 替换为 `AgentBase` 即可。\n+在该版本中，一些原先接收 `Agent` 作为参数的地方，现在改为接收 `AgentBase` 作为参数。例如，MCP 服务中的 `list_tools()` 调用。这纯属类型变更，你依然会收到 `Agent` 对象。要更新，请将类型错误中的 `Agent` 替换为 `AgentBase`。\n \n ### 0.1.0\n \n-此版本中，[`MCPServer.list_tools()`][agents.mcp.server.MCPServer] 新增两个参数：`run_context` 和 `agent`。你需要在继承 `MCPServer` 的任何类中添加这些参数。\n\\ No newline at end of file\n+在该版本中，[`MCPServer.list_tools()`][agents.mcp.server.MCPServer] 新增了两个参数：`run_context` 和 `agent`。你需要将这些参数添加到任何继承自 `MCPServer` 的类中。\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Frelease.md",
        "sha": "890d8c7eda8ab8ee7ab875e03e1cfea73d0d628d",
        "status": "modified"
      },
      {
        "additions": 2,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Frepl.md",
        "changes": 5,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fzh%2Frepl.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 3,
        "filename": "docs/zh/repl.md",
        "patch": "@@ -4,8 +4,7 @@ search:\n ---\n # REPL 工具\n \n-The SDK provides `run_demo_loop` for quick, interactive testing of an agent's behavior directly in your terminal.\n-\n+该 SDK 提供 `run_demo_loop`，可在终端中快速、交互式地测试智能体的行为。\n \n ```python\n import asyncio\n@@ -19,6 +18,6 @@ if __name__ == \"__main__\":\n     asyncio.run(main())\n ```\n \n-`run_demo_loop` 会在循环中提示用户输入，并在轮次之间保留对话历史。默认情况下，它会在模型生成输出时进行流式传输。当你运行上面的示例时，run_demo_loop 会启动一个交互式聊天会话。它会持续请求你的输入，记住轮次之间的整个对话历史（因此你的智能体知道已讨论的内容），并在生成过程中将智能体的响应实时流式传输给你。\n+`run_demo_loop` 会在循环中提示用户输入，并在回合之间保留对话历史。默认情况下，它会在生成的同时流式传输模型输出。运行上面的示例后，run_demo_loop 会启动一个交互式聊天会话。它会持续请求你的输入、在回合之间记住完整的对话历史（让你的智能体知道已讨论的内容），并在生成时实时自动将智能体的回复流式传输给你。\n \n 要结束此聊天会话，只需输入 `quit` 或 `exit`（然后按回车），或使用 `Ctrl-D` 键盘快捷键。\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Frepl.md",
        "sha": "e6bbd243e728a60507f34a548232df4af4a97226",
        "status": "modified"
      },
      {
        "additions": 18,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Fresults.md",
        "changes": 36,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fzh%2Fresults.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 18,
        "filename": "docs/zh/results.md",
        "patch": "@@ -6,51 +6,51 @@ search:\n \n 当你调用 `Runner.run` 方法时，你会得到：\n \n-- [`RunResult`][agents.result.RunResult]（如果你调用的是 `run` 或 `run_sync`）\n-- [`RunResultStreaming`][agents.result.RunResultStreaming]（如果你调用的是 `run_streamed`）\n+- [`RunResult`][agents.result.RunResult]（如果调用 `run` 或 `run_sync`）\n+- [`RunResultStreaming`][agents.result.RunResultStreaming]（如果调用 `run_streamed`）\n \n-两者都继承自 [`RunResultBase`][agents.result.RunResultBase]，大多数有用的信息都在这里。\n+两者都继承自 [`RunResultBase`][agents.result.RunResultBase]，其中包含大多数有用信息。\n \n ## 最终输出\n \n-[`final_output`][agents.result.RunResultBase.final_output] 属性包含最后一个运行的智能体的最终输出。它可能是：\n+[`final_output`][agents.result.RunResultBase.final_output] 属性包含最后一个运行的智能体的最终输出。可能是：\n \n-- `str`，如果最后一个智能体未定义 `output_type`\n-- 类型为 `last_agent.output_type` 的对象，如果该智能体定义了输出类型\n+- `str`，如果最后一个智能体没有定义 `output_type`\n+- 类型为 `last_agent.output_type` 的对象，如果该智能体定义了输出类型。\n \n !!! note\n \n-    `final_output` 的类型是 `Any`。由于存在任务转移，我们无法进行静态类型标注。如果发生任务转移，任何智能体都有可能成为最后一个智能体，因此我们在静态上无法得知可能的输出类型集合。\n+    `final_output` 的类型是 `Any`。由于存在 任务转移，我们无法进行静态类型标注。如果发生 任务转移，任何智能体都有可能成为最后一个智能体，因此我们无法静态地知道可能的输出类型集合。\n \n ## 下一轮的输入\n \n-你可以使用 [`result.to_input_list()`][agents.result.RunResultBase.to_input_list] 将结果转换为一个输入列表：它会把你提供的原始输入与智能体运行期间生成的条目拼接起来。这样可以方便地将一次智能体运行的输出传入另一次运行，或者在循环中每次追加新的用户输入。\n+你可以使用 [`result.to_input_list()`][agents.result.RunResultBase.to_input_list] 将结果转换为一个输入列表，该列表把你提供的原始输入与智能体运行期间生成的条目拼接在一起。这样便于将一次智能体运行的输出传递给另一次运行，或在循环中运行并在每次追加新的用户输入。\n \n ## 最后一个智能体\n \n-[`last_agent`][agents.result.RunResultBase.last_agent] 属性包含最后一个运行的智能体。根据你的应用，这通常对用户下次输入时很有用。比如，如果你有一个前线分诊智能体会将任务转移到特定语言的智能体，你可以存储这个最后的智能体，并在用户下次给智能体发送消息时复用它。\n+[`last_agent`][agents.result.RunResultBase.last_agent] 属性包含最后一个运行的智能体。根据你的应用场景，这对用户下次输入时通常很有用。例如，如果你有一个前线分诊智能体会将任务转移给特定语言的智能体，你可以存储该最后的智能体，并在用户下次向智能体发送消息时复用它。\n \n-## 新条目\n+## 新增条目\n \n-[`new_items`][agents.result.RunResultBase.new_items] 属性包含运行期间生成的新条目。条目是 [`RunItem`][agents.items.RunItem]。Run item 包装了由 LLM 生成的原始条目。\n+[`new_items`][agents.result.RunResultBase.new_items] 属性包含运行期间生成的新增条目。条目为 [`RunItem`][agents.items.RunItem]。运行条目封装了由 LLM 生成的原始条目。\n \n-- [`MessageOutputItem`][agents.items.MessageOutputItem] 表示来自 LLM 的一条消息。原始条目是生成的消息。\n-- [`HandoffCallItem`][agents.items.HandoffCallItem] 表示 LLM 调用了任务转移工具。原始条目是来自 LLM 的工具调用条目。\n-- [`HandoffOutputItem`][agents.items.HandoffOutputItem] 表示发生了一次任务转移。原始条目是对任务转移工具调用的工具响应。你也可以从条目中访问源/目标智能体。\n-- [`ToolCallItem`][agents.items.ToolCallItem] 表示 LLM 调用了一个工具。\n-- [`ToolCallOutputItem`][agents.items.ToolCallOutputItem] 表示一个工具被调用。原始条目是工具响应。你也可以从条目中访问工具输出。\n+- [`MessageOutputItem`][agents.items.MessageOutputItem] 表示来自 LLM 的消息。原始条目是生成的消息。\n+- [`HandoffCallItem`][agents.items.HandoffCallItem] 表示 LLM 调用了 任务转移 工具。原始条目是来自 LLM 的工具调用条目。\n+- [`HandoffOutputItem`][agents.items.HandoffOutputItem] 表示发生了 任务转移。原始条目是对 任务转移 工具调用的工具响应。你也可以从该条目访问源/目标智能体。\n+- [`ToolCallItem`][agents.items.ToolCallItem] 表示 LLM 调用了某个工具。\n+- [`ToolCallOutputItem`][agents.items.ToolCallOutputItem] 表示某个工具被调用。原始条目是工具响应。你也可以从该条目访问工具输出。\n - [`ReasoningItem`][agents.items.ReasoningItem] 表示来自 LLM 的推理条目。原始条目是生成的推理。\n \n ## 其他信息\n \n ### 安全防护措施结果\n \n-[`input_guardrail_results`][agents.result.RunResultBase.input_guardrail_results] 和 [`output_guardrail_results`][agents.result.RunResultBase.output_guardrail_results] 属性包含安全防护措施的结果（如果有）。安全防护措施的结果有时包含你想记录或存储的有用信息，因此我们将其提供给你。\n+[`input_guardrail_results`][agents.result.RunResultBase.input_guardrail_results] 和 [`output_guardrail_results`][agents.result.RunResultBase.output_guardrail_results] 属性包含（如果有）安全防护措施的结果。安全防护措施结果有时包含你希望记录或存储的有用信息，因此我们将其提供给你。\n \n ### 原始响应\n \n [`raw_responses`][agents.result.RunResultBase.raw_responses] 属性包含由 LLM 生成的 [`ModelResponse`][agents.items.ModelResponse]。\n \n ### 原始输入\n \n-[`input`][agents.result.RunResultBase.input] 属性包含你提供给 `run` 方法的原始输入。大多数情况下你不需要它，但在需要时它是可用的。\n\\ No newline at end of file\n+[`input`][agents.result.RunResultBase.input] 属性包含你传递给 `run` 方法的原始输入。在大多数情况下你不需要它，但如有需要可用。\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Fresults.md",
        "sha": "d0bad68d97055942e053f9c3f1a326ea22a1f237",
        "status": "modified"
      },
      {
        "additions": 47,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Frunning_agents.md",
        "changes": 94,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fzh%2Frunning_agents.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 47,
        "filename": "docs/zh/running_agents.md",
        "patch": "@@ -6,9 +6,9 @@ search:\n \n 你可以通过 [`Runner`][agents.run.Runner] 类来运行智能体。共有 3 种方式：\n \n-1. [`Runner.run()`][agents.run.Runner.run]：异步运行并返回一个 [`RunResult`][agents.result.RunResult]。\n+1. [`Runner.run()`][agents.run.Runner.run]：异步运行，返回 [`RunResult`][agents.result.RunResult]。\n 2. [`Runner.run_sync()`][agents.run.Runner.run_sync]：同步方法，内部调用 `.run()`。\n-3. [`Runner.run_streamed()`][agents.run.Runner.run_streamed]：异步运行并返回一个 [`RunResultStreaming`][agents.result.RunResultStreaming]。它以流式传输模式调用 LLM，并在接收时将这些事件流式传输给你。\n+3. [`Runner.run_streamed()`][agents.run.Runner.run_streamed]：异步运行，返回 [`RunResultStreaming`][agents.result.RunResultStreaming]。它以流式模式调用 LLM，并在接收时将事件流式传输给你。\n \n ```python\n from agents import Agent, Runner\n@@ -23,59 +23,59 @@ async def main():\n     # Infinite loop's dance\n ```\n \n-在[结果指南](results.md)中了解更多。\n+更多内容参见[结果指南](results.md)。\n \n ## 智能体循环\n \n-当你在 `Runner` 中使用 run 方法时，需要传入一个起始智能体和输入。输入可以是一个字符串（视为用户消息），也可以是一个输入项列表，这些输入项即 OpenAI Responses API 中的条目。\n+当你在 `Runner` 中使用 run 方法时，需要传入一个起始智能体和输入。输入可以是字符串（被视为用户消息），也可以是输入项列表，这些输入项与 OpenAI Responses API 中的项目一致。\n \n-runner 会运行如下循环：\n+运行器随后执行一个循环：\n \n-1. 我们使用当前输入为当前智能体调用 LLM。\n+1. 我们针对当前智能体与当前输入调用 LLM。\n 2. LLM 生成输出。\n     1. 如果 LLM 返回 `final_output`，循环结束并返回结果。\n-    2. 如果 LLM 进行任务转移，我们会更新当前智能体和输入，并重新运行循环。\n-    3. 如果 LLM 产生工具调用，我们会运行这些工具调用，追加结果并重新运行循环。\n-3. 如果超过传入的 `max_turns`，我们会抛出 [`MaxTurnsExceeded`][agents.exceptions.MaxTurnsExceeded] 异常。\n+    2. 如果 LLM 执行了任务转移，我们更新当前智能体和输入，并重新运行循环。\n+    3. 如果 LLM 产生工具调用，我们运行这些工具调用，附加其结果，并重新运行循环。\n+3. 如果超过传入的 `max_turns`，将抛出 [`MaxTurnsExceeded`][agents.exceptions.MaxTurnsExceeded] 异常。\n \n !!! note\n \n-    判断 LLM 输出是否为“最终输出”的规则是：它生成了具有期望类型的文本输出，且没有工具调用。\n+    判定 LLM 输出是否为“最终输出”的规则是：它生成了所需类型的文本输出，且没有工具调用。\n \n ## 流式传输\n \n-流式传输允许你在 LLM 运行时同时接收流式事件。流结束后，[`RunResultStreaming`][agents.result.RunResultStreaming] 将包含关于本次运行的完整信息，包括所有新生成的输出。你可以调用 `.stream_events()` 获取流式事件。更多内容参见[流式传输指南](streaming.md)。\n+流式传输允许你在 LLM 运行时接收事件流。流结束后，[`RunResultStreaming`][agents.result.RunResultStreaming] 将包含此次运行的完整信息，包括所有新生成的输出。你可以调用 `.stream_events()` 获取事件流。更多内容参见[流式传输指南](streaming.md)。\n \n ## 运行配置\n \n-`run_config` 参数可用于配置本次智能体运行的一些全局设置：\n+`run_config` 参数允许为智能体运行配置一些全局设置：\n \n-- [`model`][agents.run.RunConfig.model]：允许设置一个全局的 LLM 模型使用，而不受各个 Agent 的 `model` 配置影响。\n-- [`model_provider`][agents.run.RunConfig.model_provider]：用于查找模型名称的模型提供方，默认是 OpenAI。\n-- [`model_settings`][agents.run.RunConfig.model_settings]：覆盖智能体级别的设置。例如，你可以设置全局的 `temperature` 或 `top_p`。\n-- [`input_guardrails`][agents.run.RunConfig.input_guardrails], [`output_guardrails`][agents.run.RunConfig.output_guardrails]：要在所有运行中包含的输入或输出安全防护措施列表。\n-- [`handoff_input_filter`][agents.run.RunConfig.handoff_input_filter]：一个全局输入过滤器，若某次任务转移未定义，则应用于所有任务转移。输入过滤器允许你编辑发送给新智能体的输入。详见 [`Handoff.input_filter`][agents.handoffs.Handoff.input_filter]。\n-- [`nest_handoff_history`][agents.run.RunConfig.nest_handoff_history]：当为 `True`（默认）时，runner 会在调用下一个智能体前，将先前的对话记录折叠为单个助手消息。帮助器将内容放入一个 `<CONVERSATION HISTORY>` 块中，并在后续任务转移发生时不断追加新轮次。如果你希望传递原始对话记录，请将其设为 `False`，或提供自定义的 handoff 过滤器。所有 [`Runner` 方法](agents.run.Runner) 在你未显式传入时会自动创建一个 `RunConfig`，因此快速上手与 code examples 会自动采用该默认值，且任何显式的 [`Handoff.input_filter`][agents.handoffs.Handoff.input_filter] 回调仍会覆盖它。单次任务转移可通过 [`Handoff.nest_handoff_history`][agents.handoffs.Handoff.nest_handoff_history] 覆盖该设置。\n-- [`handoff_history_mapper`][agents.run.RunConfig.handoff_history_mapper]：可选的可调用对象。当 `nest_handoff_history` 为 `True` 时，它会接收规范化后的对话记录（history + handoff items）。它必须返回要转发给下一个智能体的精确输入项列表，使你无需编写完整的 handoff 过滤器即可替换内置摘要。\n-- [`tracing_disabled`][agents.run.RunConfig.tracing_disabled]：允许为整个运行禁用[追踪](tracing.md)。\n-- [`trace_include_sensitive_data`][agents.run.RunConfig.trace_include_sensitive_data]：配置追踪中是否包含潜在的敏感数据，例如 LLM 与工具调用的输入/输出。\n-- [`workflow_name`][agents.run.RunConfig.workflow_name], [`trace_id`][agents.run.RunConfig.trace_id], [`group_id`][agents.run.RunConfig.group_id]：为此次运行设置追踪的工作流名称、追踪 ID 和追踪分组 ID。我们建议至少设置 `workflow_name`。分组 ID 是可选字段，允许你关联多次运行之间的追踪。\n-- [`trace_metadata`][agents.run.RunConfig.trace_metadata]：要包含在所有追踪上的元数据。\n+-   [`model`][agents.run.RunConfig.model]：设置全局 LLM 模型，不受各 Agent 自身 `model` 的影响。\n+-   [`model_provider`][agents.run.RunConfig.model_provider]：用于查找模型名称的模型提供方，默认是 OpenAI。\n+-   [`model_settings`][agents.run.RunConfig.model_settings]：覆盖智能体级别设置。例如你可以设置全局的 `temperature` 或 `top_p`。\n+-   [`input_guardrails`][agents.run.RunConfig.input_guardrails], [`output_guardrails`][agents.run.RunConfig.output_guardrails]：要在所有运行中包含的输入或输出安全防护措施列表。\n+-   [`handoff_input_filter`][agents.run.RunConfig.handoff_input_filter]：在任务转移未指定输入过滤器时应用的全局输入过滤器。输入过滤器允许你编辑发送给新智能体的输入。更多细节参见 [`Handoff.input_filter`][agents.handoffs.Handoff.input_filter] 的文档。\n+-   [`nest_handoff_history`][agents.run.RunConfig.nest_handoff_history]：当为 `True`（默认）时，运行器会在调用下一个智能体前，将先前的对话转写折叠为单条助手消息。辅助工具会将内容放入一个 `<CONVERSATION HISTORY>` 块中，并在后续任务转移时持续追加新轮次。如果你希望传递原始对话记录，请设置为 `False` 或提供自定义的任务转移过滤器。所有 [`Runner` 方法](agents.run.Runner) 在未传入时会自动创建 `RunConfig`，因此快速上手和 code examples 会自动采用该默认值，同时任何显式的 [`Handoff.input_filter`][agents.handoffs.Handoff.input_filter] 回调仍会覆盖它。单次任务转移也可通过 [`Handoff.nest_handoff_history`][agents.handoffs.Handoff.nest_handoff_history] 覆盖此设置。\n+-   [`handoff_history_mapper`][agents.run.RunConfig.handoff_history_mapper]：可选的可调用对象，当 `nest_handoff_history` 为 `True` 时接收规范化的转录内容（历史 + 任务转移项）。它必须返回要转发给下一个智能体的精确输入项列表，使你无需编写完整的转移过滤器即可替换内置摘要。\n+-   [`tracing_disabled`][agents.run.RunConfig.tracing_disabled]：允许对整个运行禁用[追踪](tracing.md)。\n+-   [`trace_include_sensitive_data`][agents.run.RunConfig.trace_include_sensitive_data]：配置追踪中是否包含潜在的敏感数据，例如 LLM 与工具调用的输入/输出。\n+-   [`workflow_name`][agents.run.RunConfig.workflow_name], [`trace_id`][agents.run.RunConfig.trace_id], [`group_id`][agents.run.RunConfig.group_id]：设置本次运行的追踪工作流名称、追踪 ID 与追踪分组 ID。建议至少设置 `workflow_name`。分组 ID 是可选字段，用于将多次运行的追踪关联在一起。\n+-   [`trace_metadata`][agents.run.RunConfig.trace_metadata]：要包含在所有追踪中的元数据。\n \n-默认情况下，当一个智能体将任务转移给另一个智能体时，SDK 会将先前的轮次嵌套到单个助手摘要消息中。这减少了重复的助手消息，并将完整的对话记录保存在一个单独的块中，便于新智能体快速扫描。如果你希望恢复旧行为，可以传入 `RunConfig(nest_handoff_history=False)`，或者提供一个 `handoff_input_filter`（或 `handoff_history_mapper`）以按需原样转发对话。你也可以为特定的任务转移选择退出（或启用），通过设置 `handoff(..., nest_handoff_history=False)` 或 `True`。若想在不编写自定义映射器的情况下更改生成摘要所用的包装文本，请调用 [`set_conversation_history_wrappers`][agents.handoffs.set_conversation_history_wrappers]（以及用于恢复默认值的 [`reset_conversation_history_wrappers`][agents.handoffs.reset_conversation_history_wrappers]）。\n+默认情况下，SDK 现在会在智能体进行任务转移时，将先前轮次嵌套到单条助手摘要消息中。这减少了重复的助手消息，并将完整的对话记录保持在单个块中，便于新智能体快速扫描。如果你想恢复旧行为，可传入 `RunConfig(nest_handoff_history=False)`，或提供一个 `handoff_input_filter`（或 `handoff_history_mapper`）以按需转发对话。你也可以针对特定的任务转移选择退出（或开启），通过设置 `handoff(..., nest_handoff_history=False)` 或 `True`。若想在不编写自定义映射器的情况下更改生成的摘要所用的包裹文本，请调用 [`set_conversation_history_wrappers`][agents.handoffs.set_conversation_history_wrappers]（并使用 [`reset_conversation_history_wrappers`][agents.handoffs.reset_conversation_history_wrappers] 恢复默认值）。\n \n ## 会话/聊天线程\n \n-调用任一运行方法，可能会导致一个或多个智能体运行（因此可能会有一次或多次 LLM 调用），但其代表一次聊天会话中的单个逻辑轮次。例如：\n+调用任一运行方法都可能触发一个或多个智能体运行（因此可能进行一次或多次 LLM 调用），但它代表聊天会话中的单个逻辑轮次。例如：\n \n 1. 用户轮次：用户输入文本\n-2. Runner 运行：第一个智能体调用 LLM、运行工具、将任务转移给第二个智能体，第二个智能体运行更多工具，然后生成输出。\n+2. Runner 运行：第一个智能体调用 LLM、运行工具、将任务转移给第二个智能体，第二个智能体再运行更多工具，然后产生输出。\n \n-在智能体运行结束时，你可以选择向用户展示的内容。例如，你可以展示智能体生成的每一个新条目，或仅展示最终输出。无论哪种方式，用户都可能继续追问，此时你可以再次调用 run 方法。\n+在智能体运行结束时，你可以选择向用户展示的内容。例如，你可以展示智能体生成的每个新项目，或仅展示最终输出。无论哪种方式，用户都可能提出后续问题，此时你可以再次调用 run 方法。\n \n ### 手动会话管理\n \n-你可以使用 [`RunResultBase.to_input_list()`][agents.result.RunResultBase.to_input_list] 方法手动管理会话历史，以获取下一轮的输入：\n+你可以使用 [`RunResultBase.to_input_list()`][agents.result.RunResultBase.to_input_list] 手动管理会话历史，以获取下一轮的输入：\n \n ```python\n async def main():\n@@ -97,7 +97,7 @@ async def main():\n \n ### 使用 Sessions 的自动会话管理\n \n-若想更简化，你可以使用 [Sessions](sessions/index.md) 自动处理会话历史，而无需手动调用 `.to_input_list()`：\n+如果希望更简单的方式，你可以使用 [Sessions](sessions/index.md) 自动处理会话历史，无需手动调用 `.to_input_list()`：\n \n ```python\n from agents import Agent, Runner, SQLiteSession\n@@ -123,21 +123,21 @@ async def main():\n \n Sessions 会自动：\n \n-- 在每次运行前检索会话历史\n-- 在每次运行后存储新消息\n-- 为不同的 session ID 维护独立会话\n+-   在每次运行前获取会话历史\n+-   在每次运行后存储新消息\n+-   为不同的 session ID 维护独立的会话\n \n-更多详情参见 [Sessions 文档](sessions/index.md)。\n+更多细节请参见 [Sessions 文档](sessions/index.md)。\n \n-### 由服务管理的会话\n+### 服务端管理的会话\n \n-你也可以让 OpenAI 的对话状态功能在服务端管理会话状态，而不是通过 `to_input_list()` 或 `Sessions` 在本地处理。这样可以在无需手动重发全部历史消息的情况下保留会话历史。更多内容参见 [OpenAI Conversation state 指南](https://platform.openai.com/docs/guides/conversation-state?api-mode=responses)。\n+你也可以让 OpenAI 的会话状态功能在服务端管理会话状态，而不是使用 `to_input_list()` 或 `Sessions` 在本地处理。这样可以在无需手动重发所有历史消息的情况下保留会话历史。详见 [OpenAI Conversation state 指南](https://platform.openai.com/docs/guides/conversation-state?api-mode=responses)。\n \n-OpenAI 提供两种跨轮次跟踪状态的方法：\n+OpenAI 提供两种跨轮次追踪状态的方式：\n \n #### 1. 使用 `conversation_id`\n \n-你首先通过 OpenAI Conversations API 创建一个会话，然后在后续每次调用中复用其 ID：\n+首先通过 OpenAI Conversations API 创建一个会话，然后在后续每次调用中复用其 ID：\n \n ```python\n from agents import Agent, Runner\n@@ -160,7 +160,7 @@ async def main():\n \n #### 2. 使用 `previous_response_id`\n \n-另一种方式是**响应链（response chaining）**，每一轮显式链接到上一轮的响应 ID。\n+另一种方式是**响应链式调用**（response chaining），每一轮都显式链接到上一轮的 response ID。\n \n ```python\n from agents import Agent, Runner\n@@ -185,18 +185,18 @@ async def main():\n         print(f\"Assistant: {result.final_output}\")\n ```\n \n-## 长时间运行的智能体与人类参与\n+## 长时间运行的智能体与 human-in-the-loop\n \n-你可以使用 Agents SDK 的 [Temporal](https://temporal.io/) 集成来运行持久、长时间运行的工作流，包括 human-in-the-loop 任务。可在[此视频](https://www.youtube.com/watch?v=fFBZqzT4DD8)中观看 Temporal 与 Agents SDK 协同完成长任务的演示，并[在此查看文档](https://github.com/temporalio/sdk-python/tree/main/temporalio/contrib/openai_agents)。\n+你可以使用 Agents SDK 的 [Temporal](https://temporal.io/) 集成来运行持久的、长时间运行的工作流，包括 human-in-the-loop 任务。观看此[视频](https://www.youtube.com/watch?v=fFBZqzT4DD8)了解 Temporal 与 Agents SDK 协同完成长任务的演示，并[查看此处的文档](https://github.com/temporalio/sdk-python/tree/main/temporalio/contrib/openai_agents)。\n \n ## 异常\n \n SDK 在某些情况下会抛出异常。完整列表见 [`agents.exceptions`][]。概览如下：\n \n-- [`AgentsException`][agents.exceptions.AgentsException]：SDK 内抛出的所有异常的基类。它是所有其他特定异常的通用父类型。\n-- [`MaxTurnsExceeded`][agents.exceptions.MaxTurnsExceeded]：当智能体的运行超过传给 `Runner.run`、`Runner.run_sync` 或 `Runner.run_streamed` 方法的 `max_turns` 限制时抛出。表示智能体未能在指定的交互轮次数内完成任务。\n-- [`ModelBehaviorError`][agents.exceptions.ModelBehaviorError]：当底层模型（LLM）产生意外或无效输出时发生。这可能包括：\n-    - 格式错误的 JSON：当模型为工具调用或其直接输出提供格式错误的 JSON 结构，尤其是在指定了特定 `output_type` 时。\n-    - 与工具相关的意外失败：当模型未能以预期方式使用工具\n-- [`UserError`][agents.exceptions.UserError]：当你（使用 SDK 编写代码的人）在使用 SDK 时发生错误时抛出。通常由不正确的代码实现、无效的配置或对 SDK API 的误用导致。\n-- [`InputGuardrailTripwireTriggered`][agents.exceptions.InputGuardrailTripwireTriggered], [`OutputGuardrailTripwireTriggered`][agents.exceptions.OutputGuardrailTripwireTriggered]：当输入或输出安全防护措施的触发条件分别被满足时抛出。输入安全防护措施在处理之前检查传入消息，而输出安全防护措施在交付之前检查智能体的最终响应。\n\\ No newline at end of file\n+-   [`AgentsException`][agents.exceptions.AgentsException]：SDK 内抛出的所有异常的基类。它是其他特定异常的通用父类型。\n+-   [`MaxTurnsExceeded`][agents.exceptions.MaxTurnsExceeded]：当智能体运行超过传递给 `Runner.run`、`Runner.run_sync` 或 `Runner.run_streamed` 的 `max_turns` 限制时抛出。表示智能体无法在指定的交互轮次数内完成任务。\n+-   [`ModelBehaviorError`][agents.exceptions.ModelBehaviorError]：当底层模型（LLM）产生意外或无效输出时发生。这包括：\n+    -   Malformed JSON：当模型为工具调用或其直接输出提供了格式错误的 JSON 结构，尤其是在定义了特定 `output_type` 时。\n+    -   意外的工具相关失败：当模型未按预期方式使用工具\n+-   [`UserError`][agents.exceptions.UserError]：当你（使用 SDK 编写代码的人）在使用 SDK 时出错会抛出此异常。通常由错误的代码实现、无效配置或误用 SDK 的 API 导致。\n+-   [`InputGuardrailTripwireTriggered`][agents.exceptions.InputGuardrailTripwireTriggered], [`OutputGuardrailTripwireTriggered`][agents.exceptions.OutputGuardrailTripwireTriggered]：当满足输入或输出安全防护措施的触发条件时分别抛出。输入安全防护措施在处理前检查传入消息，而输出安全防护措施在交付前检查智能体的最终响应。\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Frunning_agents.md",
        "sha": "d9cc3da190dfee1110f9c3b790757877177e9694",
        "status": "modified"
      },
      {
        "additions": 20,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Fsessions%2Fadvanced_sqlite_session.md",
        "changes": 41,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fzh%2Fsessions%2Fadvanced_sqlite_session.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 21,
        "filename": "docs/zh/sessions/advanced_sqlite_session.md",
        "patch": "@@ -4,15 +4,15 @@ search:\n ---\n # 高级 SQLite 会话\n \n-`AdvancedSQLiteSession` 是基础 `SQLiteSession` 的增强版本，提供高级对话管理能力，包括对话分支、详细的使用分析，以及结构化的对话查询。\n+`AdvancedSQLiteSession` 是基础 `SQLiteSession` 的增强版本，提供高级对话管理能力，包括会话分支、详细的使用分析以及结构化会话查询。\n \n ## 功能\n \n-- **对话分支**: 从任意用户消息创建替代对话路径\n-- **使用跟踪**: 按回合的详细 token 使用分析，并提供完整的 JSON 明细\n-- **结构化查询**: 按回合获取对话、工具使用统计等\n+- **会话分支**: 从任意用户消息创建备选对话路径\n+- **使用追踪**: 每轮详尽的 token 使用分析，附完整 JSON 明细\n+- **结构化查询**: 按轮次获取会话、工具使用统计等\n - **分支管理**: 独立的分支切换与管理\n-- **消息结构元数据**: 跟踪消息类型、工具使用和对话流程\n+- **消息结构元数据**: 追踪消息类型、工具使用与会话流转\n \n ## 快速开始\n \n@@ -84,14 +84,14 @@ session = AdvancedSQLiteSession(\n \n ### 参数\n \n-- `session_id` (str): 对话会话的唯一标识符\n-- `db_path` (str | Path): SQLite 数据库文件路径。默认使用 `:memory:` 进行内存存储\n-- `create_tables` (bool): 是否自动创建高级表。默认值为 `False`\n-- `logger` (logging.Logger | None): 会话的自定义日志记录器。默认使用模块日志记录器\n+- `session_id` (str): 会话会话的唯一标识符\n+- `db_path` (str | Path): SQLite 数据库文件路径。默认为 `:memory:`（内存存储）\n+- `create_tables` (bool): 是否自动创建高级表。默认为 `False`\n+- `logger` (logging.Logger | None): 会话的自定义日志记录器。默认为模块级 logger\n \n-## 使用跟踪\n+## 使用追踪\n \n-AdvancedSQLiteSession 通过按对话回合存储 token 使用数据来提供详细的使用分析。**这完全依赖于在每次智能体运行后调用 `store_run_usage` 方法。**\n+AdvancedSQLiteSession 通过按会话轮次存储 token 使用数据来提供详细的使用分析。**这完全依赖于在每次智能体运行后调用 `store_run_usage` 方法。**\n \n ### 存储使用数据\n \n@@ -135,9 +135,9 @@ for turn_data in turn_usage:\n turn_2_usage = await session.get_turn_usage(user_turn_number=2)\n ```\n \n-## 对话分支\n+## 会话分支\n \n-AdvancedSQLiteSession 的关键特性之一是能够从任意用户消息创建对话分支，使你可以探索替代的对话路径。\n+AdvancedSQLiteSession 的关键特性之一是能够从任意用户消息创建会话分支，使你可以探索备选对话路径。\n \n ### 创建分支\n \n@@ -217,9 +217,9 @@ await session.store_run_usage(result)\n \n ## 结构化查询\n \n-AdvancedSQLiteSession 提供多种方法来分析对话结构和内容。\n+AdvancedSQLiteSession 提供多种方法用于分析会话结构与内容。\n \n-### 对话分析\n+### 会话分析\n \n ```python\n # Get conversation organized by turns\n@@ -245,17 +245,17 @@ for turn in matching_turns:\n \n ### 消息结构\n \n-会话会自动跟踪消息结构，包括：\n+会话会自动追踪消息结构，包括：\n \n - 消息类型（user、assistant、tool_call 等）\n - 工具调用的工具名称\n-- 回合编号与序号\n+- 轮次编号与序号\n - 分支关联\n - 时间戳\n \n ## 数据库模式\n \n-AdvancedSQLiteSession 在基础的 SQLite 模式上扩展了两个附加表：\n+AdvancedSQLiteSession 在基础 SQLite 模式上扩展了两个附加表：\n \n ### message_structure 表\n \n@@ -296,10 +296,9 @@ CREATE TABLE turn_usage (\n );\n ```\n \n-## 完整示例\n-\n-查看[完整示例](https://github.com/openai/openai-agents-python/tree/main/examples/memory/advanced_sqlite_session_example.py)，以全面演示所有功能。\n+## 完整代码示例\n \n+查看[完整代码示例](https://github.com/openai/openai-agents-python/tree/main/examples/memory/advanced_sqlite_session_example.py)，全面了解所有功能。\n \n ## API 参考\n ",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Fsessions%2Fadvanced_sqlite_session.md",
        "sha": "7fffef02fb621b9df98cb9588cae3c1c8df12a4b",
        "status": "modified"
      },
      {
        "additions": 15,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Fsessions%2Fencrypted_session.md",
        "changes": 30,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fzh%2Fsessions%2Fencrypted_session.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 15,
        "filename": "docs/zh/sessions/encrypted_session.md",
        "patch": "@@ -4,18 +4,18 @@ search:\n ---\n # 加密会话\n \n-`EncryptedSession` 为任意会话实现提供透明加密，通过自动过期机制保护对话数据中较旧的条目。\n+`EncryptedSession` 为任意会话实现提供透明加密，并通过自动过期机制保护会话数据中过期条目。\n \n ## 功能\n \n-- **透明加密**：用 Fernet 加密包装任意会话\n-- **按会话独立密钥**：使用 HKDF 密钥派生，为每个会话生成唯一密钥\n-- **自动过期**：当 TTL 过期时，旧条目会被静默跳过\n-- **可直接替换**：可与任何现有会话实现一起使用\n+- **透明加密**：使用 Fernet 加密封装任意会话\n+- **每会话独立密钥**：使用 HKDF 进行派生，为每个会话生成唯一密钥\n+- **自动过期**：当 TTL 到期时，旧条目会被静默跳过\n+- **可直接替换**：适用于任何现有的会话实现\n \n ## 安装\n \n-加密会话需要安装 `encrypt` 可选依赖：\n+加密会话需要 `encrypt` 扩展：\n \n ```bash\n pip install openai-agents[encrypt]\n@@ -140,30 +140,30 @@ session = EncryptedSession(\n \n !!! warning \"高级会话功能\"\n \n-    将 `EncryptedSession` 与诸如 `AdvancedSQLiteSession` 等高级会话实现一起使用时，请注意：\n+    当将 `EncryptedSession` 与诸如 `AdvancedSQLiteSession` 这类高级会话实现一起使用时，请注意：\n \n-    - 由于消息内容已被加密，诸如 `find_turns_by_content()` 的方法将难以有效工作\n-    - 基于内容的搜索会在加密数据上运行，其效果会受到限制\n+    - 由于消息内容被加密，`find_turns_by_content()` 等方法将无法有效工作\n+    - 基于内容的搜索是在加密数据上进行的，因此效果受限\n \n \n \n ## 密钥派生\n \n-EncryptedSession 使用 HKDF（基于 HMAC 的密钥派生函数，HMAC-based Key Derivation Function）为每个会话派生唯一的加密密钥：\n+EncryptedSession 使用 HKDF（基于 HMAC 的密钥派生函数）为每个会话派生唯一的加密密钥：\n \n - **主密钥**：你提供的加密密钥\n - **会话盐值**：会话 ID\n-- **Info 字符串**：`\"agents.session-store.hkdf.v1\"`\n-- **输出**：32 字节 Fernet 密钥\n+- **信息字符串**：`\"agents.session-store.hkdf.v1\"`\n+- **输出**：32 字节的 Fernet 密钥\n \n 这确保了：\n - 每个会话都有唯一的加密密钥\n-- 没有主密钥无法推导出各会话密钥\n-- 不同会话之间的数据无法相互解密\n+- 未持有主密钥无法推导出密钥\n+- 不同会话之间无法互相解密数据\n \n ## 自动过期\n \n-当条目超过 TTL 时，在检索过程中会被自动跳过：\n+当条目超过 TTL 时，在检索时会被自动跳过：\n \n ```python\n # Items older than TTL are silently ignored",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Fsessions%2Fencrypted_session.md",
        "sha": "06138a1dbd22d8eb165c9eae4c5a50f73c02ea49",
        "status": "modified"
      },
      {
        "additions": 39,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Fsessions%2Findex.md",
        "changes": 78,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fzh%2Fsessions%2Findex.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 39,
        "filename": "docs/zh/sessions/index.md",
        "patch": "@@ -4,11 +4,11 @@ search:\n ---\n # 会话\n \n-Agents SDK 提供了内置的会话记忆，用于在多次智能体运行之间自动维护对话历史，避免在轮次之间手动处理 `.to_input_list()`。\n+Agents SDK 提供了内置的会话记忆，可在多次智能体运行间自动维护对话历史，无需在轮次之间手动处理 `.to_input_list()`。\n \n-会话为特定会话存储对话历史，使智能体无需显式的手动内存管理即可保持上下文。这对于构建聊天应用或多轮对话（需要智能体记住先前交互）特别有用。\n+Sessions 会为特定会话存储对话历史，使智能体无需显式的手动记忆管理即可保持上下文。这对于构建聊天应用或多轮对话（需要让智能体记住先前交互）尤为有用。\n \n-## 快速入门\n+## 快速开始\n \n ```python\n from agents import Agent, Runner, SQLiteSession\n@@ -49,19 +49,19 @@ print(result.final_output)  # \"Approximately 39 million\"\n \n ## 工作原理\n \n-当启用会话记忆时：\n+启用会话记忆后：\n \n-1. **每次运行前**：运行器会自动检索该会话的对话历史，并将其预置到输入项之前。\n-2. **每次运行后**：运行期间生成的所有新项（用户输入、助手回复、工具调用等）都会自动存储到会话中。\n-3. **上下文保持**：使用相同会话的后续运行将包含完整的对话历史，从而使智能体保持上下文。\n+1. **每次运行前**：运行器会自动检索该会话的历史并将其预置到输入项之前。\n+2. **每次运行后**：运行期间生成的所有新项（用户输入、助手回复、工具调用等）都会自动存入会话。\n+3. **上下文保留**：使用同一会话进行的后续运行会包含完整对话历史，使智能体能够保持上下文。\n \n-这消除了在运行之间手动调用 `.to_input_list()` 并管理对话状态的需要。\n+这消除了在轮次之间手动调用 `.to_input_list()` 并管理对话状态的需要。\n \n ## 记忆操作\n \n ### 基本操作\n \n-会话支持多种用于管理对话历史的操作：\n+Sessions 支持多种用于管理对话历史的操作：\n \n ```python\n from agents import SQLiteSession\n@@ -86,9 +86,9 @@ print(last_item)  # {\"role\": \"assistant\", \"content\": \"Hi there!\"}\n await session.clear_session()\n ```\n \n-### 使用 pop_item 的纠正\n+### 使用 pop_item 进行更正\n \n-当你想要撤销或修改对话中的最后一项时，`pop_item` 方法特别有用：\n+当你想撤销或修改对话中的最后一个项目时，`pop_item` 方法尤其有用：\n \n ```python\n from agents import Agent, Runner, SQLiteSession\n@@ -119,11 +119,11 @@ print(f\"Agent: {result.final_output}\")\n \n ## 会话类型\n \n-SDK 为不同用例提供了多种会话实现：\n+SDK 为不同的使用场景提供了多种会话实现：\n \n ### OpenAI Conversations API 会话\n \n-通过 `OpenAIConversationsSession` 使用 [OpenAI 的 Conversations API](https://platform.openai.com/docs/api-reference/conversations)。\n+通过 `OpenAIConversationsSession` 使用 [OpenAI's Conversations API](https://platform.openai.com/docs/api-reference/conversations)。\n \n ```python\n from agents import Agent, Runner, OpenAIConversationsSession\n@@ -159,7 +159,7 @@ print(result.final_output)  # \"California\"\n \n ### SQLite 会话\n \n-默认的、轻量级的 SQLite 会话实现：\n+使用 SQLite 的默认轻量级会话实现：\n \n ```python\n from agents import SQLiteSession\n@@ -180,7 +180,7 @@ result = await Runner.run(\n \n ### SQLAlchemy 会话\n \n-使用任意 SQLAlchemy 支持的数据库的生产级会话：\n+使用任何 SQLAlchemy 支持的数据库的生产级会话：\n \n ```python\n from agents.extensions.memory import SQLAlchemySession\n@@ -198,13 +198,13 @@ engine = create_async_engine(\"postgresql+asyncpg://user:pass@localhost/db\")\n session = SQLAlchemySession(\"user_123\", engine=engine, create_tables=True)\n ```\n \n-详见[SQLAlchemy 会话](sqlalchemy_session.md)的详细文档。\n+详见 [SQLAlchemy Sessions](sqlalchemy_session.md) 的详细文档。\n \n \n \n ### 高级 SQLite 会话\n \n-增强的 SQLite 会话，支持会话分支、用量分析和结构化查询：\n+增强版 SQLite 会话，支持会话分支、用量分析和结构化查询：\n \n ```python\n from agents.extensions.memory import AdvancedSQLiteSession\n@@ -224,11 +224,11 @@ await session.store_run_usage(result)  # Track token usage\n await session.create_branch_from_turn(2)  # Branch from turn 2\n ```\n \n-详见[高级 SQLite 会话](advanced_sqlite_session.md)的详细文档。\n+详见 [Advanced SQLite Sessions](advanced_sqlite_session.md) 的详细文档。\n \n ### 加密会话\n \n-适用于任意会话实现的透明加密封装器：\n+适用于任意会话实现的透明加密封装：\n \n ```python\n from agents.extensions.memory import EncryptedSession, SQLAlchemySession\n@@ -251,32 +251,32 @@ session = EncryptedSession(\n result = await Runner.run(agent, \"Hello\", session=session)\n ```\n \n-详见[加密会话](encrypted_session.md)的详细文档。\n+详见 [Encrypted Sessions](encrypted_session.md) 的详细文档。\n \n ### 其他会话类型\n \n-还有一些其他内置选项。请参阅 `examples/memory/` 以及 `extensions/memory/` 下的源码。\n+还有更多内置选项。请参考 `examples/memory/` 以及 `extensions/memory/` 下的源代码。\n \n ## 会话管理\n \n ### 会话 ID 命名\n \n-使用有意义的会话 ID 来帮助你组织对话：\n+使用有意义的会话 ID 以便组织对话：\n \n - 用户维度：`\"user_12345\"`\n - 线程维度：`\"thread_abc123\"`\n-- 场景维度：`\"support_ticket_456\"`\n+- 上下文维度：`\"support_ticket_456\"`\n \n ### 记忆持久化\n \n-- 使用内存型 SQLite（`SQLiteSession(\"session_id\")`）用于临时对话\n-- 使用文件型 SQLite（`SQLiteSession(\"session_id\", \"path/to/db.sqlite\")`）用于持久化对话\n-- 使用基于 SQLAlchemy 的会话（`SQLAlchemySession(\"session_id\", engine=engine, create_tables=True)`) 用于已有 SQLAlchemy 支持数据库的生产系统\n+- 使用内存版 SQLite（`SQLiteSession(\"session_id\")`）用于临时对话\n+- 使用文件版 SQLite（`SQLiteSession(\"session_id\", \"path/to/db.sqlite\")`）用于持久对话\n+- 使用基于 SQLAlchemy 的会话（`SQLAlchemySession(\"session_id\", engine=engine, create_tables=True)）`，适用于使用 SQLAlchemy 支持的现有数据库的生产系统\n - 使用 Dapr 状态存储会话（`DaprSession.from_address(\"session_id\", state_store_name=\"statestore\", dapr_address=\"localhost:50001\")`）用于生产级云原生部署，支持\n-30+ 种数据库后端，并内置遥测、追踪和数据隔离\n-- 当你希望将历史存储在 OpenAI Conversations API 中时，使用 OpenAI 托管存储（`OpenAIConversationsSession()`）\n+30+ 种数据库后端，具备内置遥测、追踪和数据隔离\n+- 当你希望将历史存储在 OpenAI Conversations API 中时，使用由 OpenAI 托管的存储（`OpenAIConversationsSession()`）\n - 使用加密会话（`EncryptedSession(session_id, underlying_session, encryption_key)`）为任意会话添加透明加密与基于 TTL 的过期\n-- 可考虑为其他生产系统（Redis、Django 等）实现自定义会话后端，以满足更高级的用例\n+- 针对更高级的用例，考虑为其他生产系统（Redis、Django 等）实现自定义会话后端\n \n ### 多个会话\n \n@@ -324,7 +324,7 @@ result2 = await Runner.run(\n \n ## 完整示例\n \n-下面是一个演示会话记忆实际效果的完整示例：\n+下面是一个展示会话记忆实际效果的完整示例：\n \n ```python\n import asyncio\n@@ -388,7 +388,7 @@ if __name__ == \"__main__\":\n \n ## 自定义会话实现\n \n-你可以通过创建一个遵循 [`Session`][agents.memory.session.Session] 协议的类，实现你自己的会话记忆：\n+你可以通过创建一个遵循 [`Session`][agents.memory.session.Session] 协议的类来实现自己的会话记忆：\n \n ```python\n from agents.memory.session import SessionABC\n@@ -433,22 +433,22 @@ result = await Runner.run(\n \n ## 社区会话实现\n \n-社区已开发了更多会话实现：\n+社区还开发了更多会话实现：\n \n-| Package | Description |\n+| 包 | 描述 |\n |---------|-------------|\n | [openai-django-sessions](https://pypi.org/project/openai-django-sessions/) | 基于 Django ORM 的会话，适用于任意 Django 支持的数据库（PostgreSQL、MySQL、SQLite 等） |\n \n-如果你构建了会话实现，欢迎提交文档 PR 将其添加到这里！\n+如果你构建了会话实现，欢迎提交文档 PR 将其添加到此处！\n \n ## API 参考\n \n-详尽的 API 文档请参阅：\n+有关详细 API 文档，请参见：\n \n - [`Session`][agents.memory.session.Session] - 协议接口\n-- [`OpenAIConversationsSession`][agents.memory.OpenAIConversationsSession] - OpenAI Conversations API 实现\n-- [`SQLiteSession`][agents.memory.sqlite_session.SQLiteSession] - 基本的 SQLite 实现\n+- [`OpenAIConversationsSession`][agents.memory.OpenAIConversationsSession] - OpenAI Conversations API 的实现\n+- [`SQLiteSession`][agents.memory.sqlite_session.SQLiteSession] - 基础的 SQLite 实现\n - [`SQLAlchemySession`][agents.extensions.memory.sqlalchemy_session.SQLAlchemySession] - 基于 SQLAlchemy 的实现\n - [`DaprSession`][agents.extensions.memory.dapr_session.DaprSession] - Dapr 状态存储实现\n-- [`AdvancedSQLiteSession`][agents.extensions.memory.advanced_sqlite_session.AdvancedSQLiteSession] - 具备分支和分析功能的增强型 SQLite\n-- [`EncryptedSession`][agents.extensions.memory.encrypt_session.EncryptedSession] - 适用于任意会话的加密封装器\n\\ No newline at end of file\n+- [`AdvancedSQLiteSession`][agents.extensions.memory.advanced_sqlite_session.AdvancedSQLiteSession] - 具备分支与分析的增强版 SQLite\n+- [`EncryptedSession`][agents.extensions.memory.encrypt_session.EncryptedSession] - 适用于任意会话的加密封装\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Fsessions%2Findex.md",
        "sha": "c9efb829463ed59df95b649e53edfe39da4bcd94",
        "status": "modified"
      },
      {
        "additions": 3,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Fsessions%2Fsqlalchemy_session.md",
        "changes": 6,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fzh%2Fsessions%2Fsqlalchemy_session.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 3,
        "filename": "docs/zh/sessions/sqlalchemy_session.md",
        "patch": "@@ -4,11 +4,11 @@ search:\n ---\n # SQLAlchemy 会话\n \n-`SQLAlchemySession` 使用 SQLAlchemy 提供可用于生产环境的会话实现，使你可以使用任何 SQLAlchemy 支持的数据库（PostgreSQL、MySQL、SQLite 等）来存储会话。\n+`SQLAlchemySession` 使用 SQLAlchemy 提供可用于生产的会话实现，使你可以使用 SQLAlchemy 支持的任何数据库（PostgreSQL、MySQL、SQLite 等）进行会话存储。\n \n ## 安装\n \n-SQLAlchemy 会话需要 `sqlalchemy` extra：\n+SQLAlchemy 会话需要 `sqlalchemy` 可选依赖：\n \n ```bash\n pip install openai-agents[sqlalchemy]\n@@ -77,4 +77,4 @@ if __name__ == \"__main__\":\n ## API 参考\n \n - [`SQLAlchemySession`][agents.extensions.memory.sqlalchemy_session.SQLAlchemySession] - 主类\n-- [`Session`][agents.memory.session.Session] - 基础会话协议\n\\ No newline at end of file\n+- [`Session`][agents.memory.session.Session] - 基本会话协议\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Fsessions%2Fsqlalchemy_session.md",
        "sha": "ec4c969e3396425ab2f9359ca244eea30a599870",
        "status": "modified"
      },
      {
        "additions": 6,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Fstreaming.md",
        "changes": 12,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fzh%2Fstreaming.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 6,
        "filename": "docs/zh/streaming.md",
        "patch": "@@ -4,15 +4,15 @@ search:\n ---\n # 流式传输\n \n-流式传输允许你在智能体运行过程中订阅其更新。这对于向最终用户展示进度更新和部分响应很有用。\n+流式传输允许你在智能体运行的过程中订阅其更新。这对于向终端用户显示进度更新和部分响应很有用。\n \n-要进行流式传输，你可以调用[`Runner.run_streamed()`][agents.run.Runner.run_streamed]，它会返回一个[`RunResultStreaming`][agents.result.RunResultStreaming]。调用`result.stream_events()`会得到一个由[`StreamEvent`][agents.stream_events.StreamEvent]对象组成的异步流，详见下文。\n+要进行流式传输，你可以调用[`Runner.run_streamed()`][agents.run.Runner.run_streamed]，它将返回一个[`RunResultStreaming`][agents.result.RunResultStreaming]。调用`result.stream_events()`会得到一个由[`StreamEvent`][agents.stream_events.StreamEvent]对象组成的异步流，详见下文。\n \n ## 原始响应事件\n \n-[`RawResponsesStreamEvent`][agents.stream_events.RawResponsesStreamEvent]是直接从 LLM 传递的原始事件。它们采用 OpenAI Responses API 格式，这意味着每个事件都有一个类型（如`response.created`、`response.output_text.delta`等）和数据。如果你想在消息生成时立刻向用户流式传输响应内容，这些事件很有用。\n+[`RawResponsesStreamEvent`][agents.stream_events.RawResponsesStreamEvent]是直接来自 LLM 的原始事件。它们采用 OpenAI Responses API 格式，这意味着每个事件都有一个类型（如`response.created`、`response.output_text.delta`等）以及数据。如果你希望在生成后立刻将响应消息流式传输给用户，这些事件会很有用。\n \n-例如，下面将逐 token 输出由 LLM 生成的文本。\n+例如，下面的代码将以逐个 token 的方式输出 LLM 生成的文本。\n \n ```python\n import asyncio\n@@ -37,9 +37,9 @@ if __name__ == \"__main__\":\n \n ## 运行项事件与智能体事件\n \n-[`RunItemStreamEvent`][agents.stream_events.RunItemStreamEvent]是更高层级的事件。它们会在一个条目完全生成时通知你。这样你可以在“消息已生成”“工具已运行”等层级推送进度更新，而不是在每个 token 层级。类似地，[`AgentUpdatedStreamEvent`][agents.stream_events.AgentUpdatedStreamEvent]会在当前智能体发生变化时（例如由于一次任务转移）向你推送更新。\n+[`RunItemStreamEvent`][agents.stream_events.RunItemStreamEvent]属于更高层级的事件。它们会告知某个项已完全生成。这使你可以在“消息已生成”“工具已运行”等层级推送进度更新，而不是每个 token。类似地，[`AgentUpdatedStreamEvent`][agents.stream_events.AgentUpdatedStreamEvent]会在当前智能体发生变化时（例如由于一次任务转移）提供更新。\n \n-例如，下面会忽略原始事件，并向用户流式传输更新。\n+例如，下面的代码将忽略原始事件，仅向用户流式传输更新。\n \n ```python\n import asyncio",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Fstreaming.md",
        "sha": "1a46d997ae0b8ff8541cf2ce4b2128f09832524d",
        "status": "modified"
      },
      {
        "additions": 48,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Ftools.md",
        "changes": 96,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fzh%2Ftools.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 48,
        "filename": "docs/zh/tools.md",
        "patch": "@@ -4,21 +4,21 @@ search:\n ---\n # 工具\n \n-工具让智能体能够执行操作：例如获取数据、运行代码、调用外部 API，甚至进行计算机操作。在 Agent SDK 中，工具分为三类：\n+工具让智能体执行操作：例如获取数据、运行代码、调用外部 API，甚至进行计算机操作。Agents SDK 中有三类工具：\n \n-- 托管工具：它们在 LLM 服务与 AI 模型并行运行。OpenAI 提供检索、网络检索和计算机操作等托管工具。\n-- Function calling：允许你将任意 Python 函数用作工具。\n-- 将智能体作为工具：允许你把一个智能体当作工具使用，使智能体在不进行任务转移的情况下调用其他智能体。\n+- 托管工具：这些工具与 AI 模型一起运行在 LLM 服务上。OpenAI 提供检索、网络检索和计算机操作等托管工具。\n+- Function calling：这些允许你将任意 Python 函数用作工具。\n+- 将智能体作为工具：这使你可以把智能体当作工具使用，从而让智能体在不进行任务转移的情况下调用其他智能体。\n \n ## 托管工具\n \n-使用 [`OpenAIResponsesModel`][agents.models.openai_responses.OpenAIResponsesModel] 时，OpenAI 提供了一些内置工具：\n+使用 [`OpenAIResponsesModel`][agents.models.openai_responses.OpenAIResponsesModel] 时，OpenAI 提供一些内置工具：\n \n - [`WebSearchTool`][agents.tool.WebSearchTool] 让智能体进行网络检索。\n-- [`FileSearchTool`][agents.tool.FileSearchTool] 允许从你的 OpenAI 向量存储 中检索信息。\n+- [`FileSearchTool`][agents.tool.FileSearchTool] 允许从你的 OpenAI 向量存储中检索信息。\n - [`ComputerTool`][agents.tool.ComputerTool] 允许自动化计算机操作任务。\n - [`CodeInterpreterTool`][agents.tool.CodeInterpreterTool] 让 LLM 在沙盒环境中执行代码。\n-- [`HostedMCPTool`][agents.tool.HostedMCPTool] 将远程 MCP 服务 的工具暴露给模型。\n+- [`HostedMCPTool`][agents.tool.HostedMCPTool] 将远程 MCP 服务的工具暴露给模型。\n - [`ImageGenerationTool`][agents.tool.ImageGenerationTool] 根据提示生成图像。\n - [`LocalShellTool`][agents.tool.LocalShellTool] 在你的机器上运行 shell 命令。\n \n@@ -41,16 +41,16 @@ async def main():\n     print(result.final_output)\n ```\n \n-## 工具调用\n+## 函数工具\n \n-你可以将任何 Python 函数用作工具。Agents SDK 会自动为你设置该工具：\n+你可以将任意 Python 函数用作工具。Agents SDK 会自动设置该工具：\n \n-- 工具名称将是 Python 函数名（或你也可以自定义名称）\n-- 工具描述将来自函数的 docstring（或你也可以自定义描述）\n+- 工具名称将是 Python 函数名（或你可以自定义名称）\n+- 工具描述将取自函数的 docstring（或你可以自定义描述）\n - 函数输入的模式会根据函数参数自动创建\n-- 各输入的描述将来自函数的 docstring，除非你禁用此行为\n+- 每个输入的描述来自函数的 docstring，除非被禁用\n \n-我们使用 Python 的 `inspect` 模块提取函数签名，使用 [`griffe`](https://mkdocstrings.github.io/griffe/) 解析 docstring，并使用 `pydantic` 创建模式。\n+我们使用 Python 的 `inspect` 模块提取函数签名，配合 [`griffe`](https://mkdocstrings.github.io/griffe/) 解析 docstring，并使用 `pydantic` 创建模式。\n \n ```python\n import json\n@@ -102,9 +102,9 @@ for tool in agent.tools:\n \n ```\n \n-1. 你可以使用任何 Python 类型作为函数参数，函数可以是同步或异步的。\n-2. 若存在 docstring，将用于提取工具和参数的描述。\n-3. 函数可以选择性地接收 `context`（必须是第一个参数）。你也可以设置覆盖项，如工具名称、描述、docstring 风格等。\n+1. 你可以使用任意 Python 类型作为函数参数，函数可以是同步或异步。\n+2. 如果存在 docstring，将用于捕获描述和参数描述。\n+3. 函数可选接收 `context`（必须是第一个参数）。你也可以设置覆盖项，如工具名称、描述、docstring 风格等。\n 4. 你可以将装饰后的函数传入工具列表。\n \n ??? note \"展开以查看输出\"\n@@ -177,22 +177,22 @@ for tool in agent.tools:\n     }\n     ```\n \n-### 从工具调用返回图像或文件\n+### 从函数工具返回图像或文件\n \n-除了返回文本输出外，你还可以让工具调用返回一个或多个图像或文件。为此，可以返回以下任意内容：\n+除了返回文本输出外，你还可以将一张或多张图像或文件作为函数工具的输出返回。为此，你可以返回以下任意内容：\n \n-- 图像：[`ToolOutputImage`][agents.tool.ToolOutputImage]（或其 TypedDict 版本 [`ToolOutputImageDict`][agents.tool.ToolOutputImageDict]）\n-- 文件：[`ToolOutputFileContent`][agents.tool.ToolOutputFileContent]（或其 TypedDict 版本 [`ToolOutputFileContentDict`][agents.tool.ToolOutputFileContentDict]）\n-- 文本：字符串或可转为字符串的对象，或 [`ToolOutputText`][agents.tool.ToolOutputText]（或其 TypedDict 版本 [`ToolOutputTextDict`][agents.tool.ToolOutputTextDict]）\n+- 图像：[`ToolOutputImage`][agents.tool.ToolOutputImage]（或 TypedDict 版本 [`ToolOutputImageDict`][agents.tool.ToolOutputImageDict]）\n+- 文件：[`ToolOutputFileContent`][agents.tool.ToolOutputFileContent]（或 TypedDict 版本 [`ToolOutputFileContentDict`][agents.tool.ToolOutputFileContentDict]）\n+- 文本：字符串或可转为字符串的对象，或 [`ToolOutputText`][agents.tool.ToolOutputText]（或 TypedDict 版本 [`ToolOutputTextDict`][agents.tool.ToolOutputTextDict]）\n \n-### 自定义工具调用\n+### 自定义函数工具\n \n-有时你不希望使用 Python 函数作为工具。你可以直接创建一个 [`FunctionTool`][agents.tool.FunctionTool]。你需要提供：\n+有时你可能不想将 Python 函数作为工具。如果你愿意，可以直接创建一个 [`FunctionTool`][agents.tool.FunctionTool]。你需要提供：\n \n - `name`\n - `description`\n - `params_json_schema`，即参数的 JSON 模式\n-- `on_invoke_tool`，这是一个异步函数，接收 [`ToolContext`][agents.tool_context.ToolContext] 和作为 JSON 字符串的参数，并且必须返回字符串形式的工具输出。\n+- `on_invoke_tool`，一个异步函数，接收 [`ToolContext`][agents.tool_context.ToolContext] 和 JSON 字符串形式的参数，并且必须返回字符串形式的工具输出。\n \n ```python\n from typing import Any\n@@ -227,16 +227,16 @@ tool = FunctionTool(\n \n ### 自动参数与 docstring 解析\n \n-如前所述，我们会自动解析函数签名以提取工具的模式，并解析 docstring 来获得工具及各参数的描述。注意事项：\n+如前所述，我们会自动解析函数签名以提取工具的模式，并解析 docstring 以提取工具及各个参数的描述。注意事项如下：\n \n-1. 使用 `inspect` 模块进行签名解析。我们依据类型注解理解参数类型，并动态构建一个 Pydantic 模型来表示整体模式。支持大多数类型，包括 Python 基础类型、Pydantic 模型、TypedDict 等。\n-2. 我们使用 `griffe` 解析 docstring。支持的 docstring 格式有 `google`、`sphinx` 和 `numpy`。我们会尽力自动检测 docstring 格式，但你也可以在调用 `function_tool` 时显式设置。也可以通过将 `use_docstring_info` 设为 `False` 来禁用 docstring 解析。\n+1. 使用 `inspect` 模块进行签名解析。我们利用类型注解理解参数类型，并动态构建一个 Pydantic 模型来表示整体模式。它支持大多数类型，包括 Python 基本类型、Pydantic 模型、TypedDict 等。\n+2. 我们使用 `griffe` 解析 docstring。支持的 docstring 格式包括 `google`、`sphinx` 和 `numpy`。我们会尝试自动检测 docstring 格式，但这仅是尽力而为，你也可以在调用 `function_tool` 时显式设置。你还可以通过将 `use_docstring_info` 设为 `False` 来禁用 docstring 解析。\n \n-用于提取模式的代码位于 [`agents.function_schema`][] 中。\n+用于模式提取的代码位于 [`agents.function_schema`][]。\n \n ## 将智能体作为工具\n \n-在某些工作流中，你可能希望由一个中心智能体来编排一组专业化的智能体，而不是进行任务转移。你可以通过将智能体建模为工具来实现。\n+在某些工作流中，你可能希望由一个中心智能体编排一组专业化智能体，而不是将控制权进行任务转移。你可以通过将智能体建模为工具来实现。\n \n ```python\n from agents import Agent, Runner\n@@ -277,7 +277,7 @@ async def main():\n \n ### 自定义工具化智能体\n \n-`agent.as_tool` 是一个便捷方法，可轻松将智能体转换为工具。但它并不支持所有配置；例如，你无法设置 `max_turns`。对于更高级的用例，请在你的工具实现中直接使用 `Runner.run`：\n+`agent.as_tool` 是一个便捷方法，便于将智能体转换为工具。它并不支持所有配置；例如，你不能设置 `max_turns`。对于高级用例，请在你的工具实现中直接使用 `Runner.run`：\n \n ```python\n @function_tool\n@@ -298,11 +298,11 @@ async def run_my_agent() -> str:\n \n ### 自定义输出提取\n \n-在某些情况下，你可能希望在将输出返回给中心智能体之前对工具化智能体的输出进行修改。如果你希望：\n+在某些情况下，你可能希望在将工具化智能体的输出返回给中心智能体之前对其进行修改。如果你希望：\n \n-- 从子智能体的聊天历史中提取特定信息（例如 JSON 负载）。\n-- 转换或重格式化智能体的最终答案（例如将 Markdown 转为纯文本或 CSV）。\n-- 验证输出，或在智能体的响应缺失或格式错误时提供后备值。\n+- 从子智能体的对话历史中提取特定信息（例如 JSON 负载）。\n+- 转换或重新格式化智能体的最终答案（例如将 Markdown 转为纯文本或 CSV）。\n+- 验证输出或在智能体响应缺失或格式错误时提供回退值。\n \n 你可以通过向 `as_tool` 方法提供 `custom_output_extractor` 参数来实现：\n \n@@ -325,7 +325,7 @@ json_tool = data_agent.as_tool(\n \n ### 流式传输嵌套智能体运行\n \n-向 `as_tool` 传入 `on_stream` 回调，以监听嵌套智能体发出的流式传输事件，同时在流结束后仍返回其最终输出。\n+将 `on_stream` 回调传递给 `as_tool`，以在返回流完成后的最终输出同时，监听由嵌套智能体发出的流式传输事件。\n \n ```python\n from agents import AgentToolStreamEvent\n@@ -345,11 +345,11 @@ billing_agent_tool = billing_agent.as_tool(\n \n 预期行为：\n \n-- 事件类型与 `StreamEvent[\"type\"]` 对应：`raw_response_event`、`run_item_stream_event`、`agent_updated_stream_event`。\n-- 提供 `on_stream` 会自动以流式模式运行嵌套智能体，并在返回最终输出之前耗尽流。\n-- 处理器可以是同步或异步的；每个事件会按到达顺序投递。\n-- 当通过模型的工具调用触发时，`tool_call_id` 会出现；直接调用时可能为 `None`。\n-- 参见 `examples/agent_patterns/agents_as_tools_streaming.py` 获取完整可运行的示例。\n+- 事件类型与 `StreamEvent[\"type\"]` 一致：`raw_response_event`、`run_item_stream_event`、`agent_updated_stream_event`。\n+- 提供 `on_stream` 会自动以流式传输模式运行嵌套智能体，并在返回最终输出前排空该流。\n+- 处理器可以是同步或异步的；每个事件按到达顺序传递。\n+- 当通过模型工具调用调用该工具时会包含 `tool_call_id`；直接调用时可能为 `None`。\n+- 参见 `examples/agent_patterns/agents_as_tools_streaming.py` 获取完整可运行示例。\n \n ### 条件启用工具\n \n@@ -414,20 +414,20 @@ asyncio.run(main())\n - **可调用函数**：接收 `(context, agent)` 并返回布尔值的函数\n - **异步函数**：用于复杂条件逻辑的异步函数\n \n-被禁用的工具在运行时对 LLM 完全不可见，适用于：\n+被禁用的工具在运行时会对 LLM 完全隐藏，适用于：\n \n-- 基于用户权限的功能门控\n+- 基于用户权限的功能开关\n - 基于环境的工具可用性（开发 vs 生产）\n - 不同工具配置的 A/B 测试\n - 基于运行时状态的动态工具筛选\n \n-## 在工具调用中处理错误\n+## 在函数工具中处理错误\n \n-当你通过 `@function_tool` 创建工具调用时，可以传入 `failure_error_function`。这是一个在工具调用崩溃时向 LLM 提供错误响应的函数。\n+当你通过 `@function_tool` 创建函数工具时，你可以传入 `failure_error_function`。这是一个在工具调用崩溃时向 LLM 提供错误响应的函数。\n \n-- 默认情况下（即未传入任何内容），会运行 `default_tool_error_function`，告知 LLM 发生了错误。\n-- 若你传入了自定义错误函数，则运行该函数，并将其响应发送给 LLM。\n-- 如果你显式传入 `None`，则任何工具调用错误都会被重新抛出以供你处理。若模型产生了无效的 JSON，可能会是 `ModelBehaviorError`；若你的代码崩溃，可能会是 `UserError` 等。\n+- 默认情况下（即未传入时），会运行 `default_tool_error_function`，告知 LLM 发生了错误。\n+- 如果你传入了自定义错误函数，则会运行该函数，并将响应发送给 LLM。\n+- 如果你显式传入 `None`，则任何工具调用错误都会被重新抛出供你处理。如果模型生成了无效 JSON，可能会是 `ModelBehaviorError`；如果你的代码崩溃了，可能会是 `UserError`，等等。\n \n ```python\n from agents import function_tool, RunContextWrapper\n@@ -450,4 +450,4 @@ def get_user_profile(user_id: str) -> str:\n \n ```\n \n-如果你手动创建 `FunctionTool` 对象，则必须在 `on_invoke_tool` 函数内部处理错误。\n\\ No newline at end of file\n+如果你手动创建一个 `FunctionTool` 对象，则必须在 `on_invoke_tool` 函数内部处理错误。\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Ftools.md",
        "sha": "7c08600e2d78b8bae44fe52e4ff7dfb32eb1b8f4",
        "status": "modified"
      },
      {
        "additions": 59,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Ftracing.md",
        "changes": 104,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fzh%2Ftracing.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 45,
        "filename": "docs/zh/tracing.md",
        "patch": "@@ -4,52 +4,52 @@ search:\n ---\n # 追踪\n \n-Agents SDK 内置了追踪功能，可在智能体运行期间收集全面的事件记录：LLM 生成、工具调用、任务转移、安全防护措施，以及自定义事件。使用 [Traces 仪表板](https://platform.openai.com/traces)，你可以在开发和生产环境中对工作流进行调试、可视化和监控。\n+Agents SDK 内置了追踪功能，会在智能体运行期间收集全面的事件记录：LLM 生成、工具调用、任务转移、安全防护措施，甚至自定义事件。使用 [Traces 仪表板](https://platform.openai.com/traces)，你可以在开发与生产环境中调试、可视化并监控你的工作流。\n \n !!!note\n \n-    追踪默认启用。可通过两种方式禁用追踪：\n+    追踪默认已启用。可以通过以下两种方式禁用追踪：\n \n-    1. 你可以通过设置环境变量 `OPENAI_AGENTS_DISABLE_TRACING=1` 全局禁用追踪\n-    2. 你可以通过将 [`agents.run.RunConfig.tracing_disabled`][] 设置为 `True` 来仅对单次运行禁用追踪\n+    1. 通过设置环境变量 `OPENAI_AGENTS_DISABLE_TRACING=1` 全局禁用追踪\n+    2. 通过将 [`agents.run.RunConfig.tracing_disabled`][] 设置为 `True`，仅对单次运行禁用追踪\n \n-***对于在使用 OpenAI API 且遵循 Zero Data Retention (ZDR) 策略的组织，无法使用追踪功能。***\n+***对于在使用 OpenAI 的 API 并遵循 Zero Data Retention (ZDR) 策略的组织，追踪不可用。***\n \n ## 追踪与 Span\n \n--   **追踪**代表一次“工作流”的端到端操作。它由多个 Span 组成。追踪具备以下属性：\n-    -   `workflow_name`：逻辑上的工作流或应用。例如 “Code generation” 或 “Customer service”。\n-    -   `trace_id`：追踪的唯一 ID。如果未传入将自动生成。必须符合格式 `trace_<32_alphanumeric>`。\n-    -   `group_id`：可选的分组 ID，用于关联同一会话中的多个追踪。例如你可以使用会话线程 ID。\n-    -   `disabled`：若为 True，则不会记录该追踪。\n-    -   `metadata`：追踪的可选元数据。\n--   **Spans** 表示具有开始和结束时间的操作。Span 包含：\n+-   **追踪（Traces）** 表示一次“工作流”的端到端操作。它由多个 Span 组成。追踪具有以下属性：\n+    -   `workflow_name`：逻辑上的工作流或应用名称。例如 “Code generation” 或 “Customer service”。\n+    -   `trace_id`：该追踪的唯一 ID。如果未传入，会自动生成。必须符合 `trace_<32_alphanumeric>` 的格式。\n+    -   `group_id`：可选的分组 ID，用于将同一会话中的多个追踪关联起来。例如，你可以使用聊天线程 ID。\n+    -   `disabled`：如果为 True，则不会记录该追踪。\n+    -   `metadata`：该追踪的可选元数据。\n+-   **Span（跨度）** 表示具有开始和结束时间的操作。Span 具有：\n     -   `started_at` 和 `ended_at` 时间戳。\n-    -   `trace_id`，表示所属的追踪\n-    -   `parent_id`，指向该 Span 的父 Span（如有）\n-    -   `span_data`，关于该 Span 的信息。例如，`AgentSpanData` 包含关于智能体的信息，`GenerationSpanData` 包含关于 LLM 生成的信息等。\n+    -   `trace_id`，表示其所属的追踪\n+    -   `parent_id`，指向该 Span 的父 Span（如果有）\n+    -   `span_data`，关于该 Span 的信息。例如，`AgentSpanData` 包含关于智能体的信息，`GenerationSpanData` 包含关于 LLM 生成的信息，等等。\n \n ## 默认追踪\n \n 默认情况下，SDK 会追踪以下内容：\n \n--   整个 `Runner.{run, run_sync, run_streamed}()` 被包裹在 `trace()` 中。\n--   每次智能体运行，都会被包裹在 `agent_span()` 中\n--   LLM 生成会被包裹在 `generation_span()` 中\n--   每次 function 工具调用都会被包裹在 `function_span()` 中\n--   安全防护措施会被包裹在 `guardrail_span()` 中\n--   任务转移会被包裹在 `handoff_span()` 中\n--   音频输入（语音转文本）会被包裹在 `transcription_span()` 中\n--   音频输出（文本转语音）会被包裹在 `speech_span()` 中\n--   相关音频 Span 可能会被挂载在 `speech_group_span()` 之下\n+-   整个 `Runner.{run, run_sync, run_streamed}()` 会被 `trace()` 包裹。\n+-   每次智能体运行，都会被 `agent_span()` 包裹\n+-   LLM 生成会被 `generation_span()` 包裹\n+-   工具调用会分别被 `function_span()` 包裹\n+-   安全防护措施会被 `guardrail_span()` 包裹\n+-   任务转移会被 `handoff_span()` 包裹\n+-   音频输入（语音转文本）会被 `transcription_span()` 包裹\n+-   音频输出（文本转语音）会被 `speech_span()` 包裹\n+-   相关音频 Span 可能会挂载在 `speech_group_span()` 之下\n \n-默认情况下，追踪名称为 “Agent workflow”。如果你使用 `trace`，可以设置该名称；或者可以通过 [`RunConfig`][agents.run.RunConfig] 配置名称和其他属性。\n+默认情况下，追踪名称为 “Agent workflow”。如果使用 `trace`，你可以设置该名称；或者通过 [`RunConfig`][agents.run.RunConfig] 配置名称和其他属性。\n \n-此外，你可以设置[自定义追踪处理器](#custom-tracing-processors)，将追踪推送到其他目标位置（作为替代或辅助目的地）。\n+此外，你可以设置[自定义追踪进程](#custom-tracing-processors)，将追踪推送到其他目标（作为替代或第二目的地）。\n \n ## 更高层级的追踪\n \n-有时，你可能希望多次调用 `run()` 属于同一个追踪。你可以将整段代码包裹在 `trace()` 中实现这一点。\n+有时，你可能希望多次调用 `run()` 属于同一个追踪。可以通过将整段代码包裹在 `trace()` 中实现。\n \n ```python\n from agents import Agent, Runner, trace\n@@ -64,46 +64,47 @@ async def main():\n         print(f\"Rating: {second_result.final_output}\")\n ```\n \n-1. 由于两次对 `Runner.run` 的调用都包裹在 `with trace()` 中，单独的运行将属于总体追踪的一部分，而不是创建两个追踪。\n+1. 因为两次对 `Runner.run` 的调用都包裹在 `with trace()` 中，单独的运行会归入同一个整体追踪，而不是创建两个追踪。\n \n ## 创建追踪\n \n-你可以使用 [`trace()`][agents.tracing.trace] 函数创建一个追踪。追踪需要被启动和结束。你有两种方式：\n+你可以使用 [`trace()`][agents.tracing.trace] 函数创建追踪。追踪需要显式开始与结束。可以通过两种方式完成：\n \n-1. 推荐方式：将 trace 作为上下文管理器使用，即 `with trace(...) as my_trace`。这会在正确的时间自动启动并结束追踪。\n+1. 推荐：将 trace 用作上下文管理器，即 `with trace(...) as my_trace`。这会在合适的时机自动开始并结束追踪。\n 2. 你也可以手动调用 [`trace.start()`][agents.tracing.Trace.start] 和 [`trace.finish()`][agents.tracing.Trace.finish]。\n \n-当前追踪通过 Python 的 [`contextvar`](https://docs.python.org/3/library/contextvars.html) 进行跟踪。这意味着它可自动与并发协同工作。如果你手动启动/结束追踪，则需要在 `start()`/`finish()` 时传入 `mark_as_current` 和 `reset_current` 来更新当前追踪。\n+当前追踪通过 Python 的 [`contextvar`](https://docs.python.org/3/library/contextvars.html) 跟踪。这意味着它可自动适配并发。如果你手动开始/结束追踪，需要在 `start()`/`finish()` 中分别传入 `mark_as_current` 和 `reset_current` 来更新当前追踪。\n \n ## 创建 Span\n \n-你可以使用各种 [`*_span()`][agents.tracing.create] 方法来创建 Span。一般情况下，你无需手动创建 Span。可使用 [`custom_span()`][agents.tracing.custom_span] 来记录自定义的 Span 信息。\n+你可以使用各种 [`*_span()`][agents.tracing.create] 方法来创建 Span。通常你不需要手动创建 Span。提供了一个 [`custom_span()`][agents.tracing.custom_span] 函数用于跟踪自定义的 Span 信息。\n \n-Span 会自动加入当前追踪，并嵌套在最近的当前 Span 之下，其跟踪通过 Python 的 [`contextvar`](https://docs.python.org/3/library/contextvars.html) 实现。\n+Span 会自动归入当前追踪，并嵌套在最近的当前 Span 之下；该状态通过 Python 的 [`contextvar`](https://docs.python.org/3/library/contextvars.html) 跟踪。\n \n ## 敏感数据\n \n 某些 Span 可能会捕获潜在的敏感数据。\n \n-`generation_span()` 会存储 LLM 生成的输入/输出，`function_span()` 会存储函数调用的输入/输出。这些可能包含敏感数据，因此你可以通过 [`RunConfig.trace_include_sensitive_data`][agents.run.RunConfig.trace_include_sensitive_data] 禁用对这些数据的采集。\n+`generation_span()` 会存储 LLM 生成的输入/输出，`function_span()` 会存储工具调用的输入/输出。这些内容可能包含敏感数据，因此你可以通过 [`RunConfig.trace_include_sensitive_data`][agents.run.RunConfig.trace_include_sensitive_data] 禁用这些数据的捕获。\n \n-同样，音频相关的 Span 默认会包含输入与输出音频的 base64 编码 PCM 数据。你可以通过配置 [`VoicePipelineConfig.trace_include_sensitive_audio_data`][agents.voice.pipeline_config.VoicePipelineConfig.trace_include_sensitive_audio_data] 来禁用音频数据的采集。\n+同样地，音频相关的 Span 默认会包含输入与输出音频的 base64 编码 PCM 数据。你可以通过配置 [`VoicePipelineConfig.trace_include_sensitive_audio_data`][agents.voice.pipeline_config.VoicePipelineConfig.trace_include_sensitive_audio_data] 禁用音频数据的捕获。\n \n-## 自定义追踪处理器\n+## 自定义追踪进程\n \n 追踪的高层架构如下：\n \n--   初始化时，我们会创建一个全局的 [`TraceProvider`][agents.tracing.setup.TraceProvider]，负责创建追踪。\n--   我们将 `TraceProvider` 配置为使用 [`BatchTraceProcessor`][agents.tracing.processors.BatchTraceProcessor]，它会将追踪/Span 批量发送到 [`BackendSpanExporter`][agents.tracing.processors.BackendSpanExporter]，后者会将 Span 和追踪批量导出到 OpenAI 后端。\n+-   在初始化时，我们创建一个全局的 [`TraceProvider`][agents.tracing.setup.TraceProvider]，负责创建追踪。\n+-   我们为 `TraceProvider` 配置一个 [`BatchTraceProcessor`][agents.tracing.processors.BatchTraceProcessor]，它会将追踪/Span 以批量形式发送到 [`BackendSpanExporter`][agents.tracing.processors.BackendSpanExporter]，再由其批量导出到 OpenAI 后端。\n \n-若要自定义该默认设置，以将追踪发送到替代或附加的后端，或修改导出器行为，你有两种选择：\n+若要自定义该默认设置、将追踪发送到备用或附加后端，或修改导出器行为，你有两种选择：\n+\n+1. [`add_trace_processor()`][agents.tracing.add_trace_processor] 允许你添加一个“额外的”追踪进程，它会在追踪和 Span 就绪时接收它们。这样你可以在将追踪发送到 OpenAI 后端之外，执行你自己的处理。\n+2. [`set_trace_processors()`][agents.tracing.set_trace_processors] 允许你“替换”默认的进程为你自己的追踪进程。除非你包含一个将数据发送到 OpenAI 后端的 `TracingProcessor`，否则追踪将不会发送至 OpenAI 后端。\n \n-1. [`add_trace_processor()`][agents.tracing.add_trace_processor] 允许你添加一个额外的追踪处理器，它会在追踪和 Span 就绪时接收它们。这使你可以在向 OpenAI 后端发送追踪之外，执行你自己的处理。\n-2. [`set_trace_processors()`][agents.tracing.set_trace_processors] 允许你用你自己的追踪处理器替换默认处理器。这意味着除非你包含一个将追踪发送到 OpenAI 后端的 `TracingProcessor`，否则追踪将不会被发送到 OpenAI 后端。\n \n ## 使用非 OpenAI 模型进行追踪\n \n-你可以将 OpenAI API key 与非 OpenAI 模型一起使用，在无需禁用追踪的情况下，在 OpenAI Traces 仪表板中启用免费的追踪。\n+你可以将 OpenAI API key 与非 OpenAI 模型一同使用，在无需禁用追踪的情况下，在 OpenAI Traces 仪表板中启用免费的追踪。\n \n ```python\n import os\n@@ -124,10 +125,23 @@ agent = Agent(\n )\n ```\n \n-## 备注\n-- 在 OpenAI Traces 仪表板查看免费追踪。\n+如果你只需要为单次运行使用不同的追踪 key，请通过 `RunConfig` 传入，而不是更改全局导出器。\n+\n+```python\n+from agents import Runner, RunConfig\n+\n+await Runner.run(\n+    agent,\n+    input=\"Hello\",\n+    run_config=RunConfig(tracing={\"api_key\": \"sk-tracing-123\"}),\n+)\n+```\n+\n+## 说明\n+- 在 Openai Traces 仪表板查看免费追踪。\n+\n \n-## 外部追踪处理器列表\n+## 外部追踪进程列表\n \n -   [Weights & Biases](https://weave-docs.wandb.ai/guides/integrations/openai_agents)\n -   [Arize-Phoenix](https://docs.arize.com/phoenix/tracing/integrations-tracing/openai-agents-sdk)",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Ftracing.md",
        "sha": "93b0c902114577178c866f8d75ad48e1ed7112e2",
        "status": "modified"
      },
      {
        "additions": 22,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Fusage.md",
        "changes": 44,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fzh%2Fusage.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 22,
        "filename": "docs/zh/usage.md",
        "patch": "@@ -2,24 +2,24 @@\n search:\n   exclude: true\n ---\n-# 用量\n+# 使用量\n \n-Agents SDK 会自动追踪每次运行的 token 用量。你可以从运行上下文中访问它，用于监控成本、实施限制或记录分析数据。\n+Agents SDK 会自动为每次运行追踪 token 使用情况。你可以从运行上下文中获取它，用于监控成本、执行限制或记录分析数据。\n \n ## 追踪内容\n \n - **requests**: 发起的 LLM API 调用次数\n-- **input_tokens**: 发送的输入 tokens 总数\n-- **output_tokens**: 接收的输出 tokens 总数\n+- **input_tokens**: 发送的输入 token 总数\n+- **output_tokens**: 接收的输出 token 总数\n - **total_tokens**: 输入 + 输出\n-- **request_usage_entries**: 按请求的用量明细列表\n+- **request_usage_entries**: 每次请求的使用量明细列表\n - **details**:\n   - `input_tokens_details.cached_tokens`\n   - `output_tokens_details.reasoning_tokens`\n \n-## 从一次运行中访问用量\n+## 从一次运行访问使用量\n \n-在 `Runner.run(...)` 之后，通过 `result.context_wrapper.usage` 访问用量。\n+在 `Runner.run(...)` 之后，通过 `result.context_wrapper.usage` 获取使用量。\n \n ```python\n result = await Runner.run(agent, \"What's the weather in Tokyo?\")\n@@ -31,11 +31,11 @@ print(\"Output tokens:\", usage.output_tokens)\n print(\"Total tokens:\", usage.total_tokens)\n ```\n \n-用量会在本次运行中的所有模型调用之间聚合（包括工具调用和任务转移）。\n+使用量会在运行期间的所有模型调用中聚合（包括工具调用和任务转移）。\n \n-### 在 LiteLLM 模型中启用用量\n+### 在 LiteLLM 模型中启用使用量\n \n-默认情况下，LiteLLM 提供方不会报告用量指标。使用 [`LitellmModel`](models/litellm.md) 时，向你的智能体传入 `ModelSettings(include_usage=True)`，以便 LiteLLM 的响应填充 `result.context_wrapper.usage`。\n+LiteLLM 提供方默认不报告使用量指标。当你使用 [`LitellmModel`](models/litellm.md) 时，向你的智能体传入 `ModelSettings(include_usage=True)`，以便 LiteLLM 的响应填充 `result.context_wrapper.usage`。\n \n ```python\n from agents import Agent, ModelSettings, Runner\n@@ -51,9 +51,9 @@ result = await Runner.run(agent, \"What's the weather in Tokyo?\")\n print(result.context_wrapper.usage.total_tokens)\n ```\n \n-## 按请求的用量追踪\n+## 按请求的使用量追踪\n \n-SDK 会在 `request_usage_entries` 中自动追踪每次 API 请求的用量，便于进行精细的成本计算和监控上下文窗口消耗。\n+SDK 会在 `request_usage_entries` 中自动追踪每次 API 请求的使用量，便于进行精细的成本计算和监控上下文窗口消耗。\n \n ```python\n result = await Runner.run(agent, \"What's the weather in Tokyo?\")\n@@ -62,9 +62,9 @@ for i, request in enumerate(result.context_wrapper.usage.request_usage_entries):\n     print(f\"Request {i + 1}: {request.input_tokens} in, {request.output_tokens} out\")\n ```\n \n-## 使用会话时访问用量\n+## 在会话中访问使用量\n \n-当你使用 `Session`（如 `SQLiteSession`）时，每次调用 `Runner.run(...)` 都会返回该次运行的用量。会话会为上下文维护对话历史，但每次运行的用量彼此独立。\n+当你使用 `Session`（例如 `SQLiteSession`）时，每次调用 `Runner.run(...)` 都会返回该次运行的使用量。会话会为上下文维护对话历史，但每次运行的使用量彼此独立。\n \n ```python\n session = SQLiteSession(\"my_conversation\")\n@@ -76,11 +76,11 @@ second = await Runner.run(agent, \"Can you elaborate?\", session=session)\n print(second.context_wrapper.usage.total_tokens)  # Usage for second run\n ```\n \n-请注意，尽管会话会在运行之间保留对话上下文，但每次 `Runner.run()` 调用返回的用量指标仅代表该次执行。在会话中，先前消息可能会作为输入再次提供给每次运行，这会影响后续轮次的输入 token 计数。\n+请注意，虽然会话会在运行之间保留对话上下文，但每次 `Runner.run()` 调用返回的使用量指标仅代表该次执行。在会话中，先前消息可能会在每次运行时重新作为输入提供，这会影响后续轮次的输入 token 计数。\n \n-## 在钩子中使用用量\n+## 在钩子中使用使用量\n \n-如果你在使用 `RunHooks`，传入每个钩子的 `context` 对象包含 `usage`。这使你可以在关键生命周期时刻记录用量。\n+如果你在使用 `RunHooks`，传递给每个钩子的 `context` 对象包含 `usage`。这使你可以在关键生命周期时刻记录使用量。\n \n ```python\n class MyHooks(RunHooks):\n@@ -91,9 +91,9 @@ class MyHooks(RunHooks):\n \n ## API 参考\n \n-详见以下 API 文档：\n+如需详细的 API 文档，请参阅：\n \n-- [`Usage`][agents.usage.Usage] - 用量追踪数据结构\n-- [`RequestUsage`][agents.usage.RequestUsage] - 按请求的用量明细\n-- [`RunContextWrapper`][agents.run.RunContextWrapper] - 从运行上下文访问用量\n-- [`RunHooks`][agents.run.RunHooks] - 接入用量追踪的生命周期\n\\ No newline at end of file\n+- [`Usage`][agents.usage.Usage] - 使用量追踪数据结构\n+- [`RequestUsage`][agents.usage.RequestUsage] - 按请求的使用量详情\n+- [`RunContextWrapper`][agents.run.RunContextWrapper] - 从运行上下文访问使用量\n+- [`RunHooks`][agents.run.RunHooks] - 挂载到使用量追踪的生命周期\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Fusage.md",
        "sha": "07c18f1298be073919ac9620c6833ad2a28513a0",
        "status": "modified"
      },
      {
        "additions": 14,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Fvisualization.md",
        "changes": 28,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fzh%2Fvisualization.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 14,
        "filename": "docs/zh/visualization.md",
        "patch": "@@ -4,7 +4,7 @@ search:\n ---\n # 智能体可视化\n \n-智能体可视化允许你使用 **Graphviz** 生成智能体及其关系的结构化图形表示。这有助于理解在应用中智能体、工具与任务转移如何交互。\n+智能体可视化允许你使用 **Graphviz** 生成智能体及其关系的结构化图形表示。这有助于理解在应用中智能体、工具和任务转移的交互方式。\n \n ## 安装\n \n@@ -18,12 +18,12 @@ pip install \"openai-agents[viz]\"\n \n 你可以使用 `draw_graph` 函数生成智能体可视化。该函数会创建一个有向图，其中：\n \n-- **智能体** 用黄色方框表示。\n-- **MCP 服务** 用灰色方框表示。\n-- **工具** 用绿色椭圆表示。\n-- **任务转移** 用从一个智能体指向另一个智能体的有向边表示。\n+- **智能体** 显示为黄色方框。\n+- **MCP 服务** 显示为灰色方框。\n+- **工具** 显示为绿色椭圆。\n+- **任务转移** 是从一个智能体指向另一个智能体的有向边。\n \n-### 用法示例\n+### 使用示例\n \n ```python\n import os\n@@ -67,9 +67,9 @@ triage_agent = Agent(\n draw_graph(triage_agent)\n ```\n \n-![智能体图](../assets/images/graph.png)\n+![Agent Graph](../assets/images/graph.png)\n \n-这会生成一个图，直观展示 **triage agent** 的结构及其与子智能体和工具的连接关系。\n+这将生成一个图形，直观展示 **分诊智能体** 的结构以及它与子智能体和工具的连接关系。\n \n \n ## 可视化说明\n@@ -82,17 +82,17 @@ draw_graph(triage_agent)\n - 用灰色填充的 **矩形** 表示 MCP 服务。\n - 表示交互的有向边：\n   - **实线箭头** 表示智能体之间的任务转移。\n-  - **虚线点状箭头** 表示工具调用。\n-  - **虚线箭头** 表示 MCP 服务调用。\n-- 一个表示执行终止位置的 **结束节点**（`__end__`）。\n+  - **虚线箭头** 表示工具调用。\n+  - **短划线箭头** 表示对 MCP 服务的调用。\n+- 一个表示执行结束位置的 **结束节点**（`__end__`）。\n \n-**注意：**MCP 服务仅在较新版本的\n-`agents` 包中渲染（在 **v0.2.8** 中已验证）。如果你在可视化中未看到 MCP 方框，请升级到最新版本。\n+**注意：** MCP 服务在近期版本的\n+`agents` 包中会被渲染（已在 **v0.2.8** 验证）。如果你的可视化中没有看到 MCP 方框，请升级到最新版本。\n \n ## 图形自定义\n \n ### 显示图形\n-默认情况下，`draw_graph` 会内联显示图形。若要在单独窗口中显示，请编写：\n+默认情况下，`draw_graph` 会内联显示图形。若要在单独窗口中显示，编写如下代码：\n \n ```python\n draw_graph(triage_agent).view()",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Fvisualization.md",
        "sha": "6eef8f74302ebf70b1b80c21f1d2a0b361ea3f5b",
        "status": "modified"
      },
      {
        "additions": 18,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Fvoice%2Fpipeline.md",
        "changes": 36,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fzh%2Fvoice%2Fpipeline.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 18,
        "filename": "docs/zh/voice/pipeline.md",
        "patch": "@@ -2,9 +2,9 @@\n search:\n   exclude: true\n ---\n-# 管道与工作流\n+# 管线与工作流\n \n-[`VoicePipeline`][agents.voice.pipeline.VoicePipeline] 是一个类，可以轻松将你的智能体工作流变成语音应用。你传入一个要运行的工作流，管道会负责转录输入音频、检测音频结束时间、在正确的时机调用你的工作流，并将工作流输出重新转换为音频。\n+[`VoicePipeline`][agents.voice.pipeline.VoicePipeline] 是一个用于将你的智能体工作流快速变成语音应用的类。你传入要运行的工作流，管线会负责转写输入音频、检测音频结束时机、在合适的时间调用你的工作流，并将工作流的输出转换回音频。\n \n ```mermaid\n graph LR\n@@ -32,30 +32,30 @@ graph LR\n \n ```\n \n-## 管道配置\n+## 管线配置\n \n-创建管道时，你可以设置以下内容：\n+创建管线时，你可以设置以下内容：\n \n-1. [`workflow`][agents.voice.workflow.VoiceWorkflowBase]：每当有新音频被转录时运行的代码。\n-2. 使用的 [`speech-to-text`][agents.voice.model.STTModel] 和 [`text-to-speech`][agents.voice.model.TTSModel] 模型。\n-3. [`config`][agents.voice.pipeline_config.VoicePipelineConfig]：用于配置以下内容：\n-    - 模型提供者，可将模型名称映射到模型\n+1. [`workflow`][agents.voice.workflow.VoiceWorkflowBase]：每当有新的音频被转写时运行的代码。\n+2. 所使用的 [`speech-to-text`][agents.voice.model.STTModel] 和 [`text-to-speech`][agents.voice.model.TTSModel] 模型。\n+3. [`config`][agents.voice.pipeline_config.VoicePipelineConfig]：用于配置如下内容：\n+    - 模型提供方，可将模型名称映射到实际模型\n     - 追踪，包括是否禁用追踪、是否上传音频文件、工作流名称、追踪 ID 等\n-    - TTS 和 STT 模型的设置，例如使用的 prompt、语言和数据类型\n+    - TTS 与 STT 模型的设置，如提示词、语言以及使用的数据类型\n \n-## 运行管道\n+## 运行管线\n \n-你可以通过 [`run()`][agents.voice.pipeline.VoicePipeline.run] 方法运行管道，它允许你以两种形式传入音频输入：\n+你可以通过 [`run()`][agents.voice.pipeline.VoicePipeline.run] 方法运行管线，它允许以两种形式传入音频输入：\n \n-1. [`AudioInput`][agents.voice.input.AudioInput] 适用于你已经拥有完整音频转录时，仅需为其生成结果的场景。这在不需要检测说话者何时说完的情况下很有用；例如，当你有预先录制的音频，或在“按住说话”的应用中可以明确知道用户何时说完。\n-2. [`StreamedAudioInput`][agents.voice.input.StreamedAudioInput] 适用于可能需要检测用户何时说完的情况。它允许你在检测到时推送音频分片，语音管道将通过“活动检测”过程在正确的时机自动运行智能体工作流。\n+1. [`AudioInput`][agents.voice.input.AudioInput]：当你已有完整的音频转写，只需生成对应结果时使用。适用于不需要检测说话者何时结束的场景；例如，处理预录音频，或在按键说话应用中用户结束说话的时机很明确。\n+2. [`StreamedAudioInput`][agents.voice.input.StreamedAudioInput]：当你可能需要检测用户何时说完时使用。它允许你在检测到音频片段时逐步推送，语音管线会通过“activity detection（活动检测）”在正确的时间自动运行智能体工作流。\n \n ## 结果\n \n-语音管道运行的结果是一个 [`StreamedAudioResult`][agents.voice.result.StreamedAudioResult]。这是一个对象，允许你在事件发生时进行流式传输。存在几种 [`VoiceStreamEvent`][agents.voice.events.VoiceStreamEvent] 类型，包括：\n+一次语音管线运行的结果是 [`StreamedAudioResult`][agents.voice.result.StreamedAudioResult]。这是一个可随事件发生而进行流式传输的对象。包含以下几类 [`VoiceStreamEvent`][agents.voice.events.VoiceStreamEvent]：\n \n-1. [`VoiceStreamEventAudio`][agents.voice.events.VoiceStreamEventAudio]，包含一段音频分片。\n-2. [`VoiceStreamEventLifecycle`][agents.voice.events.VoiceStreamEventLifecycle]，通知你回合开始或结束等生命周期事件。\n+1. [`VoiceStreamEventAudio`][agents.voice.events.VoiceStreamEventAudio]，包含一段音频数据。\n+2. [`VoiceStreamEventLifecycle`][agents.voice.events.VoiceStreamEventLifecycle]，用于通知诸如轮次开始或结束等生命周期事件。\n 3. [`VoiceStreamEventError`][agents.voice.events.VoiceStreamEventError]，为错误事件。\n \n ```python\n@@ -74,6 +74,6 @@ async for event in result.stream():\n \n ## 最佳实践\n \n-### 中断\n+### 打断\n \n-Agents SDK 目前不支持对 [`StreamedAudioInput`][agents.voice.input.StreamedAudioInput] 的任何内置中断支持。相反，对于每个检测到的回合，它都会触发对你的工作流的单独运行。如果你想在应用内处理中断，你可以监听 [`VoiceStreamEventLifecycle`][agents.voice.events.VoiceStreamEventLifecycle] 事件。`turn_started` 表示新的回合已被转录并开始处理。`turn_ended` 会在相应回合的所有音频分发完毕后触发。你可以利用这些事件在模型开始一个回合时静音说话者的麦克风，并在你刷新完该回合的所有相关音频后取消静音。\n\\ No newline at end of file\n+Agents SDK 目前对 [`StreamedAudioInput`][agents.voice.input.StreamedAudioInput] 尚无内置的打断支持。相反，它会针对每个检测到的轮次单独触发一次工作流运行。如果你希望在应用内处理打断，可以监听 [`VoiceStreamEventLifecycle`][agents.voice.events.VoiceStreamEventLifecycle] 事件。`turn_started` 表示新的轮次已被转写且处理开始；`turn_ended` 会在相应轮次的所有音频分发完成后触发。你可以利用这些事件在模型开始一个轮次时静音说话者的麦克风，并在你将该轮次的相关音频全部发送完毕后取消静音。\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Fvoice%2Fpipeline.md",
        "sha": "71f012bd0e3dee3156947e72bb480677c3050072",
        "status": "modified"
      },
      {
        "additions": 9,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Fvoice%2Fquickstart.md",
        "changes": 18,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fzh%2Fvoice%2Fquickstart.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 9,
        "filename": "docs/zh/voice/quickstart.md",
        "patch": "@@ -6,18 +6,18 @@ search:\n \n ## 先决条件\n \n-请先完成 Agents SDK 的[快速开始说明](../quickstart.md)，并设置虚拟环境。然后，从 SDK 安装可选的语音依赖：\n+请确保你已按照 Agents SDK 的基础[快速开始说明](../quickstart.md)完成设置，并创建了虚拟环境。然后从 SDK 安装可选的语音依赖项：\n \n ```bash\n pip install 'openai-agents[voice]'\n ```\n \n ## 概念\n \n-需要了解的主要概念是一个 [`VoicePipeline`][agents.voice.pipeline.VoicePipeline]，它是一个包含三步的流程：\n+这里的核心概念是一个[`VoicePipeline`][agents.voice.pipeline.VoicePipeline]，它包含 3 个步骤：\n \n 1. 运行语音转文本模型，将音频转换为文本。\n-2. 运行你的代码（通常是一个智能体工作流）以生成结果。\n+2. 运行你的代码（通常是智能体工作流）以生成结果。\n 3. 运行文本转语音模型，将结果文本转换回音频。\n \n ```mermaid\n@@ -48,7 +48,7 @@ graph LR\n \n ## 智能体\n \n-首先，我们来设置一些智能体。如果你已经使用此 SDK 构建过智能体，这部分应该很熟悉。我们将创建几个智能体、一次任务转移，以及一个工具。\n+首先，让我们设置一些智能体。如果你已经使用该 SDK 构建过智能体，这部分应该很熟悉。我们将使用几个智能体、一次任务转移，以及一个工具。\n \n ```python\n import asyncio\n@@ -90,16 +90,16 @@ agent = Agent(\n )\n ```\n \n-## 语音流水线\n+## 语音管线\n \n-我们将设置一个简单的语音流水线，使用 [`SingleAgentVoiceWorkflow`][agents.voice.workflow.SingleAgentVoiceWorkflow] 作为工作流。\n+我们将设置一个简单的语音管线，使用[`SingleAgentVoiceWorkflow`][agents.voice.workflow.SingleAgentVoiceWorkflow]作为工作流。\n \n ```python\n from agents.voice import SingleAgentVoiceWorkflow, VoicePipeline\n pipeline = VoicePipeline(workflow=SingleAgentVoiceWorkflow(agent))\n ```\n \n-## 运行流水线\n+## 运行管线\n \n ```python\n import numpy as np\n@@ -124,7 +124,7 @@ async for event in result.stream():\n \n ```\n \n-## 整合到一起\n+## 汇总\n \n ```python\n import asyncio\n@@ -195,4 +195,4 @@ if __name__ == \"__main__\":\n     asyncio.run(main())\n ```\n \n-如果你运行此示例，智能体会对你说话！查看 [examples/voice/static](https://github.com/openai/openai-agents-python/tree/main/examples/voice/static) 中的示例，体验一个你可以亲自与智能体对话的演示。\n\\ No newline at end of file\n+如果你运行此示例，智能体会对你说话！查看[code examples/voice/static](https://github.com/openai/openai-agents-python/tree/main/examples/voice/static)中的示例，体验你亲自与智能体对话的演示。\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Fvoice%2Fquickstart.md",
        "sha": "c75dc395f3ae30621fdedc666d2ff436f91a1b1b",
        "status": "modified"
      },
      {
        "additions": 7,
        "blob_url": "https://github.com/openai/openai-agents-python/blob/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Fvoice%2Ftracing.md",
        "changes": 14,
        "contents_url": "https://api.github.com/repos/openai/openai-agents-python/contents/docs%2Fzh%2Fvoice%2Ftracing.md?ref=cad7ee04e65a03cc994c53d4a0b4698fc66613db",
        "deletions": 7,
        "filename": "docs/zh/voice/tracing.md",
        "patch": "@@ -4,15 +4,15 @@ search:\n ---\n # 追踪\n \n-与[智能体的追踪方式](../tracing.md)类似，语音流水线也会被自动追踪。\n+就像[智能体的追踪方式](../tracing.md)一样，语音流水线也会被自动追踪。\n \n-你可以参考上面的追踪文档了解基本信息，也可以通过[`VoicePipelineConfig`][agents.voice.pipeline_config.VoicePipelineConfig]对流水线的追踪进行额外配置。\n+你可以参考上面的追踪文档获取基础信息，此外还可以通过[`VoicePipelineConfig`][agents.voice.pipeline_config.VoicePipelineConfig]对流水线的追踪进行配置。\n \n-与追踪相关的关键字段有：\n+与追踪相关的关键字段包括：\n \n--   [`tracing_disabled`][agents.voice.pipeline_config.VoicePipelineConfig.tracing_disabled]: 控制是否禁用追踪。默认启用追踪。\n--   [`trace_include_sensitive_data`][agents.voice.pipeline_config.VoicePipelineConfig.trace_include_sensitive_data]: 控制追踪是否包含潜在敏感数据，例如音频转写文本。这仅针对语音流水线，不涉及你的工作流内部的任何内容。\n+-   [`tracing_disabled`][agents.voice.pipeline_config.VoicePipelineConfig.tracing_disabled]: 控制是否禁用追踪。默认情况下，追踪是启用的。\n+-   [`trace_include_sensitive_data`][agents.voice.pipeline_config.VoicePipelineConfig.trace_include_sensitive_data]: 控制追踪是否包含可能的敏感数据，例如音频转写。此项仅针对语音流水线，不涉及你的工作流内部发生的任何内容。\n -   [`trace_include_sensitive_audio_data`][agents.voice.pipeline_config.VoicePipelineConfig.trace_include_sensitive_audio_data]: 控制追踪是否包含音频数据。\n -   [`workflow_name`][agents.voice.pipeline_config.VoicePipelineConfig.workflow_name]: 追踪工作流的名称。\n--   [`group_id`][agents.voice.pipeline_config.VoicePipelineConfig.group_id]: 追踪的`group_id`，可用于关联多个追踪。\n--   [`trace_metadata`][agents.voice.pipeline_config.VoicePipelineConfig.tracing_disabled]: 要随追踪一起包含的额外元数据。\n\\ No newline at end of file\n+-   [`group_id`][agents.voice.pipeline_config.VoicePipelineConfig.group_id]: 该追踪的`group_id`，用于将多个追踪关联起来。\n+-   [`trace_metadata`][agents.voice.pipeline_config.VoicePipelineConfig.tracing_disabled]: 随追踪一起包含的附加元数据。\n\\ No newline at end of file",
        "raw_url": "https://github.com/openai/openai-agents-python/raw/cad7ee04e65a03cc994c53d4a0b4698fc66613db/docs%2Fzh%2Fvoice%2Ftracing.md",
        "sha": "1feb9a38b47eb4394d737a2dc4a20e895fb662bc",
        "status": "modified"
      }
    ],
    "status": 200
  },
  "started_at": "2026-01-20T04:54:39.185662Z"
}
